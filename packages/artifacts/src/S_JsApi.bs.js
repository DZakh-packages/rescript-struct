// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml_option = require("rescript/lib/js/caml_option.js");
var S_Core$RescriptStruct = require("./S_Core.bs.js");

function toJsResult(result) {
  if (result.TAG === "Ok") {
    return {
            success: true,
            value: result._0
          };
  } else {
    return {
            success: false,
            error: result._0
          };
  }
}

function transform(struct, maybeParser, maybeSerializer) {
  return S_Core$RescriptStruct.transform(struct, (function (s) {
                return {
                        p: maybeParser !== undefined ? (function (v) {
                              return maybeParser(v, s);
                            }) : undefined,
                        s: maybeSerializer !== undefined ? (function (v) {
                              return maybeSerializer(v, s);
                            }) : undefined
                      };
              }));
}

function refine(struct, refiner) {
  return S_Core$RescriptStruct.refine(struct, (function (s) {
                return function (v) {
                  refiner(v, s);
                };
              }));
}

function noop(a) {
  return a;
}

function asyncParserRefine(struct, refine) {
  return S_Core$RescriptStruct.transform(struct, (function (s) {
                return {
                        a: (function (v) {
                            return function () {
                              return refine(v, s).then(function () {
                                          return v;
                                        });
                            };
                          }),
                        s: noop
                      };
              }));
}

function optional(struct, maybeOr) {
  var struct$1 = S_Core$RescriptStruct.option(struct);
  if (maybeOr === undefined) {
    return struct$1;
  }
  var or = Caml_option.valFromOption(maybeOr);
  if (typeof or === "function") {
    return S_Core$RescriptStruct.$$Option.getOrWith(struct$1, or);
  } else {
    return S_Core$RescriptStruct.$$Option.getOr(struct$1, or);
  }
}

function tuple(definer) {
  if (typeof definer === "function") {
    return S_Core$RescriptStruct.tuple(definer);
  } else {
    return S_Core$RescriptStruct.tuple(function (s) {
                return definer.map(function (struct, idx) {
                            return s.i(idx, struct);
                          });
              });
  }
}

function custom(name, maybeParser, maybeSerializer, param) {
  return S_Core$RescriptStruct.custom(name, (function (s) {
                return {
                        p: maybeParser !== undefined ? (function (v) {
                              return maybeParser(v, s);
                            }) : undefined,
                        s: maybeSerializer !== undefined ? (function (v) {
                              return maybeSerializer(v, s);
                            }) : undefined
                      };
              }));
}

function object(definer) {
  if (typeof definer === "function") {
    return S_Core$RescriptStruct.object(definer);
  } else {
    return S_Core$RescriptStruct.object(function (s) {
                var definition = {};
                var fieldNames = Object.keys(definer);
                for(var idx = 0 ,idx_finish = fieldNames.length; idx < idx_finish; ++idx){
                  var fieldName = fieldNames[idx];
                  var struct = definer[fieldName];
                  definition[fieldName] = s.f(fieldName, struct);
                }
                return definition;
              });
  }
}

function parse(struct, data) {
  return toJsResult(S_Core$RescriptStruct.parseAnyWith(data, struct));
}

function parseOrThrow(struct, data) {
  return S_Core$RescriptStruct.parseAnyOrRaiseWith(data, struct);
}

function parseAsync(struct, data) {
  return S_Core$RescriptStruct.parseAnyAsyncWith(data, struct).then(toJsResult);
}

function serialize(struct, value) {
  return toJsResult(S_Core$RescriptStruct.serializeToUnknownWith(value, struct));
}

function serializeOrThrow(struct, value) {
  return S_Core$RescriptStruct.serializeToUnknownOrRaiseWith(value, struct);
}

exports.optional = optional;
exports.tuple = tuple;
exports.custom = custom;
exports.asyncParserRefine = asyncParserRefine;
exports.refine = refine;
exports.transform = transform;
exports.object = object;
exports.parse = parse;
exports.parseOrThrow = parseOrThrow;
exports.parseAsync = parseAsync;
exports.serialize = serialize;
exports.serializeOrThrow = serializeOrThrow;
/* S_Core-RescriptStruct Not a pure module */
