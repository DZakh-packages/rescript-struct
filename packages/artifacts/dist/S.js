'use strict';

var Caml_option = require('rescript/lib/js/caml_option.js');
var S = require('./../src/S_Core.bs.js');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var Caml_option__namespace = /*#__PURE__*/_interopNamespaceDefault(Caml_option);
var S__namespace = /*#__PURE__*/_interopNamespaceDefault(S);

// Generated by ReScript, PLEASE EDIT WITH CARE

function toJsResult(result) {
  if (result.TAG === "Ok") {
    return {
            success: true,
            value: result._0
          };
  } else {
    return {
            success: false,
            error: result._0
          };
  }
}

function transform$1(struct, maybeParser, maybeSerializer) {
  return S__namespace.transform(struct, (function (s) {
                return {
                        p: maybeParser !== undefined ? (function (v) {
                              return maybeParser(v, s);
                            }) : undefined,
                        s: maybeSerializer !== undefined ? (function (v) {
                              return maybeSerializer(v, s);
                            }) : undefined
                      };
              }));
}

function refine$1(struct, refiner) {
  return S__namespace.refine(struct, (function (s) {
                return function (v) {
                  refiner(v, s);
                };
              }));
}

function noop(a) {
  return a;
}

function asyncParserRefine$1(struct, refine) {
  return S__namespace.transform(struct, (function (s) {
                return {
                        a: (function (v) {
                            return function () {
                              return refine(v, s).then(function () {
                                          return v;
                                        });
                            };
                          }),
                        s: noop
                      };
              }));
}

function optional$1(struct, maybeOr) {
  var struct$1 = S__namespace.option(struct);
  if (maybeOr === undefined) {
    return struct$1;
  }
  var or = Caml_option__namespace.valFromOption(maybeOr);
  if (typeof or === "function") {
    return S__namespace.$$Option.getOrWith(struct$1, or);
  } else {
    return S__namespace.$$Option.getOr(struct$1, or);
  }
}

function tuple$1(definer) {
  if (typeof definer === "function") {
    return S__namespace.tuple(definer);
  } else {
    return S__namespace.tuple(function (s) {
                return definer.map(function (struct, idx) {
                            return s.i(idx, struct);
                          });
              });
  }
}

function custom$1(name, maybeParser, maybeSerializer, param) {
  return S__namespace.custom(name, (function (s) {
                return {
                        p: maybeParser !== undefined ? (function (v) {
                              return maybeParser(v, s);
                            }) : undefined,
                        s: maybeSerializer !== undefined ? (function (v) {
                              return maybeSerializer(v, s);
                            }) : undefined
                      };
              }));
}

function object$1(definer) {
  if (typeof definer === "function") {
    return S__namespace.object(definer);
  } else {
    return S__namespace.object(function (s) {
                var definition = {};
                var fieldNames = Object.keys(definer);
                for(var idx = 0 ,idx_finish = fieldNames.length; idx < idx_finish; ++idx){
                  var fieldName = fieldNames[idx];
                  var struct = definer[fieldName];
                  definition[fieldName] = s.f(fieldName, struct);
                }
                return definition;
              });
  }
}

function parse$1(struct, data) {
  return toJsResult(S__namespace.parseAnyWith(data, struct));
}

function parseOrThrow$1(struct, data) {
  return S__namespace.parseAnyOrRaiseWith(data, struct);
}

function parseAsync$1(struct, data) {
  return S__namespace.parseAnyAsyncWith(data, struct).then(toJsResult);
}

function serialize$1(struct, value) {
  return toJsResult(S__namespace.serializeToUnknownWith(value, struct));
}

function serializeOrThrow$1(struct, value) {
  return S__namespace.serializeToUnknownOrRaiseWith(value, struct);
}
/* S_Core-RescriptStruct Not a pure module */

const Error = S__namespace.$$Error.$$class;
const string = S__namespace.string;
const boolean = S__namespace.bool;
const integer = S__namespace.$$int;
const number = S__namespace.$$float;
const json = S__namespace.json;
const never = S__namespace.never;
const unknown = S__namespace.unknown;
const undefined$1 = S__namespace.unit;
const optional = optional$1;
const nullable = S__namespace.$$null;
const array = S__namespace.array;
const record = S__namespace.dict;
const jsonString = S__namespace.jsonString;
const union = S__namespace.union;
const object = object$1;
const Object$1 = S__namespace.$$Object;
const String = S__namespace.$$String;
const Number = S__namespace.Float;
const Array = S__namespace.$$Array;
const custom = custom$1;
const literal = S__namespace.literal;
const tuple = tuple$1;
const asyncParserRefine = asyncParserRefine$1;
const refine = refine$1;
const transform = transform$1;
const description = S__namespace.description;
const describe = S__namespace.describe;
const parse = parse$1;
const parseOrThrow = parseOrThrow$1;
const parseAsync = parseAsync$1;
const serialize = serialize$1;
const serializeOrThrow = serializeOrThrow$1;

exports.Array = Array;
exports.Error = Error;
exports.Number = Number;
exports.Object = Object$1;
exports.String = String;
exports.array = array;
exports.asyncParserRefine = asyncParserRefine;
exports.boolean = boolean;
exports.custom = custom;
exports.describe = describe;
exports.description = description;
exports.integer = integer;
exports.json = json;
exports.jsonString = jsonString;
exports.literal = literal;
exports.never = never;
exports.nullable = nullable;
exports.number = number;
exports.object = object;
exports.optional = optional;
exports.parse = parse;
exports.parseAsync = parseAsync;
exports.parseOrThrow = parseOrThrow;
exports.record = record;
exports.refine = refine;
exports.serialize = serialize;
exports.serializeOrThrow = serializeOrThrow;
exports.string = string;
exports.transform = transform;
exports.tuple = tuple;
exports.undefined = undefined$1;
exports.union = union;
exports.unknown = unknown;
