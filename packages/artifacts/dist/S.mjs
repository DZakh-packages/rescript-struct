import * as Caml_option from 'rescript/lib/es6/caml_option.js';
import * as S from './../src/S_Core.bs.mjs';

// Generated by ReScript, PLEASE EDIT WITH CARE

function toJsResult(result) {
  if (result.TAG === "Ok") {
    return {
            success: true,
            value: result._0
          };
  } else {
    return {
            success: false,
            error: result._0
          };
  }
}

function transform$1(struct, maybeParser, maybeSerializer) {
  return S.transform(struct, (function (s) {
                return {
                        p: maybeParser !== undefined ? (function (v) {
                              return maybeParser(v, s);
                            }) : undefined,
                        s: maybeSerializer !== undefined ? (function (v) {
                              return maybeSerializer(v, s);
                            }) : undefined
                      };
              }));
}

function refine$1(struct, refiner) {
  return S.refine(struct, (function (s) {
                return function (v) {
                  refiner(v, s);
                };
              }));
}

function noop(a) {
  return a;
}

function asyncParserRefine$1(struct, refine) {
  return S.transform(struct, (function (s) {
                return {
                        a: (function (v) {
                            return function () {
                              return refine(v, s).then(function () {
                                          return v;
                                        });
                            };
                          }),
                        s: noop
                      };
              }));
}

function optional$1(struct, maybeOr) {
  var struct$1 = S.option(struct);
  if (maybeOr === undefined) {
    return struct$1;
  }
  var or = Caml_option.valFromOption(maybeOr);
  if (typeof or === "function") {
    return S.$$Option.getOrWith(struct$1, or);
  } else {
    return S.$$Option.getOr(struct$1, or);
  }
}

function tuple$1(definer) {
  if (typeof definer === "function") {
    return S.tuple(definer);
  } else {
    return S.tuple(function (s) {
                return definer.map(function (struct, idx) {
                            return s.i(idx, struct);
                          });
              });
  }
}

function custom$1(name, maybeParser, maybeSerializer, param) {
  return S.custom(name, (function (s) {
                return {
                        p: maybeParser !== undefined ? (function (v) {
                              return maybeParser(v, s);
                            }) : undefined,
                        s: maybeSerializer !== undefined ? (function (v) {
                              return maybeSerializer(v, s);
                            }) : undefined
                      };
              }));
}

function object$1(definer) {
  if (typeof definer === "function") {
    return S.object(definer);
  } else {
    return S.object(function (s) {
                var definition = {};
                var fieldNames = Object.keys(definer);
                for(var idx = 0 ,idx_finish = fieldNames.length; idx < idx_finish; ++idx){
                  var fieldName = fieldNames[idx];
                  var struct = definer[fieldName];
                  definition[fieldName] = s.f(fieldName, struct);
                }
                return definition;
              });
  }
}

function parse$1(struct, data) {
  return toJsResult(S.parseAnyWith(data, struct));
}

function parseOrThrow$1(struct, data) {
  return S.parseAnyOrRaiseWith(data, struct);
}

function parseAsync$1(struct, data) {
  return S.parseAnyAsyncWith(data, struct).then(toJsResult);
}

function serialize$1(struct, value) {
  return toJsResult(S.serializeToUnknownWith(value, struct));
}

function serializeOrThrow$1(struct, value) {
  return S.serializeToUnknownOrRaiseWith(value, struct);
}
/* S_Core-RescriptStruct Not a pure module */

const Error = S.$$Error.$$class;
const string = S.string;
const boolean = S.bool;
const integer = S.$$int;
const number = S.$$float;
const json = S.json;
const never = S.never;
const unknown = S.unknown;
const undefined$1 = S.unit;
const optional = optional$1;
const nullable = S.$$null;
const array = S.array;
const record = S.dict;
const jsonString = S.jsonString;
const union = S.union;
const object = object$1;
const Object$1 = S.$$Object;
const String = S.$$String;
const Number = S.Float;
const Array = S.$$Array;
const custom = custom$1;
const literal = S.literal;
const tuple = tuple$1;
const asyncParserRefine = asyncParserRefine$1;
const refine = refine$1;
const transform = transform$1;
const description = S.description;
const describe = S.describe;
const parse = parse$1;
const parseOrThrow = parseOrThrow$1;
const parseAsync = parseAsync$1;
const serialize = serialize$1;
const serializeOrThrow = serializeOrThrow$1;

export { Array, Error, Number, Object$1 as Object, String, array, asyncParserRefine, boolean, custom, describe, description, integer, json, jsonString, literal, never, nullable, number, object, optional, parse, parseAsync, parseOrThrow, record, refine, serialize, serializeOrThrow, string, transform, tuple, undefined$1 as undefined, union, unknown };
