// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Js_types from "rescript/lib/es6/js_types.js";
import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

function toName(unknown) {
  var number = Js_types.classify(unknown);
  if (typeof number !== "object") {
    switch (number) {
      case "JSFalse" :
      case "JSTrue" :
          return "Bool";
      case "JSNull" :
          return "Null";
      case "JSUndefined" :
          return "Option";
      
    }
  } else {
    switch (number.TAG) {
      case "JSNumber" :
          if (Number.isNaN(number._0)) {
            return "NaN Literal (NaN)";
          } else {
            return "Float";
          }
      case "JSString" :
          return "String";
      case "JSFunction" :
          return "Function";
      case "JSObject" :
          if (Array.isArray(number._0)) {
            return "Array";
          } else {
            return "Object";
          }
      case "JSSymbol" :
          return "Symbol";
      case "JSBigInt" :
          return "BigInt";
      
    }
  }
}

function test(data) {
  if (typeof data === "number" && data < 2147483648 && data > -2147483649) {
    return data % 1 === 0;
  } else {
    return false;
  }
}

function fromString(string) {
  return JSON.stringify(string);
}

function toArray(path) {
  if (path === "") {
    return [];
  } else {
    return JSON.parse(path.split("\"][\"").join("\",\""));
  }
}

function fromLocation($$location) {
  return "[" + JSON.stringify($$location) + "]";
}

function fromArray(array) {
  var len = array.length;
  if (len !== 1) {
    if (len !== 0) {
      return "[" + array.map(fromString).join("][") + "]";
    } else {
      return "";
    }
  } else {
    return "[" + JSON.stringify(array[0]) + "]";
  }
}

function concat(path, concatedPath) {
  return path + concatedPath;
}

var Exception = /* @__PURE__ */Caml_exceptions.create("S-RescriptStruct.Error.Internal.Exception");

function raise(expected, received, initialPathOpt, param) {
  var initialPath = initialPathOpt !== undefined ? initialPathOpt : "";
  throw {
        RE_EXN_ID: Exception,
        _1: {
          c: {
            TAG: "UnexpectedValue",
            expected: expected === undefined ? "undefined" : JSON.stringify(expected),
            received: received === undefined ? "undefined" : JSON.stringify(received)
          },
          p: initialPath
        },
        Error: new Error()
      };
}

function raise$1(code) {
  throw {
        RE_EXN_ID: Exception,
        _1: {
          c: code,
          p: ""
        },
        Error: new Error()
      };
}

function toParseError(internalError) {
  return {
          operation: "Parsing",
          code: internalError.c,
          path: internalError.p
        };
}

function toSerializeError(internalError) {
  return {
          operation: "Serializing",
          code: internalError.c,
          path: internalError.p
        };
}

function prependPath(error, path) {
  return {
          c: error.c,
          p: path + error.p
        };
}

function panic($$location) {
  throw new Error("[rescript-struct] " + ("For a " + $$location + " either a parser, or a serializer is required"));
}

function panic$1(param) {
  throw new Error("[rescript-struct] Unreachable");
}

function toReason(nestedLevelOpt, error) {
  var nestedLevel = nestedLevelOpt !== undefined ? nestedLevelOpt : 0;
  var reason = error.code;
  if (typeof reason !== "object") {
    switch (reason) {
      case "MissingParser" :
          return "Struct parser is missing";
      case "MissingSerializer" :
          return "Struct serializer is missing";
      case "UnexpectedAsync" :
          return "Encountered unexpected asynchronous transform or refine. Use S.parseAsyncWith instead of S.parseWith";
      
    }
  } else {
    switch (reason.TAG) {
      case "OperationFailed" :
          return reason._0;
      case "UnexpectedType" :
      case "UnexpectedValue" :
          break;
      case "TupleSize" :
          return "Expected Tuple with " + reason.expected.toString() + " items, received " + reason.received.toString();
      case "ExcessField" :
          return "Encountered disallowed excess key \"" + reason._0 + "\" on an object. Use Deprecated to ignore a specific field, or S.Object.strip to ignore excess keys completely";
      case "InvalidUnion" :
          var lineBreak = "\n" + " ".repeat((nestedLevel << 1));
          var array = reason._0.map(function (error) {
                var reason = toReason(nestedLevel + 1, error);
                var nonEmptyPath = error.path;
                var $$location = nonEmptyPath === "" ? "" : "Failed at " + nonEmptyPath + ". ";
                return "- " + $$location + reason;
              });
          var reasons = Array.from(new Set(array));
          return "Invalid union with following errors" + lineBreak + reasons.join(lineBreak);
      case "InvalidJsonStruct" :
          return "The struct " + reason.received + " is not compatible with JSON";
      
    }
  }
  return "Expected " + reason.expected + ", received " + reason.received;
}

function toString(error) {
  var match = error.operation;
  var operation;
  operation = match === "Serializing" ? "serializing" : "parsing";
  var reason = toReason(undefined, error);
  var nonEmptyPath = error.path;
  var pathText = nonEmptyPath === "" ? "root" : nonEmptyPath;
  return "Failed " + operation + " at " + pathText + ". Reason: " + reason;
}

function advancedFail(error) {
  throw {
        RE_EXN_ID: Exception,
        _1: {
          c: error.code,
          p: error.path
        },
        Error: new Error()
      };
}

function fail(pathOpt, message) {
  var path = pathOpt !== undefined ? pathOpt : "";
  throw {
        RE_EXN_ID: Exception,
        _1: {
          c: {
            TAG: "OperationFailed",
            _0: message
          },
          p: path
        },
        Error: new Error()
      };
}

var Raised = /* @__PURE__ */Caml_exceptions.create("S-RescriptStruct.Raised");

var emptyMetadataMap = {};

function raiseUnexpectedTypeError(input, struct) {
  return raise$1({
              TAG: "UnexpectedType",
              expected: struct.n,
              received: toName(input)
            });
}

function planSyncTransformation(ctx, transformation) {
  var prevSyncTransformation = ctx.t;
  var prevAsyncTransformation = ctx.a;
  var match = ctx.p;
  switch (match) {
    case "NoTransformation" :
        ctx.p = "OnlySync";
        ctx.t = transformation;
        return ;
    case "OnlySync" :
        ctx.t = (function (input) {
            return transformation(prevSyncTransformation(input));
          });
        return ;
    case "OnlyAsync" :
    case "SyncAndAsync" :
        break;
    
  }
  ctx.a = (function (input) {
      return prevAsyncTransformation(input).then(transformation);
    });
}

function planAsyncTransformation(ctx, transformation) {
  var prevAsyncTransformation = ctx.a;
  var match = ctx.p;
  switch (match) {
    case "NoTransformation" :
        ctx.p = "OnlyAsync";
        ctx.a = transformation;
        return ;
    case "OnlySync" :
        ctx.p = "SyncAndAsync";
        ctx.a = transformation;
        return ;
    case "OnlyAsync" :
    case "SyncAndAsync" :
        break;
    
  }
  ctx.a = (function (input) {
      return prevAsyncTransformation(input).then(transformation);
    });
}

function planMissingParserTransformation(ctx) {
  planSyncTransformation(ctx, (function (param) {
          return raise$1("MissingParser");
        }));
}

function empty(param) {
  
}

function compile(transformationFactory, struct) {
  var ctx = {
    s: struct,
    p: "NoTransformation",
    t: undefined,
    a: undefined
  };
  transformationFactory(ctx);
  var match = ctx.p;
  switch (match) {
    case "NoTransformation" :
        return "NoOperation";
    case "OnlySync" :
        return {
                TAG: "SyncOperation",
                _0: ctx.t
              };
    case "OnlyAsync" :
        return {
                TAG: "AsyncOperation",
                _0: (function (input) {
                    return function () {
                      return ctx.a(input);
                    };
                  })
              };
    case "SyncAndAsync" :
        return {
                TAG: "AsyncOperation",
                _0: (function (input) {
                    var syncOutput = ctx.t(input);
                    return function () {
                      return ctx.a(syncOutput);
                    };
                  })
              };
    
  }
}

function classify(struct) {
  return struct.t;
}

function name(struct) {
  return struct.n;
}

function getParseOperation(struct) {
  var parseOperationState = struct.r;
  if (typeof parseOperationState !== "number") {
    return parseOperationState;
  }
  if (parseOperationState === 2) {
    return {
            TAG: "SyncOperation",
            _0: (function (input) {
                return struct.p(input);
              })
          };
  }
  if (parseOperationState === 3) {
    return {
            TAG: "AsyncOperation",
            _0: (function (input) {
                return struct.a(input);
              })
          };
  }
  struct.r = parseOperationState === 1 ? 3 : 2;
  var compiledParseOperation = compile(struct.pf, struct);
  struct.r = compiledParseOperation;
  return compiledParseOperation;
}

function getSerializeOperation(struct) {
  var serializeOperationState = struct.e;
  if (typeof serializeOperationState !== "number") {
    return serializeOperationState;
  }
  if (serializeOperationState === 1) {
    return (function (input) {
              return struct.s(input);
            });
  }
  struct.e = 1;
  var fn = compile(struct.sf, struct);
  var compiledSerializeOperation;
  compiledSerializeOperation = typeof fn !== "object" ? undefined : (
      fn.TAG === "SyncOperation" ? fn._0 : panic$1(undefined)
    );
  struct.e = compiledSerializeOperation;
  return compiledSerializeOperation;
}

function $$var(b) {
  b.varCounter = b.varCounter + 1;
  var v = "v" + b.varCounter;
  b.varsAllocation = b.varsAllocation + "," + v;
  return v;
}

function varWithoutAllocation(b) {
  b.varCounter = b.varCounter + 1;
  return "v" + b.varCounter;
}

function internalTransformRethrow(pathVar) {
  return "if(t&&t.RE_EXN_ID===\"S-RescriptStruct.Error.Internal.Exception/1\"){t._1.p=" + pathVar + "+t._1.p}throw t";
}

function syncOperation(b, inputVar, fn, prependPathVar) {
  var outputVar = $$var(b);
  var code = outputVar + "=" + ("e[" + (b.embeded.push(fn) - 1) + "]") + "(" + inputVar + ");";
  var tmp = prependPathVar === "\"\"" ? code : "try{" + code + "}catch(t){" + internalTransformRethrow(prependPathVar) + "}";
  return {
          code: tmp,
          outputVar: outputVar,
          isAsync: false
        };
}

function asyncOperation(b, inputVar, fn, prependPathVar) {
  var outputVar = $$var(b);
  if (prependPathVar === "\"\"") {
    return {
            code: outputVar + "=" + ("e[" + (b.embeded.push(fn) - 1) + "]") + "(" + inputVar + ");",
            outputVar: outputVar,
            isAsync: true
          };
  }
  var syncResultVar = varWithoutAllocation(b);
  var code = "let " + syncResultVar + "=" + ("e[" + (b.embeded.push(fn) - 1) + "]") + "(" + inputVar + ");";
  return {
          code: "try{" + code + outputVar + "=()=>{try{return " + syncResultVar + "().catch(t=>{" + internalTransformRethrow(prependPathVar) + "})}catch(t){" + internalTransformRethrow(prependPathVar) + "}}}catch(t){" + internalTransformRethrow(prependPathVar) + "};",
          outputVar: outputVar,
          isAsync: true
        };
}

function syncTransform(b, inputVar, outputVar, isAsyncInput, fn, isRefineOpt, maybePrependPathVar, param) {
  var isRefine = isRefineOpt !== undefined ? isRefineOpt : false;
  var tmp;
  if (isAsyncInput) {
    var code = outputVar + "=()=>" + inputVar + "().then(" + (
      isRefine ? "t=>{" + ("e[" + (b.embeded.push(fn) - 1) + "]") + "(t);return " + inputVar + "}" : "e[" + (b.embeded.push(fn) - 1) + "]"
    ) + ")";
    tmp = maybePrependPathVar !== undefined && maybePrependPathVar !== "\"\"" ? code + ".catch(t=>{" + internalTransformRethrow(maybePrependPathVar) + "})" : code;
  } else {
    var code$1 = isRefine ? "e[" + (b.embeded.push(fn) - 1) + "](" + inputVar + ");" + outputVar + "=" + inputVar + ";" : outputVar + "=" + ("e[" + (b.embeded.push(fn) - 1) + "]") + "(" + inputVar + ")";
    tmp = maybePrependPathVar !== undefined && maybePrependPathVar !== "\"\"" ? "try{" + code$1 + "}catch(t){" + internalTransformRethrow(maybePrependPathVar) + "}" : code$1;
  }
  return tmp + ";";
}

function asyncTransform(b, inputVar, outputVar, isAsyncInput, fn, isRefineOpt, maybePrependPathVar, param) {
  var isRefine = isRefineOpt !== undefined ? isRefineOpt : false;
  var tmp;
  if (isAsyncInput) {
    var code = inputVar + "().then(" + (
      isRefine ? "t=>" + ("e[" + (b.embeded.push(fn) - 1) + "]") + "(t).then(_=>t)" : "e[" + (b.embeded.push(fn) - 1) + "]"
    ) + ")";
    tmp = maybePrependPathVar !== undefined && maybePrependPathVar !== "\"\"" ? code + ".catch(t=>{" + internalTransformRethrow(maybePrependPathVar) + "})" : code;
  } else {
    var code$1 = "e[" + (b.embeded.push(fn) - 1) + "](" + inputVar + ")" + (
      isRefine ? ".then(_=>" + inputVar + ")" : ""
    );
    tmp = maybePrependPathVar !== undefined && maybePrependPathVar !== "\"\"" ? "{try{return " + code$1 + ".catch(t=>{" + internalTransformRethrow(maybePrependPathVar) + "})}catch(t){" + internalTransformRethrow(maybePrependPathVar) + "}}" : code$1;
  }
  return outputVar + "=()=>" + tmp + ";";
}

function raiseWithArg(b, pathVar, fn, arg) {
  return "e[" + (b.embeded.push(function (path, arg) {
                throw {
                      RE_EXN_ID: Exception,
                      _1: {
                        c: fn(arg),
                        p: path
                      },
                      Error: new Error()
                    };
              }) - 1) + "](" + pathVar + "," + arg + ")";
}

function raise$2(b, pathVar, code) {
  return "e[" + (b.embeded.push(function (path) {
                throw {
                      RE_EXN_ID: Exception,
                      _1: {
                        c: code,
                        p: path
                      },
                      Error: new Error()
                    };
              }) - 1) + "](" + pathVar + ")";
}

function compileParser(b, struct, inputVar, pathVar) {
  var operationFactory = struct.parseOperationFactory;
  if (operationFactory !== undefined) {
    return operationFactory(b, struct, inputVar, pathVar);
  }
  var operation = getParseOperation(struct);
  if (typeof operation !== "object") {
    return {
            code: "",
            outputVar: inputVar,
            isAsync: false
          };
  } else if (operation.TAG === "SyncOperation") {
    return syncOperation(b, inputVar, operation._0, pathVar);
  } else {
    return asyncOperation(b, inputVar, operation._0, pathVar);
  }
}

function compile$1(operationFactory, struct) {
  var intitialInputVar = "i";
  var b = {
    varCounter: -1,
    varsAllocation: "_",
    embeded: []
  };
  var match = operationFactory(b, struct, intitialInputVar, "\"\"");
  struct.isAsyncParseOperation = match.isAsync;
  var inlinedFunction = intitialInputVar + "=>{var " + b.varsAllocation + ";" + match.code + "return " + match.outputVar + "}";
  console.log(inlinedFunction);
  return new Function("e", "return " + inlinedFunction)(b.embeded);
}

function isAsyncParse(struct) {
  var match = getParseOperation(struct);
  if (typeof match !== "object" || match.TAG === "SyncOperation") {
    return false;
  } else {
    return true;
  }
}

function noOperation(input) {
  return input;
}

function initialSerialize(input) {
  var struct = this;
  var fn = getSerializeOperation(struct);
  var compiledSerialize = fn !== undefined ? fn : noOperation;
  struct.s = compiledSerialize;
  return compiledSerialize(input);
}

function validateJsonableStruct(_struct, rootStruct, _isRootOpt, _param) {
  while(true) {
    var isRootOpt = _isRootOpt;
    var struct = _struct;
    var isRoot = isRootOpt !== undefined ? isRootOpt : false;
    if (!(isRoot || rootStruct !== struct)) {
      return ;
    }
    var childrenStructs = struct.t;
    if (typeof childrenStructs !== "object") {
      if (childrenStructs === "Unknown") {
        return raise$1({
                    TAG: "InvalidJsonStruct",
                    received: struct.n
                  });
      } else {
        return ;
      }
    }
    switch (childrenStructs.TAG) {
      case "Literal" :
          var tmp = childrenStructs._0;
          if (typeof tmp === "object") {
            return ;
          }
          switch (tmp) {
            case "EmptyOption" :
            case "NaN" :
                return raise$1({
                            TAG: "InvalidJsonStruct",
                            received: struct.n
                          });
            default:
              return ;
          }
      case "Option" :
          return raise$1({
                      TAG: "InvalidJsonStruct",
                      received: struct.n
                    });
      case "Object" :
          var fieldNames = childrenStructs.fieldNames;
          var fields = childrenStructs.fields;
          for(var idx = 0 ,idx_finish = fieldNames.length; idx < idx_finish; ++idx){
            var fieldName = fieldNames[idx];
            var fieldStruct = fields[fieldName];
            try {
              var s = fieldStruct.t;
              var tmp$1;
              tmp$1 = typeof s !== "object" || s.TAG !== "Option" ? fieldStruct : s._0;
              validateJsonableStruct(tmp$1, rootStruct, undefined, undefined);
            }
            catch (raw_e){
              var e = Caml_js_exceptions.internalToOCamlException(raw_e);
              if (e.RE_EXN_ID === Exception) {
                throw {
                      RE_EXN_ID: Exception,
                      _1: prependPath(e._1, "[" + JSON.stringify(fieldName) + "]"),
                      Error: new Error()
                    };
              }
              throw e;
            }
          }
          return ;
      case "Tuple" :
          childrenStructs._0.forEach(function (childStruct, i) {
                try {
                  return validateJsonableStruct(childStruct, rootStruct, undefined, undefined);
                }
                catch (raw_e){
                  var e = Caml_js_exceptions.internalToOCamlException(raw_e);
                  if (e.RE_EXN_ID === Exception) {
                    var $$location = i.toString();
                    throw {
                          RE_EXN_ID: Exception,
                          _1: prependPath(e._1, "[" + JSON.stringify($$location) + "]"),
                          Error: new Error()
                        };
                  }
                  throw e;
                }
              });
          return ;
      case "Union" :
          childrenStructs._0.forEach(function (childStruct) {
                validateJsonableStruct(childStruct, rootStruct, undefined, undefined);
              });
          return ;
      case "Null" :
      case "Array" :
      case "Dict" :
          break;
      
    }
    _param = undefined;
    _isRootOpt = undefined;
    _struct = childrenStructs._0;
    continue ;
  };
}

function initialSerializeToJson(input) {
  var struct = this;
  try {
    validateJsonableStruct(struct, struct, true, undefined);
    if (struct.s === initialSerialize) {
      var fn = getSerializeOperation(struct);
      var compiledSerialize = fn !== undefined ? fn : noOperation;
      struct.s = compiledSerialize;
    }
    struct.j = struct.s;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Exception) {
      struct.j = (function (param) {
          throw exn;
        });
    } else {
      throw exn;
    }
  }
  return struct.j(input);
}

function intitialParse(input) {
  var struct = this;
  var parseOperationFactory = struct.parseOperationFactory;
  var compiledParse;
  if (parseOperationFactory !== undefined) {
    var compiledParse$1 = compile$1(parseOperationFactory, struct);
    if (struct.isAsyncParseOperation) {
      raise$1("UnexpectedAsync");
    }
    compiledParse = compiledParse$1;
  } else {
    var fn = getParseOperation(struct);
    compiledParse = typeof fn !== "object" ? noOperation : (
        fn.TAG === "SyncOperation" ? fn._0 : (function (param) {
              return raise$1("UnexpectedAsync");
            })
      );
  }
  struct.p = compiledParse;
  return compiledParse(input);
}

function asyncNoopOperation(input) {
  return function () {
    return Promise.resolve(input);
  };
}

function intitialParseAsync(input) {
  var struct = this;
  var parseOperationFactory = struct.parseOperationFactory;
  var compiledParseAsync;
  if (parseOperationFactory !== undefined) {
    var parseOperation = compile$1(parseOperationFactory, struct);
    compiledParseAsync = struct.isAsyncParseOperation ? parseOperation : (function (input) {
          var syncValue = parseOperation(input);
          return function () {
            return Promise.resolve(syncValue);
          };
        });
  } else {
    var fn = getParseOperation(struct);
    if (typeof fn !== "object") {
      compiledParseAsync = asyncNoopOperation;
    } else if (fn.TAG === "SyncOperation") {
      var fn$1 = fn._0;
      compiledParseAsync = (function (input) {
          var syncValue = fn$1(input);
          return function () {
            return Promise.resolve(syncValue);
          };
        });
    } else {
      compiledParseAsync = fn._0;
    }
  }
  struct.a = compiledParseAsync;
  return compiledParseAsync(input);
}

function parseAnyWith(any, struct) {
  try {
    return {
            TAG: "Ok",
            _0: struct.p(any)
          };
  }
  catch (raw_jsError){
    var jsError = Caml_js_exceptions.internalToOCamlException(raw_jsError);
    if (jsError.RE_EXN_ID === Js_exn.$$Error) {
      throw jsError._1;
    }
    if (jsError.RE_EXN_ID === Exception) {
      return {
              TAG: "Error",
              _0: toParseError(jsError._1)
            };
    }
    throw jsError;
  }
}

function parseAnyOrRaiseWith(any, struct) {
  try {
    return struct.p(any);
  }
  catch (raw_jsError){
    var jsError = Caml_js_exceptions.internalToOCamlException(raw_jsError);
    if (jsError.RE_EXN_ID === Js_exn.$$Error) {
      throw jsError._1;
    }
    if (jsError.RE_EXN_ID === Exception) {
      throw {
            RE_EXN_ID: Raised,
            _1: toParseError(jsError._1),
            Error: new Error()
          };
    }
    throw jsError;
  }
}

function asyncPrepareOk(value) {
  return {
          TAG: "Ok",
          _0: value
        };
}

function asyncPrepareError(exn) {
  if (exn.RE_EXN_ID === Exception) {
    return {
            TAG: "Error",
            _0: toParseError(exn._1)
          };
  }
  throw exn;
}

function parseAnyAsyncWith(any, struct) {
  try {
    return struct.a(any)(undefined).then(asyncPrepareOk, asyncPrepareError);
  }
  catch (raw_jsError){
    var jsError = Caml_js_exceptions.internalToOCamlException(raw_jsError);
    if (jsError.RE_EXN_ID === Js_exn.$$Error) {
      throw jsError._1;
    }
    if (jsError.RE_EXN_ID === Exception) {
      return Promise.resolve({
                  TAG: "Error",
                  _0: toParseError(jsError._1)
                });
    }
    throw jsError;
  }
}

function parseAnyAsyncInStepsWith(any, struct) {
  try {
    var asyncFn = struct.a(any);
    return {
            TAG: "Ok",
            _0: (function () {
                return asyncFn(undefined).then(asyncPrepareOk, asyncPrepareError);
              })
          };
  }
  catch (raw_jsError){
    var jsError = Caml_js_exceptions.internalToOCamlException(raw_jsError);
    if (jsError.RE_EXN_ID === Js_exn.$$Error) {
      throw jsError._1;
    }
    if (jsError.RE_EXN_ID === Exception) {
      return {
              TAG: "Error",
              _0: toParseError(jsError._1)
            };
    }
    throw jsError;
  }
}

function serializeToUnknownWith(value, struct) {
  try {
    return {
            TAG: "Ok",
            _0: struct.s(value)
          };
  }
  catch (raw_jsError){
    var jsError = Caml_js_exceptions.internalToOCamlException(raw_jsError);
    if (jsError.RE_EXN_ID === Js_exn.$$Error) {
      throw jsError._1;
    }
    if (jsError.RE_EXN_ID === Exception) {
      return {
              TAG: "Error",
              _0: toSerializeError(jsError._1)
            };
    }
    throw jsError;
  }
}

function serializeOrRaiseWith(value, struct) {
  try {
    return struct.j(value);
  }
  catch (raw_jsError){
    var jsError = Caml_js_exceptions.internalToOCamlException(raw_jsError);
    if (jsError.RE_EXN_ID === Js_exn.$$Error) {
      throw jsError._1;
    }
    if (jsError.RE_EXN_ID === Exception) {
      throw {
            RE_EXN_ID: Raised,
            _1: toSerializeError(jsError._1),
            Error: new Error()
          };
    }
    throw jsError;
  }
}

function serializeToUnknownOrRaiseWith(value, struct) {
  try {
    return struct.s(value);
  }
  catch (raw_jsError){
    var jsError = Caml_js_exceptions.internalToOCamlException(raw_jsError);
    if (jsError.RE_EXN_ID === Js_exn.$$Error) {
      throw jsError._1;
    }
    if (jsError.RE_EXN_ID === Exception) {
      throw {
            RE_EXN_ID: Raised,
            _1: toSerializeError(jsError._1),
            Error: new Error()
          };
    }
    throw jsError;
  }
}

function serializeWith(value, struct) {
  try {
    return {
            TAG: "Ok",
            _0: struct.j(value)
          };
  }
  catch (raw_jsError){
    var jsError = Caml_js_exceptions.internalToOCamlException(raw_jsError);
    if (jsError.RE_EXN_ID === Js_exn.$$Error) {
      throw jsError._1;
    }
    if (jsError.RE_EXN_ID === Exception) {
      return {
              TAG: "Error",
              _0: toSerializeError(jsError._1)
            };
    }
    throw jsError;
  }
}

function serializeToJsonStringWith(value, spaceOpt, struct) {
  var space = spaceOpt !== undefined ? spaceOpt : 0;
  var json = serializeWith(value, struct);
  if (json.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: JSON.stringify(json._0, null, space)
          };
  } else {
    return json;
  }
}

function parseJsonStringWith(json, struct) {
  var json$1;
  try {
    json$1 = {
      TAG: "Ok",
      _0: JSON.parse(json)
    };
  }
  catch (raw_error){
    var error = Caml_js_exceptions.internalToOCamlException(raw_error);
    if (error.RE_EXN_ID === Js_exn.$$Error) {
      json$1 = {
        TAG: "Error",
        _0: {
          operation: "Parsing",
          code: {
            TAG: "OperationFailed",
            _0: error._1.message
          },
          path: ""
        }
      };
    } else {
      throw error;
    }
  }
  if (json$1.TAG === "Ok") {
    return parseAnyWith(json$1._0, struct);
  } else {
    return json$1;
  }
}

function recursive(fn) {
  var placeholder = ({m:emptyMetadataMap});
  var struct = fn(placeholder);
  Object.assign(placeholder, struct);
  var operationFactory = placeholder.parseOperationFactory;
  if (operationFactory !== undefined) {
    placeholder.parseOperationFactory = (function (b, selfStruct, inputVar, pathVar) {
        selfStruct.parseOperationFactory = (function (_b, param, inputVar, param$1) {
            return {
                    code: "",
                    outputVar: inputVar,
                    isAsync: false
                  };
          });
        var match = operationFactory(b, selfStruct, inputVar, pathVar);
        var isAsync = match.isAsync;
        b.varCounter = -1;
        b.varsAllocation = "_";
        selfStruct.parseOperationFactory = (function (b, selfStruct, inputVar, pathVar) {
            if (isAsync) {
              return asyncOperation(b, inputVar, (function (input) {
                            return selfStruct.a(input);
                          }), pathVar);
            } else {
              return syncOperation(b, inputVar, (function (input) {
                            return selfStruct.p(input);
                          }), pathVar);
            }
          });
        var operation = compile$1(operationFactory, selfStruct);
        selfStruct.p = isAsync ? (function (param) {
              return raise$1("UnexpectedAsync");
            }) : operation;
        selfStruct.a = isAsync ? operation : (function (input) {
              var syncValue = operation(input);
              return function () {
                return Promise.resolve(syncValue);
              };
            });
        selfStruct.parseOperationFactory = operationFactory;
        if (isAsync) {
          return asyncOperation(b, inputVar, operation, pathVar);
        } else {
          return syncOperation(b, inputVar, operation, pathVar);
        }
      });
  } else if (isAsyncParse(placeholder)) {
    throw new Error("[rescript-struct] " + ("The \"" + struct.n + "\" struct in the S.recursive has an async parser. To make it work, use S.asyncRecursive instead."));
  }
  return placeholder;
}

function make(namespace, name) {
  return namespace + ":" + name;
}

var Id = {
  make: make
};

function get(struct, id) {
  return Js_dict.get(struct.m, id);
}

function set(struct, id, metadata) {
  var metadataMap = Object.assign({}, struct.m);
  metadataMap[id] = metadata;
  return {
          n: struct.n,
          t: struct.t,
          parseOperationFactory: struct.parseOperationFactory,
          isAsyncParseOperation: undefined,
          pf: struct.pf,
          sf: struct.sf,
          r: 0,
          e: 0,
          s: initialSerialize,
          j: initialSerializeToJson,
          p: intitialParse,
          a: intitialParseAsync,
          m: metadataMap
        };
}

var Metadata = {
  Id: Id,
  get: get,
  set: set
};

function refine(struct, maybeParser, maybeAsyncParser, maybeSerializer, param) {
  if (maybeParser === undefined && maybeAsyncParser === undefined && maybeSerializer === undefined) {
    panic("struct factory Refine");
  }
  var nextParseTransformationFactory = maybeParser !== undefined ? (
      maybeAsyncParser !== undefined ? (function (ctx) {
            struct.pf(ctx);
            planSyncTransformation(ctx, (function (input) {
                    maybeParser(input);
                    return input;
                  }));
            planAsyncTransformation(ctx, (function (input) {
                    return maybeAsyncParser(input).then(function (param) {
                                return input;
                              });
                  }));
          }) : (function (ctx) {
            struct.pf(ctx);
            planSyncTransformation(ctx, (function (input) {
                    maybeParser(input);
                    return input;
                  }));
          })
    ) : (
      maybeAsyncParser !== undefined ? (function (ctx) {
            struct.pf(ctx);
            planAsyncTransformation(ctx, (function (input) {
                    return maybeAsyncParser(input).then(function (param) {
                                return input;
                              });
                  }));
          }) : struct.pf
    );
  return {
          n: struct.n,
          t: struct.t,
          parseOperationFactory: maybeParser !== undefined ? (
              maybeAsyncParser !== undefined ? (function (b, param, inputVar, pathVar) {
                    var match = compileParser(b, struct, inputVar, pathVar);
                    var isAsync = match.isAsync;
                    var parsedItemVar = match.outputVar;
                    var outputVar = $$var(b);
                    return {
                            code: match.code + syncTransform(b, parsedItemVar, outputVar, isAsync, maybeParser, true, pathVar, undefined) + asyncTransform(b, parsedItemVar, outputVar, isAsync, maybeAsyncParser, true, pathVar, undefined),
                            outputVar: outputVar,
                            isAsync: true
                          };
                  }) : (function (b, param, inputVar, pathVar) {
                    var match = compileParser(b, struct, inputVar, pathVar);
                    var isAsync = match.isAsync;
                    var outputVar = $$var(b);
                    return {
                            code: match.code + syncTransform(b, match.outputVar, outputVar, isAsync, maybeParser, true, pathVar, undefined),
                            outputVar: outputVar,
                            isAsync: isAsync
                          };
                  })
            ) : (
              maybeAsyncParser !== undefined ? (function (b, param, inputVar, pathVar) {
                    var match = compileParser(b, struct, inputVar, pathVar);
                    var outputVar = $$var(b);
                    return {
                            code: match.code + asyncTransform(b, match.outputVar, outputVar, match.isAsync, maybeAsyncParser, true, pathVar, undefined),
                            outputVar: outputVar,
                            isAsync: true
                          };
                  }) : struct.parseOperationFactory
            ),
          isAsyncParseOperation: undefined,
          pf: nextParseTransformationFactory,
          sf: maybeSerializer !== undefined ? (function (ctx) {
                planSyncTransformation(ctx, (function (input) {
                        maybeSerializer(input);
                        return input;
                      }));
                struct.sf(ctx);
              }) : struct.sf,
          r: 0,
          e: 0,
          s: initialSerialize,
          j: initialSerializeToJson,
          p: intitialParse,
          a: intitialParseAsync,
          m: struct.m
        };
}

function addRefinement(struct, metadataId, refinement, refiner) {
  var refinements = Js_dict.get(struct.m, metadataId);
  return refine(set(struct, metadataId, refinements !== undefined ? refinements.concat(refinement) : [refinement]), refiner, undefined, refiner, undefined);
}

function advancedTransform(struct, maybeParser, maybeSerializer, param) {
  if (maybeParser === undefined && maybeSerializer === undefined) {
    panic("struct factory Transform");
  }
  return {
          n: struct.n,
          t: struct.t,
          parseOperationFactory: (function (b, selfStruct, inputVar, pathVar) {
              if (maybeParser === undefined) {
                return {
                        code: raise$2(b, pathVar, "MissingParser") + ";",
                        outputVar: inputVar,
                        isAsync: false
                      };
              }
              var syncTransformation = maybeParser(selfStruct);
              if (typeof syncTransformation !== "object") {
                return compileParser(b, struct, inputVar, pathVar);
              }
              if (syncTransformation.TAG === "Sync") {
                var match = compileParser(b, struct, inputVar, pathVar);
                var isAsync = match.isAsync;
                var outputVar = $$var(b);
                return {
                        code: match.code + syncTransform(b, match.outputVar, outputVar, isAsync, syncTransformation._0, undefined, pathVar, undefined),
                        outputVar: outputVar,
                        isAsync: isAsync
                      };
              }
              var match$1 = compileParser(b, struct, inputVar, pathVar);
              var outputVar$1 = $$var(b);
              return {
                      code: match$1.code + asyncTransform(b, match$1.outputVar, outputVar$1, match$1.isAsync, syncTransformation._0, undefined, pathVar, undefined),
                      outputVar: outputVar$1,
                      isAsync: true
                    };
            }),
          isAsyncParseOperation: undefined,
          pf: (function (ctx) {
              struct.pf(ctx);
              if (maybeParser === undefined) {
                return planSyncTransformation(ctx, (function (param) {
                              return raise$1("MissingParser");
                            }));
              }
              var syncTransformation = maybeParser(ctx.s);
              if (typeof syncTransformation !== "object") {
                return ;
              } else if (syncTransformation.TAG === "Sync") {
                return planSyncTransformation(ctx, syncTransformation._0);
              } else {
                return planAsyncTransformation(ctx, syncTransformation._0);
              }
            }),
          sf: (function (ctx) {
              if (maybeSerializer !== undefined) {
                var syncTransformation = maybeSerializer(ctx.s);
                if (typeof syncTransformation === "object") {
                  if (syncTransformation.TAG === "Sync") {
                    planSyncTransformation(ctx, syncTransformation._0);
                  } else {
                    planAsyncTransformation(ctx, syncTransformation._0);
                  }
                }
                
              } else {
                planSyncTransformation(ctx, (function (param) {
                        return raise$1("MissingSerializer");
                      }));
              }
              struct.sf(ctx);
            }),
          r: 0,
          e: 0,
          s: initialSerialize,
          j: initialSerializeToJson,
          p: intitialParse,
          a: intitialParseAsync,
          m: struct.m
        };
}

function transform(struct, maybeParser, maybeAsyncParser, maybeSerializer, param) {
  if (maybeParser === undefined && maybeAsyncParser === undefined && maybeSerializer === undefined) {
    panic("struct factory Transform");
  }
  var planParser;
  if (maybeParser !== undefined) {
    if (maybeAsyncParser !== undefined) {
      throw new Error("[rescript-struct] The S.transform doesn't support the `parser` and `asyncParser` arguments simultaneously. Move `asyncParser` to another S.transform.");
    }
    planParser = (function (ctx) {
        planSyncTransformation(ctx, maybeParser);
      });
  } else {
    planParser = maybeAsyncParser !== undefined ? (function (ctx) {
          planAsyncTransformation(ctx, maybeAsyncParser);
        }) : planMissingParserTransformation;
  }
  var tmp;
  if (maybeParser !== undefined) {
    if (maybeAsyncParser !== undefined) {
      throw new Error("[rescript-struct] The S.transform doesn't support the `parser` and `asyncParser` arguments simultaneously. Move `asyncParser` to another S.transform.");
    }
    tmp = (function (b, param, inputVar, pathVar) {
        var match = compileParser(b, struct, inputVar, pathVar);
        var isAsync = match.isAsync;
        var outputVar = $$var(b);
        return {
                code: match.code + syncTransform(b, match.outputVar, outputVar, isAsync, maybeParser, undefined, pathVar, undefined),
                outputVar: outputVar,
                isAsync: isAsync
              };
      });
  } else {
    tmp = maybeAsyncParser !== undefined ? (function (b, param, inputVar, pathVar) {
          var match = compileParser(b, struct, inputVar, pathVar);
          var outputVar = $$var(b);
          return {
                  code: match.code + asyncTransform(b, match.outputVar, outputVar, match.isAsync, maybeAsyncParser, undefined, pathVar, undefined),
                  outputVar: outputVar,
                  isAsync: true
                };
        }) : (function (b, param, inputVar, pathVar) {
          return {
                  code: raise$2(b, pathVar, "MissingParser") + ";",
                  outputVar: inputVar,
                  isAsync: false
                };
        });
  }
  var maybeParseOperationFactory = tmp;
  return {
          n: struct.n,
          t: struct.t,
          parseOperationFactory: maybeParseOperationFactory,
          isAsyncParseOperation: undefined,
          pf: (function (ctx) {
              struct.pf(ctx);
              planParser(ctx);
            }),
          sf: (function (ctx) {
              if (maybeSerializer !== undefined) {
                planSyncTransformation(ctx, maybeSerializer);
              } else {
                planSyncTransformation(ctx, (function (param) {
                        return raise$1("MissingSerializer");
                      }));
              }
              struct.sf(ctx);
            }),
          r: 0,
          e: 0,
          s: initialSerialize,
          j: initialSerializeToJson,
          p: intitialParse,
          a: intitialParseAsync,
          m: struct.m
        };
}

function advancedPreprocess(struct, maybePreprocessParser, maybePreprocessSerializer, param) {
  if (maybePreprocessParser === undefined && maybePreprocessSerializer === undefined) {
    panic("struct factory Preprocess");
  }
  var unionStructs = struct.t;
  if (typeof unionStructs === "object" && unionStructs.TAG === "Union") {
    var tagged = {
      TAG: "Union",
      _0: unionStructs._0.map(function (unionStruct) {
            return advancedPreprocess(unionStruct, maybePreprocessParser, maybePreprocessSerializer, undefined);
          })
    };
    return {
            n: struct.n,
            t: tagged,
            parseOperationFactory: struct.parseOperationFactory,
            isAsyncParseOperation: undefined,
            pf: struct.pf,
            sf: struct.sf,
            r: 0,
            e: 0,
            s: initialSerialize,
            j: initialSerializeToJson,
            p: intitialParse,
            a: intitialParseAsync,
            m: struct.m
          };
  }
  return {
          n: struct.n,
          t: struct.t,
          parseOperationFactory: (function (b, selfStruct, inputVar, pathVar) {
              if (maybePreprocessParser === undefined) {
                return {
                        code: raise$2(b, pathVar, "MissingParser") + ";",
                        outputVar: inputVar,
                        isAsync: false
                      };
              }
              var syncTransformation = maybePreprocessParser(selfStruct);
              if (typeof syncTransformation !== "object") {
                return compileParser(b, struct, inputVar, pathVar);
              }
              if (syncTransformation.TAG === "Sync") {
                var parseResultVar = $$var(b);
                var match = compileParser(b, struct, parseResultVar, pathVar);
                return {
                        code: syncTransform(b, inputVar, parseResultVar, false, syncTransformation._0, undefined, pathVar, undefined) + match.code,
                        outputVar: match.outputVar,
                        isAsync: match.isAsync
                      };
              }
              var parseResultVar$1 = $$var(b);
              var match$1 = compileParser(b, struct, "t", pathVar);
              var structOuputVar = match$1.outputVar;
              var outputVar = $$var(b);
              return {
                      code: asyncTransform(b, inputVar, parseResultVar$1, false, syncTransformation._0, undefined, pathVar, undefined) + outputVar + "=()=>" + parseResultVar$1 + "().then(t=>{" + match$1.code + "return " + (
                        match$1.isAsync ? structOuputVar + "()" : structOuputVar
                      ) + "});",
                      outputVar: outputVar,
                      isAsync: true
                    };
            }),
          isAsyncParseOperation: undefined,
          pf: (function (ctx) {
              if (maybePreprocessParser !== undefined) {
                var syncTransformation = maybePreprocessParser(ctx.s);
                if (typeof syncTransformation === "object") {
                  if (syncTransformation.TAG === "Sync") {
                    planSyncTransformation(ctx, syncTransformation._0);
                  } else {
                    planAsyncTransformation(ctx, syncTransformation._0);
                  }
                }
                
              } else {
                planSyncTransformation(ctx, (function (param) {
                        return raise$1("MissingParser");
                      }));
              }
              struct.pf(ctx);
            }),
          sf: (function (ctx) {
              struct.sf(ctx);
              if (maybePreprocessSerializer === undefined) {
                return planSyncTransformation(ctx, (function (param) {
                              return raise$1("MissingSerializer");
                            }));
              }
              var syncTransformation = maybePreprocessSerializer(ctx.s);
              if (typeof syncTransformation !== "object") {
                return ;
              } else if (syncTransformation.TAG === "Sync") {
                return planSyncTransformation(ctx, syncTransformation._0);
              } else {
                return planAsyncTransformation(ctx, syncTransformation._0);
              }
            }),
          r: 0,
          e: 0,
          s: initialSerialize,
          j: initialSerializeToJson,
          p: intitialParse,
          a: intitialParseAsync,
          m: struct.m
        };
}

function custom(name, maybeParser, maybeAsyncParser, maybeSerializer, param) {
  if (maybeParser === undefined && maybeAsyncParser === undefined && maybeSerializer === undefined) {
    panic("Custom struct factory");
  }
  var planParser;
  if (maybeParser !== undefined) {
    if (maybeAsyncParser !== undefined) {
      throw new Error("[rescript-struct] The S.custom doesn't support the `parser` and `asyncParser` arguments simultaneously. Keep only `asyncParser`.");
    }
    planParser = (function (ctx) {
        planSyncTransformation(ctx, maybeParser);
      });
  } else {
    planParser = maybeAsyncParser !== undefined ? (function (ctx) {
          planAsyncTransformation(ctx, maybeAsyncParser);
        }) : planMissingParserTransformation;
  }
  var tmp;
  if (maybeParser !== undefined) {
    if (maybeAsyncParser !== undefined) {
      throw new Error("[rescript-struct] The S.custom doesn't support the `parser` and `asyncParser` arguments simultaneously. Keep only `asyncParser`.");
    }
    tmp = (function (b, param, inputVar, pathVar) {
        return syncOperation(b, inputVar, maybeParser, pathVar);
      });
  } else {
    tmp = maybeAsyncParser !== undefined ? (function (b, param, inputVar, pathVar) {
          return asyncOperation(b, inputVar, (function (unknown) {
                        return function () {
                          return maybeAsyncParser(unknown);
                        };
                      }), pathVar);
        }) : (function (b, param, inputVar, pathVar) {
          return {
                  code: raise$2(b, pathVar, "MissingParser") + ";",
                  outputVar: inputVar,
                  isAsync: false
                };
        });
  }
  var maybeParseOperationFactory = tmp;
  return {
          n: name,
          t: "Unknown",
          parseOperationFactory: maybeParseOperationFactory,
          isAsyncParseOperation: undefined,
          pf: (function (ctx) {
              planParser(ctx);
            }),
          sf: (function (ctx) {
              if (maybeSerializer !== undefined) {
                return planSyncTransformation(ctx, maybeSerializer);
              } else {
                return planSyncTransformation(ctx, (function (param) {
                              return raise$1("MissingSerializer");
                            }));
              }
            }),
          r: 0,
          e: 0,
          s: initialSerialize,
          j: initialSerializeToJson,
          p: intitialParse,
          a: intitialParseAsync,
          m: emptyMetadataMap
        };
}

function internalToInlinedValue(_struct) {
  while(true) {
    var struct = _struct;
    var unionStructs = struct.t;
    if (typeof unionStructs !== "object") {
      throw undefined;
    }
    switch (unionStructs.TAG) {
      case "Literal" :
          var string = unionStructs._0;
          if (typeof string === "object") {
            if (string.TAG === "String") {
              return JSON.stringify(string._0);
            } else {
              return string._0.toString();
            }
          }
          switch (string) {
            case "EmptyNull" :
                return "null";
            case "EmptyOption" :
                return "undefined";
            case "NaN" :
                return "NaN";
            
          }
      case "Object" :
          var fields = unionStructs.fields;
          return "{" + unionStructs.fieldNames.map((function(fields){
                      return function (fieldName) {
                        return JSON.stringify(fieldName) + ":" + internalToInlinedValue(fields[fieldName]);
                      }
                      }(fields))).join(",") + "}";
      case "Tuple" :
          return "[" + unionStructs._0.map(internalToInlinedValue).join(",") + "]";
      case "Union" :
          _struct = unionStructs._0[0];
          continue ;
      default:
        throw undefined;
    }
  };
}

function analyzeDefinition(definition, definerCtx, path) {
  if (definition === definerCtx) {
    if (definerCtx.r) {
      throw new Error("[rescript-struct] The variant's value is registered multiple times. If you want to duplicate it, use S.transform instead.");
    }
    definerCtx.a = path;
    definerCtx.r = true;
    return ;
  }
  if (typeof definition === "object" && definition !== null) {
    var definitionFieldNames = Object.keys(definition);
    for(var idx = 0 ,idx_finish = definitionFieldNames.length; idx < idx_finish; ++idx){
      var definitionFieldName = definitionFieldNames[idx];
      var fieldDefinition = definition[definitionFieldName];
      analyzeDefinition(fieldDefinition, definerCtx, path + ("[" + JSON.stringify(definitionFieldName) + "]"));
    }
    return ;
  }
  definerCtx.c.push({
        v: definition,
        p: path
      });
}

function factory(struct, definer) {
  var definerCtx = {
    a: "",
    r: false,
    c: []
  };
  var definition = definer(definerCtx);
  analyzeDefinition(definition, definerCtx, "");
  return {
          n: struct.n,
          t: struct.t,
          parseOperationFactory: (function (b, param, inputVar, pathVar) {
              var match = compileParser(b, struct, inputVar, pathVar);
              var isAsync = match.isAsync;
              var outputVar = $$var(b);
              return {
                      code: match.code + syncTransform(b, match.outputVar, outputVar, isAsync, definer, undefined, undefined, undefined),
                      outputVar: outputVar,
                      isAsync: isAsync
                    };
            }),
          isAsyncParseOperation: undefined,
          pf: (function (ctx) {
              struct.pf(ctx);
              planSyncTransformation(ctx, definer);
            }),
          sf: (function (ctx) {
              ((function (ctx) {
                      try {
                        var valuePath = definerCtx.a;
                        var isValueRegistered = definerCtx.r;
                        var constantDefinitions = definerCtx.c;
                        var stringRef = "";
                        for(var idx = 0 ,idx_finish = constantDefinitions.length; idx < idx_finish; ++idx){
                          var match = constantDefinitions[idx];
                          var path = match.p;
                          stringRef = stringRef + ("if(" + ("t" + path + "!==d[" + idx + "].v") + "){" + ("r(" + idx + ",t" + path + ")") + "}");
                        }
                        var constants = stringRef;
                        var content = constants + "return " + (
                          isValueRegistered ? "t" + valuePath : internalToInlinedValue(ctx.s)
                        );
                        var inlinedSerializeFunction = "(t)=>{" + content + "}";
                        planSyncTransformation(ctx, new Function("d", "r", "return " + inlinedSerializeFunction)(constantDefinitions, (function (fieldDefinitionIdx, received) {
                                    var match = constantDefinitions[fieldDefinitionIdx];
                                    return raise(match.v, received, match.p, undefined);
                                  })));
                      }
                      catch (exn){
                        planSyncTransformation(ctx, (function (param) {
                                return raise$1("MissingSerializer");
                              }));
                      }
                    })(ctx));
              struct.sf(ctx);
            }),
          r: 0,
          e: 0,
          s: initialSerialize,
          j: initialSerializeToJson,
          p: intitialParse,
          a: intitialParseAsync,
          m: struct.m
        };
}

function factory$1(innerLiteral, variant) {
  var tagged = {
    TAG: "Literal",
    _0: innerLiteral
  };
  var makeParseTransformationFactory = function (literalValue, test) {
    return function (ctx) {
      planSyncTransformation(ctx, (function (input) {
              if (test(input)) {
                if (literalValue === input) {
                  return variant;
                } else {
                  return raise(literalValue, input, undefined, undefined);
                }
              } else {
                return raiseUnexpectedTypeError(input, ctx.s);
              }
            }));
    };
  };
  var makeSerializeTransformationFactory = function (output) {
    return function (ctx) {
      planSyncTransformation(ctx, (function (input) {
              if (input === variant) {
                return output;
              } else {
                return raise(variant, input, undefined, undefined);
              }
            }));
    };
  };
  if (typeof innerLiteral !== "object") {
    switch (innerLiteral) {
      case "EmptyNull" :
          var serializeTransformationFactory = makeSerializeTransformationFactory(null);
          return {
                  n: "EmptyNull Literal (null)",
                  t: tagged,
                  parseOperationFactory: undefined,
                  isAsyncParseOperation: undefined,
                  pf: (function (ctx) {
                      planSyncTransformation(ctx, (function (input) {
                              if (input === null) {
                                return variant;
                              } else {
                                return raiseUnexpectedTypeError(input, ctx.s);
                              }
                            }));
                    }),
                  sf: serializeTransformationFactory,
                  r: 0,
                  e: 0,
                  s: initialSerialize,
                  j: initialSerializeToJson,
                  p: intitialParse,
                  a: intitialParseAsync,
                  m: emptyMetadataMap
                };
      case "EmptyOption" :
          var serializeTransformationFactory$1 = makeSerializeTransformationFactory(undefined);
          return {
                  n: "EmptyOption Literal (undefined)",
                  t: tagged,
                  parseOperationFactory: undefined,
                  isAsyncParseOperation: undefined,
                  pf: (function (ctx) {
                      planSyncTransformation(ctx, (function (input) {
                              if (input === undefined) {
                                return variant;
                              } else {
                                return raiseUnexpectedTypeError(input, ctx.s);
                              }
                            }));
                    }),
                  sf: serializeTransformationFactory$1,
                  r: 0,
                  e: 0,
                  s: initialSerialize,
                  j: initialSerializeToJson,
                  p: intitialParse,
                  a: intitialParseAsync,
                  m: emptyMetadataMap
                };
      case "NaN" :
          var serializeTransformationFactory$2 = makeSerializeTransformationFactory(NaN);
          return {
                  n: "NaN Literal (NaN)",
                  t: tagged,
                  parseOperationFactory: undefined,
                  isAsyncParseOperation: undefined,
                  pf: (function (ctx) {
                      planSyncTransformation(ctx, (function (input) {
                              if (Number.isNaN(input)) {
                                return variant;
                              } else {
                                return raiseUnexpectedTypeError(input, ctx.s);
                              }
                            }));
                    }),
                  sf: serializeTransformationFactory$2,
                  r: 0,
                  e: 0,
                  s: initialSerialize,
                  j: initialSerializeToJson,
                  p: intitialParse,
                  a: intitialParseAsync,
                  m: emptyMetadataMap
                };
      
    }
  } else {
    switch (innerLiteral.TAG) {
      case "String" :
          var string = innerLiteral._0;
          var serializeTransformationFactory$3 = makeSerializeTransformationFactory(string);
          var parseTransformationFactory = makeParseTransformationFactory(string, (function (input) {
                  return typeof input === "string";
                }));
          return {
                  n: "String Literal (\"" + string + "\")",
                  t: tagged,
                  parseOperationFactory: undefined,
                  isAsyncParseOperation: undefined,
                  pf: parseTransformationFactory,
                  sf: serializeTransformationFactory$3,
                  r: 0,
                  e: 0,
                  s: initialSerialize,
                  j: initialSerializeToJson,
                  p: intitialParse,
                  a: intitialParseAsync,
                  m: emptyMetadataMap
                };
      case "Int" :
          var $$int = innerLiteral._0;
          var serializeTransformationFactory$4 = makeSerializeTransformationFactory($$int);
          var parseTransformationFactory$1 = makeParseTransformationFactory($$int, test);
          return {
                  n: "Int Literal (" + $$int + ")",
                  t: tagged,
                  parseOperationFactory: undefined,
                  isAsyncParseOperation: undefined,
                  pf: parseTransformationFactory$1,
                  sf: serializeTransformationFactory$4,
                  r: 0,
                  e: 0,
                  s: initialSerialize,
                  j: initialSerializeToJson,
                  p: intitialParse,
                  a: intitialParseAsync,
                  m: emptyMetadataMap
                };
      case "Float" :
          var $$float = innerLiteral._0;
          var serializeTransformationFactory$5 = makeSerializeTransformationFactory($$float);
          var parseTransformationFactory$2 = makeParseTransformationFactory($$float, (function (input) {
                  return typeof input === "number";
                }));
          var name = "Float Literal (" + $$float.toString() + ")";
          return {
                  n: name,
                  t: tagged,
                  parseOperationFactory: undefined,
                  isAsyncParseOperation: undefined,
                  pf: parseTransformationFactory$2,
                  sf: serializeTransformationFactory$5,
                  r: 0,
                  e: 0,
                  s: initialSerialize,
                  j: initialSerializeToJson,
                  p: intitialParse,
                  a: intitialParseAsync,
                  m: emptyMetadataMap
                };
      case "Bool" :
          var bool = innerLiteral._0;
          var serializeTransformationFactory$6 = makeSerializeTransformationFactory(bool);
          var parseTransformationFactory$3 = makeParseTransformationFactory(bool, (function (input) {
                  return typeof input === "boolean";
                }));
          var name$1 = "Bool Literal (" + bool.toString() + ")";
          return {
                  n: name$1,
                  t: tagged,
                  parseOperationFactory: undefined,
                  isAsyncParseOperation: undefined,
                  pf: parseTransformationFactory$3,
                  sf: serializeTransformationFactory$6,
                  r: 0,
                  e: 0,
                  s: initialSerialize,
                  j: initialSerializeToJson,
                  p: intitialParse,
                  a: intitialParseAsync,
                  m: emptyMetadataMap
                };
      
    }
  }
}

function factory$2(innerLiteral) {
  if (typeof innerLiteral === "object") {
    return factory$1(innerLiteral, innerLiteral._0);
  }
  switch (innerLiteral) {
    case "EmptyNull" :
    case "EmptyOption" :
    case "NaN" :
        return factory$1(innerLiteral, undefined);
    
  }
}

var metadataId = "rescript-struct:Object.UnknownKeys";

function classify$1(struct) {
  var t = Js_dict.get(struct.m, metadataId);
  if (t !== undefined) {
    return t;
  } else {
    return "Strip";
  }
}

function analyzeDefinition$1(definition, definerCtx, path) {
  if (definerCtx.s.has(definition)) {
    if (definition.r) {
      throw new Error("[rescript-struct] " + ("The field \"" + definition.n + "\" is registered multiple times. If you want to duplicate a field, use S.transform instead."));
    }
    definition.p = path;
    definition.r = true;
    return ;
  }
  if (typeof definition === "object" && definition !== null) {
    definerCtx.p.push(path);
    definerCtx.v.push(Array.isArray(definition) ? "[]" : "{}");
    var definitionFieldNames = Object.keys(definition);
    for(var idx = 0 ,idx_finish = definitionFieldNames.length; idx < idx_finish; ++idx){
      var definitionFieldName = definitionFieldNames[idx];
      var fieldDefinition = definition[definitionFieldName];
      analyzeDefinition$1(fieldDefinition, definerCtx, path + ("[" + JSON.stringify(definitionFieldName) + "]"));
    }
    return ;
  }
  definerCtx.c.push({
        v: definition,
        p: path
      });
}

function factory$3(definer) {
  var fields = {};
  var fieldNames = [];
  var fieldDefinitions = [];
  var fieldDefinitionsSet = new Set();
  var field = function (fieldName, struct) {
    if (fields.hasOwnProperty(fieldName)) {
      throw new Error("[rescript-struct] " + ("The field \"" + fieldName + "\" is defined multiple times. If you want to duplicate a field, use S.transform instead."));
    }
    var fieldDefinition = {
      s: struct,
      i: JSON.stringify(fieldName),
      n: fieldName,
      p: "",
      r: false
    };
    fields[fieldName] = struct;
    fieldNames.push(fieldName);
    fieldDefinitions.push(fieldDefinition);
    fieldDefinitionsSet.add(fieldDefinition);
    return fieldDefinition;
  };
  var definerCtx_p = [];
  var definerCtx_v = [];
  var definerCtx_c = [];
  var definerCtx = {
    n: fieldNames,
    h: fields,
    d: fieldDefinitions,
    p: definerCtx_p,
    v: definerCtx_v,
    c: definerCtx_c,
    s: fieldDefinitionsSet,
    f: field
  };
  var definition = definer(definerCtx);
  analyzeDefinition$1(definition, definerCtx, "");
  var serializeTransformationFactory = function (ctx) {
    var inliningFieldNameRef = undefined;
    try {
      var constantDefinitions = definerCtx_c;
      var serializeFnsByFieldDefinitionIdx = {};
      var stringRef = "";
      for(var idx = 0 ,idx_finish = constantDefinitions.length; idx < idx_finish; ++idx){
        var match = constantDefinitions[idx];
        var path = match.p;
        var content = "r(" + idx.toString() + ",t" + path + ")";
        var condition = "t" + path + "!==d[" + idx.toString() + "].v";
        stringRef = stringRef + ("if(" + condition + "){" + content + "}");
      }
      var constants = stringRef;
      var contentRef = "var i;return{";
      for(var idx$1 = 0 ,idx_finish$1 = fieldDefinitions.length; idx$1 < idx_finish$1; ++idx$1){
        var fieldDefinition = fieldDefinitions[idx$1];
        var inlinedFieldName = fieldDefinition.i;
        var fieldStruct = fieldDefinition.s;
        var path$1 = fieldDefinition.p;
        var isRegistered = fieldDefinition.r;
        var inlinedIdx = idx$1.toString();
        var tmp;
        if (isRegistered) {
          var fn = getSerializeOperation(fieldStruct);
          if (fn !== undefined) {
            serializeFnsByFieldDefinitionIdx[inlinedIdx] = fn;
            tmp = inlinedFieldName + ":(i=" + inlinedIdx + ",s[" + inlinedIdx + "](t" + path$1 + ")),";
          } else {
            tmp = inlinedFieldName + ":t" + path$1 + ",";
          }
        } else {
          inliningFieldNameRef = fieldDefinition.n;
          tmp = inlinedFieldName + ":" + internalToInlinedValue(fieldStruct) + ",";
        }
        contentRef = contentRef + tmp;
      }
      var tryContent = contentRef + "}";
      var originalObjectConstructionAndReturn = "try{" + tryContent + "}catch(e){c(e,i)}";
      var inlinedSerializeFunction = "(t)=>{" + (constants + originalObjectConstructionAndReturn) + "}";
      planSyncTransformation(ctx, new Function("s", "d", "r", "c", "return " + inlinedSerializeFunction)(serializeFnsByFieldDefinitionIdx, constantDefinitions, (function (fieldDefinitionIdx, received) {
                  var match = constantDefinitions[fieldDefinitionIdx];
                  return raise(match.v, received, match.p, undefined);
                }), (function (exn, fieldDefinitionIdx) {
                  var tmp;
                  if (exn.RE_EXN_ID === Exception) {
                    var match = fieldDefinitions[fieldDefinitionIdx];
                    var path = match.p;
                    tmp = {
                      RE_EXN_ID: Exception,
                      _1: prependPath(exn._1, path)
                    };
                  } else {
                    tmp = exn;
                  }
                  throw tmp;
                })));
    }
    catch (exn){
      var inliningOriginalFieldName = inliningFieldNameRef;
      planSyncTransformation(ctx, (function (param) {
              throw {
                    RE_EXN_ID: Exception,
                    _1: {
                      c: "MissingSerializer",
                      p: "[" + JSON.stringify(inliningOriginalFieldName) + "]"
                    },
                    Error: new Error()
                  };
            }));
    }
  };
  var parseTransformationFactory = function (ctx) {
    var constantDefinitions = definerCtx_c;
    var inlinedPreparationValues = definerCtx_v;
    var preparationPathes = definerCtx_p;
    var withUnknownKeysRefinement = classify$1(ctx.s) === "Strict";
    var asyncFieldDefinitions = [];
    var parseFnsByInstructionIdx = {};
    var withFieldDefinitions = fieldDefinitions.length !== 0;
    var refinement = "if(!(typeof o===\"object\"&&o!==null&&!Array.isArray(o))){u(o)}";
    var stringRef = "var t;";
    for(var idx = 0 ,idx_finish = preparationPathes.length; idx < idx_finish; ++idx){
      var preparationPath = preparationPathes[idx];
      var preparationInlinedValue = inlinedPreparationValues[idx];
      stringRef = stringRef + ("t" + preparationPath + "=" + preparationInlinedValue + ";");
    }
    var preparation = stringRef;
    var transformedObjectConstruction;
    if (withFieldDefinitions) {
      var stringRef$1 = "";
      for(var idx$1 = 0 ,idx_finish$1 = fieldDefinitions.length; idx$1 < idx_finish$1; ++idx$1){
        var fieldDefinition = fieldDefinitions[idx$1];
        var path = fieldDefinition.p;
        var isRegistered = fieldDefinition.r;
        var inlinedIdx = idx$1.toString();
        var parseOperation = getParseOperation(fieldDefinition.s);
        var maybeParseFn;
        maybeParseFn = typeof parseOperation !== "object" ? undefined : parseOperation._0;
        var isAsync;
        isAsync = typeof parseOperation !== "object" || parseOperation.TAG === "SyncOperation" ? false : true;
        var inlinedInputData = "o[" + fieldDefinition.i + "]";
        var maybeInlinedDestination;
        if (isAsync) {
          if (asyncFieldDefinitions.length === 0) {
            stringRef$1 = stringRef$1 + "var a={};";
          }
          if (isRegistered) {
            stringRef$1 = stringRef$1 + ("t" + path + "=undefined;");
          }
          var inlinedDestination = "a[" + asyncFieldDefinitions.length.toString() + "]";
          asyncFieldDefinitions.push(fieldDefinition);
          maybeInlinedDestination = inlinedDestination;
        } else {
          maybeInlinedDestination = isRegistered ? "t" + path : undefined;
        }
        stringRef$1 = stringRef$1 + (
          maybeParseFn !== undefined ? (parseFnsByInstructionIdx[inlinedIdx] = maybeParseFn, "i=" + inlinedIdx + ";" + (
                maybeInlinedDestination !== undefined ? maybeInlinedDestination + "=" : ""
              ) + "p[" + inlinedIdx + "](" + inlinedInputData + ");") : (
              maybeInlinedDestination !== undefined ? maybeInlinedDestination + "=" + inlinedInputData + ";" : ""
            )
        );
      }
      var tryContent = stringRef$1;
      transformedObjectConstruction = "var i;" + ("try{" + tryContent + "}catch(e){c(e,i)}");
    } else {
      transformedObjectConstruction = "";
    }
    var unknownKeysRefinement;
    if (withUnknownKeysRefinement) {
      if (withFieldDefinitions) {
        var stringRef$2 = "for(var k in o){if(!(";
        for(var idx$2 = 0 ,idx_finish$2 = fieldDefinitions.length; idx$2 < idx_finish$2; ++idx$2){
          var fieldDefinition$1 = fieldDefinitions[idx$2];
          if (idx$2 !== 0) {
            stringRef$2 = stringRef$2 + "||";
          }
          stringRef$2 = stringRef$2 + ("k===" + fieldDefinition$1.i);
        }
        unknownKeysRefinement = stringRef$2 + ")){x(k)}}";
      } else {
        unknownKeysRefinement = "for(var k in o){x(k)}";
      }
    } else {
      unknownKeysRefinement = "";
    }
    var stringRef$3 = "";
    for(var idx$3 = 0 ,idx_finish$3 = constantDefinitions.length; idx$3 < idx_finish$3; ++idx$3){
      var constantDefinition = constantDefinitions[idx$3];
      stringRef$3 = stringRef$3 + ("t" + constantDefinition.p + "=d[" + idx$3 + "].v;");
    }
    var constants = stringRef$3;
    var returnValue = asyncFieldDefinitions.length === 0 ? "t" : "a.t=t,a";
    var inlinedParseFunction = "(o)=>{" + (refinement + preparation + transformedObjectConstruction + unknownKeysRefinement + constants + "return " + returnValue) + "}";
    planSyncTransformation(ctx, new Function("c", "p", "f", "d", "u", "s", "x", "return " + inlinedParseFunction)((function (exn, fieldDefinitionIdx) {
                throw exn.RE_EXN_ID === Exception ? ({
                          RE_EXN_ID: Exception,
                          _1: prependPath(exn._1, "[" + JSON.stringify(fieldDefinitions[fieldDefinitionIdx].n) + "]")
                        }) : exn;
              }), parseFnsByInstructionIdx, fields, constantDefinitions, (function (input) {
                return raiseUnexpectedTypeError(input, ctx.s);
              }), raiseUnexpectedTypeError, (function (exccessFieldName) {
                return raise$1({
                            TAG: "ExcessField",
                            _0: exccessFieldName
                          });
              })));
    if (asyncFieldDefinitions.length <= 0) {
      return ;
    }
    var resolveVar = "rs";
    var rejectVar = "rj";
    var contentRef = "var y=" + asyncFieldDefinitions.length + ",t=a.t;";
    for(var idx$4 = 0 ,idx_finish$4 = asyncFieldDefinitions.length; idx$4 < idx_finish$4; ++idx$4){
      var fieldDefinition$2 = asyncFieldDefinitions[idx$4];
      var path$1 = fieldDefinition$2.p;
      var isRegistered$1 = fieldDefinition$2.r;
      var inlinedIdx$1 = idx$4.toString();
      var fieldValueVar = "z";
      var inlinedFieldValueAssignment = isRegistered$1 ? "t" + path$1 + "=" + fieldValueVar : "";
      var inlinedIteration = "if(y--===1){" + (resolveVar + "(t)") + "}";
      var onFieldSuccessInlinedFnContent = inlinedFieldValueAssignment + ";" + inlinedIteration;
      var onFieldSuccessInlinedFn = "(" + fieldValueVar + ")=>{" + onFieldSuccessInlinedFnContent + "}";
      var errorVar = "z";
      var onFieldErrorInlinedFn = "(" + errorVar + ")=>{" + (rejectVar + "(j(" + errorVar + "," + inlinedIdx$1 + "))") + "}";
      contentRef = contentRef + ("a[" + inlinedIdx$1 + "]().then(" + onFieldSuccessInlinedFn + "," + onFieldErrorInlinedFn + ");");
    }
    var content = contentRef;
    var inlinedAsyncParseFunction = "(a)=>{return " + ("new Promise((" + resolveVar + "," + rejectVar + ")=>{" + content + "})") + "}";
    planAsyncTransformation(ctx, new Function("j", "return " + inlinedAsyncParseFunction)(function (exn, asyncFieldDefinitionIdx) {
              if (exn.RE_EXN_ID === Exception) {
                return {
                        RE_EXN_ID: Exception,
                        _1: prependPath(exn._1, "[" + JSON.stringify(asyncFieldDefinitions[asyncFieldDefinitionIdx].n) + "]")
                      };
              } else {
                return exn;
              }
            }));
  };
  return {
          n: "Object",
          t: {
            TAG: "Object",
            fields: fields,
            fieldNames: fieldNames
          },
          parseOperationFactory: (function (b, selfStruct, inputVar, pathVar) {
              var constantDefinitions = definerCtx_c;
              var inlinedPreparationValues = definerCtx_v;
              var preparationPathes = definerCtx_p;
              var asyncFieldVars = [];
              var syncOutputVar = $$var(b);
              var codeRef = "if(!(typeof " + inputVar + "===\"object\"&&" + inputVar + "!==null&&!Array.isArray(" + inputVar + "))){" + raiseWithArg(b, pathVar, (function (input) {
                      return {
                              TAG: "UnexpectedType",
                              expected: "Object",
                              received: toName(input)
                            };
                    }), inputVar) + "}";
              for(var idx = 0 ,idx_finish = preparationPathes.length; idx < idx_finish; ++idx){
                var preparationPath = preparationPathes[idx];
                var preparationInlinedValue = inlinedPreparationValues[idx];
                codeRef = codeRef + (syncOutputVar + preparationPath + "=" + preparationInlinedValue + ";");
              }
              for(var idx$1 = 0 ,idx_finish$1 = fieldDefinitions.length; idx$1 < idx_finish$1; ++idx$1){
                var fieldDefinition = fieldDefinitions[idx$1];
                var inlinedFieldName = fieldDefinition.i;
                var path = fieldDefinition.p;
                var isRegistered = fieldDefinition.r;
                var match = compileParser(b, fieldDefinition.s, inputVar + "[" + inlinedFieldName + "]", pathVar + "+'['+" + JSON.stringify(inlinedFieldName) + "+']'");
                var fieldOuputVar = match.outputVar;
                codeRef = codeRef + match.code + (
                  isRegistered ? syncOutputVar + path + "=" + fieldOuputVar + ";" : ""
                );
                if (match.isAsync) {
                  asyncFieldVars.push(isRegistered ? syncOutputVar + path : fieldOuputVar);
                }
                
              }
              var withUnknownKeysRefinement = classify$1(selfStruct) === "Strict";
              if (withUnknownKeysRefinement) {
                if (fieldDefinitions.length !== 0) {
                  var keyVar = $$var(b);
                  codeRef = codeRef + ("for(" + keyVar + " in " + inputVar + "){if(!(");
                  for(var idx$2 = 0 ,idx_finish$2 = fieldDefinitions.length; idx$2 < idx_finish$2; ++idx$2){
                    var fieldDefinition$1 = fieldDefinitions[idx$2];
                    if (idx$2 !== 0) {
                      codeRef = codeRef + "||";
                    }
                    codeRef = codeRef + (keyVar + "===" + fieldDefinition$1.i);
                  }
                  codeRef = codeRef + (")){" + raiseWithArg(b, pathVar, (function (exccessFieldName) {
                            return {
                                    TAG: "ExcessField",
                                    _0: exccessFieldName
                                  };
                          }), keyVar) + "}}");
                } else {
                  var keyVar$1 = $$var(b);
                  codeRef = codeRef + ("for(" + keyVar$1 + " in " + inputVar + "){" + raiseWithArg(b, pathVar, (function (exccessFieldName) {
                            return {
                                    TAG: "ExcessField",
                                    _0: exccessFieldName
                                  };
                          }), keyVar$1) + "}");
                }
              }
              for(var idx$3 = 0 ,idx_finish$3 = constantDefinitions.length; idx$3 < idx_finish$3; ++idx$3){
                var match$1 = constantDefinitions[idx$3];
                codeRef = codeRef + (syncOutputVar + match$1.p + "=" + ("e[" + (b.embeded.push(match$1.v) - 1) + "]") + ";");
              }
              if (asyncFieldVars.length === 0) {
                return {
                        code: codeRef,
                        outputVar: syncOutputVar,
                        isAsync: false
                      };
              }
              var outputVar = $$var(b);
              var resolveVar = varWithoutAllocation(b);
              var rejectVar = varWithoutAllocation(b);
              var asyncParseResultVar = varWithoutAllocation(b);
              var counterVar = varWithoutAllocation(b);
              return {
                      code: codeRef + outputVar + "=()=>new Promise((" + resolveVar + "," + rejectVar + ")=>{let " + counterVar + "=" + asyncFieldVars.length.toString() + ";" + asyncFieldVars.map(function (asyncFieldVar) {
                              return asyncFieldVar + "().then(" + asyncParseResultVar + "=>{" + asyncFieldVar + "=" + asyncParseResultVar + ";if(" + counterVar + "--===1){" + resolveVar + "(" + syncOutputVar + ")}}," + rejectVar + ")";
                            }).join(";") + "});",
                      outputVar: outputVar,
                      isAsync: true
                    };
            }),
          isAsyncParseOperation: undefined,
          pf: parseTransformationFactory,
          sf: serializeTransformationFactory,
          r: 0,
          e: 0,
          s: initialSerialize,
          j: initialSerializeToJson,
          p: intitialParse,
          a: intitialParseAsync,
          m: emptyMetadataMap
        };
}

function strip(struct) {
  return set(struct, metadataId, "Strip");
}

function strict(struct) {
  return set(struct, metadataId, "Strict");
}

function transformationFactory(ctx) {
  planSyncTransformation(ctx, (function (input) {
          return raiseUnexpectedTypeError(input, ctx.s);
        }));
}

var struct = {
  n: "Never",
  t: "Never",
  parseOperationFactory: (function (b, param, inputVar, pathVar) {
      return {
              code: raiseWithArg(b, pathVar, (function (input) {
                      return {
                              TAG: "UnexpectedType",
                              expected: "Never",
                              received: toName(input)
                            };
                    }), inputVar) + ";",
              outputVar: inputVar,
              isAsync: false
            };
    }),
  isAsyncParseOperation: undefined,
  pf: transformationFactory,
  sf: transformationFactory,
  r: 0,
  e: 0,
  s: initialSerialize,
  j: initialSerializeToJson,
  p: intitialParse,
  a: intitialParseAsync,
  m: emptyMetadataMap
};

var struct$1 = {
  n: "Unknown",
  t: "Unknown",
  parseOperationFactory: (function (_b, param, inputVar, param$1) {
      return {
              code: "",
              outputVar: inputVar,
              isAsync: false
            };
    }),
  isAsyncParseOperation: undefined,
  pf: empty,
  sf: empty,
  r: 0,
  e: 0,
  s: initialSerialize,
  j: initialSerializeToJson,
  p: intitialParse,
  a: intitialParseAsync,
  m: emptyMetadataMap
};

var metadataId$1 = "rescript-struct:String.refinements";

function refinements(struct) {
  var m = Js_dict.get(struct.m, metadataId$1);
  if (m !== undefined) {
    return m;
  } else {
    return [];
  }
}

var cuidRegex = /^c[^\s-]{8,}$/i;

var uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;

var emailRegex = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;

var datetimeRe = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?Z$/;

function parseTransformationFactory(ctx) {
  planSyncTransformation(ctx, (function (input) {
          if (typeof input === "string") {
            return input;
          } else {
            return raiseUnexpectedTypeError(input, ctx.s);
          }
        }));
}

function parseOperationFactory(b, param, inputVar, pathVar) {
  return {
          code: "if(typeof " + inputVar + "!==\"string\"){" + raiseWithArg(b, pathVar, (function (input) {
                  return {
                          TAG: "UnexpectedType",
                          expected: "String",
                          received: toName(input)
                        };
                }), inputVar) + "}",
          outputVar: inputVar,
          isAsync: false
        };
}

var struct$2 = {
  n: "String",
  t: "String",
  parseOperationFactory: parseOperationFactory,
  isAsyncParseOperation: undefined,
  pf: parseTransformationFactory,
  sf: empty,
  r: 0,
  e: 0,
  s: initialSerialize,
  j: initialSerializeToJson,
  p: intitialParse,
  a: intitialParseAsync,
  m: emptyMetadataMap
};

function min(struct, maybeMessage, length) {
  var message = maybeMessage !== undefined ? maybeMessage : "String must be " + length.toString() + " or more characters long";
  var refiner = function (value) {
    if (value.length < length) {
      return fail(undefined, message);
    }
    
  };
  return addRefinement(struct, metadataId$1, {
              kind: {
                TAG: "Min",
                length: length
              },
              message: message
            }, refiner);
}

function max(struct, maybeMessage, length) {
  var message = maybeMessage !== undefined ? maybeMessage : "String must be " + length.toString() + " or fewer characters long";
  var refiner = function (value) {
    if (value.length > length) {
      return fail(undefined, message);
    }
    
  };
  return addRefinement(struct, metadataId$1, {
              kind: {
                TAG: "Max",
                length: length
              },
              message: message
            }, refiner);
}

function length(struct, maybeMessage, length$1) {
  var message = maybeMessage !== undefined ? maybeMessage : "String must be exactly " + length$1.toString() + " characters long";
  var refiner = function (value) {
    if (value.length !== length$1) {
      return fail(undefined, message);
    }
    
  };
  return addRefinement(struct, metadataId$1, {
              kind: {
                TAG: "Length",
                length: length$1
              },
              message: message
            }, refiner);
}

function email(struct, messageOpt, param) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid email address";
  var refiner = function (value) {
    if (!emailRegex.test(value)) {
      return fail(undefined, message);
    }
    
  };
  return addRefinement(struct, metadataId$1, {
              kind: "Email",
              message: message
            }, refiner);
}

function uuid(struct, messageOpt, param) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid UUID";
  var refiner = function (value) {
    if (!uuidRegex.test(value)) {
      return fail(undefined, message);
    }
    
  };
  return addRefinement(struct, metadataId$1, {
              kind: "Uuid",
              message: message
            }, refiner);
}

function cuid(struct, messageOpt, param) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid CUID";
  var refiner = function (value) {
    if (!cuidRegex.test(value)) {
      return fail(undefined, message);
    }
    
  };
  return addRefinement(struct, metadataId$1, {
              kind: "Cuid",
              message: message
            }, refiner);
}

function url(struct, messageOpt, param) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid url";
  var refiner = function (value) {
    var tmp;
    try {
      new URL(value);
      tmp = true;
    }
    catch (exn){
      tmp = false;
    }
    if (!tmp) {
      return fail(undefined, message);
    }
    
  };
  return addRefinement(struct, metadataId$1, {
              kind: "Url",
              message: message
            }, refiner);
}

function pattern(struct, messageOpt, re) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid";
  var refiner = function (value) {
    re.lastIndex = 0;
    if (!re.test(value)) {
      return fail(undefined, message);
    }
    
  };
  return addRefinement(struct, metadataId$1, {
              kind: {
                TAG: "Pattern",
                re: re
              },
              message: message
            }, refiner);
}

function datetime(struct, messageOpt, param) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid datetime string! Must be UTC";
  var refinement = {
    kind: "Datetime",
    message: message
  };
  var refinements = Js_dict.get(struct.m, metadataId$1);
  return transform(set(struct, metadataId$1, refinements !== undefined ? refinements.concat(refinement) : [refinement]), (function (string) {
                if (!datetimeRe.test(string)) {
                  fail(undefined, message);
                }
                return new Date(string);
              }), undefined, (function (date) {
                return date.toISOString();
              }), undefined);
}

function trim(struct, param) {
  var transformer = function (string) {
    return string.trim();
  };
  return transform(struct, transformer, undefined, transformer, undefined);
}

function factory$4(innerStruct) {
  return {
          n: "JsonString",
          t: "String",
          parseOperationFactory: (function (b, selfStruct, inputVar, pathVar) {
              var match = parseOperationFactory(b, selfStruct, inputVar, pathVar);
              var jsonVar = $$var(b);
              var match$1 = compileParser(b, innerStruct, jsonVar, pathVar);
              return {
                      code: match.code + "try{" + jsonVar + "=JSON.parse(" + match.outputVar + ")}catch(t){" + raiseWithArg(b, pathVar, (function (message) {
                              return {
                                      TAG: "OperationFailed",
                                      _0: message
                                    };
                            }), "t.message") + "}" + match$1.code,
                      outputVar: match$1.outputVar,
                      isAsync: match$1.isAsync
                    };
            }),
          isAsyncParseOperation: undefined,
          pf: (function (ctx) {
              var fn = getParseOperation(innerStruct);
              var $$process;
              $$process = typeof fn !== "object" ? (function (prim) {
                    return prim;
                  }) : fn._0;
              planSyncTransformation(ctx, (function (input) {
                      if (typeof input !== "string") {
                        return raiseUnexpectedTypeError(input, ctx.s);
                      }
                      var __x;
                      try {
                        __x = JSON.parse(input);
                      }
                      catch (raw_obj){
                        var obj = Caml_js_exceptions.internalToOCamlException(raw_obj);
                        if (obj.RE_EXN_ID === Js_exn.$$Error) {
                          var m = obj._1.message;
                          __x = fail(undefined, m !== undefined ? m : "Failed to parse JSON");
                        } else {
                          throw obj;
                        }
                      }
                      return $$process(__x);
                    }));
              var match = getParseOperation(innerStruct);
              if (typeof match !== "object" || match.TAG === "SyncOperation") {
                return ;
              } else {
                return planAsyncTransformation(ctx, (function (asyncFn) {
                              return asyncFn(undefined);
                            }));
              }
            }),
          sf: (function (ctx) {
              var fn = getSerializeOperation(innerStruct);
              if (fn !== undefined) {
                return planSyncTransformation(ctx, (function (input) {
                              return JSON.stringify(fn(input));
                            }));
              } else {
                return planSyncTransformation(ctx, (function (input) {
                              return JSON.stringify(input);
                            }));
              }
            }),
          r: 0,
          e: 0,
          s: initialSerialize,
          j: initialSerializeToJson,
          p: intitialParse,
          a: intitialParseAsync,
          m: emptyMetadataMap
        };
}

function parseTransformationFactory$1(ctx) {
  planSyncTransformation(ctx, (function (input) {
          if (typeof input === "boolean") {
            return input;
          } else {
            return raiseUnexpectedTypeError(input, ctx.s);
          }
        }));
}

var struct$3 = {
  n: "Bool",
  t: "Bool",
  parseOperationFactory: (function (b, param, inputVar, pathVar) {
      return {
              code: "if(typeof " + inputVar + "!==\"boolean\"){" + raiseWithArg(b, pathVar, (function (input) {
                      return {
                              TAG: "UnexpectedType",
                              expected: "Bool",
                              received: toName(input)
                            };
                    }), inputVar) + "}",
              outputVar: inputVar,
              isAsync: false
            };
    }),
  isAsyncParseOperation: undefined,
  pf: parseTransformationFactory$1,
  sf: empty,
  r: 0,
  e: 0,
  s: initialSerialize,
  j: initialSerializeToJson,
  p: intitialParse,
  a: intitialParseAsync,
  m: emptyMetadataMap
};

var metadataId$2 = "rescript-struct:Int.refinements";

function refinements$1(struct) {
  var m = Js_dict.get(struct.m, metadataId$2);
  if (m !== undefined) {
    return m;
  } else {
    return [];
  }
}

function parseTransformationFactory$2(ctx) {
  planSyncTransformation(ctx, (function (input) {
          if (typeof input === "number" && input < 2147483648 && input > -2147483649 && input % 1 === 0) {
            return input;
          } else {
            return raiseUnexpectedTypeError(input, ctx.s);
          }
        }));
}

var struct$4 = {
  n: "Int",
  t: "Int",
  parseOperationFactory: (function (b, param, inputVar, pathVar) {
      return {
              code: "if(!(typeof " + inputVar + "===\"number\"&&" + inputVar + "<2147483648&&" + inputVar + ">-2147483649&&" + inputVar + "%1===0)){" + raiseWithArg(b, pathVar, (function (input) {
                      return {
                              TAG: "UnexpectedType",
                              expected: "Int",
                              received: toName(input)
                            };
                    }), inputVar) + "}",
              outputVar: inputVar,
              isAsync: false
            };
    }),
  isAsyncParseOperation: undefined,
  pf: parseTransformationFactory$2,
  sf: empty,
  r: 0,
  e: 0,
  s: initialSerialize,
  j: initialSerializeToJson,
  p: intitialParse,
  a: intitialParseAsync,
  m: emptyMetadataMap
};

function min$1(struct, maybeMessage, minValue) {
  var message = maybeMessage !== undefined ? maybeMessage : "Number must be greater than or equal to " + minValue.toString();
  var refiner = function (value) {
    if (value < minValue) {
      return fail(undefined, message);
    }
    
  };
  return addRefinement(struct, metadataId$2, {
              kind: {
                TAG: "Min",
                value: minValue
              },
              message: message
            }, refiner);
}

function max$1(struct, maybeMessage, maxValue) {
  var message = maybeMessage !== undefined ? maybeMessage : "Number must be lower than or equal to " + maxValue.toString();
  var refiner = function (value) {
    if (value > maxValue) {
      return fail(undefined, message);
    }
    
  };
  return addRefinement(struct, metadataId$2, {
              kind: {
                TAG: "Max",
                value: maxValue
              },
              message: message
            }, refiner);
}

function port(struct, messageOpt, param) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid port";
  var refiner = function (value) {
    if (value < 1 || value > 65535) {
      return fail(undefined, message);
    }
    
  };
  return addRefinement(struct, metadataId$2, {
              kind: "Port",
              message: message
            }, refiner);
}

var metadataId$3 = "rescript-struct:Float.refinements";

function refinements$2(struct) {
  var m = Js_dict.get(struct.m, metadataId$3);
  if (m !== undefined) {
    return m;
  } else {
    return [];
  }
}

function parseTransformationFactory$3(ctx) {
  planSyncTransformation(ctx, (function (input) {
          if (typeof input === "number" && !Number.isNaN(input)) {
            return input;
          } else {
            return raiseUnexpectedTypeError(input, ctx.s);
          }
        }));
}

var struct$5 = {
  n: "Float",
  t: "Float",
  parseOperationFactory: (function (b, param, inputVar, pathVar) {
      return {
              code: "if(!(typeof " + inputVar + "===\"number\"&&!Number.isNaN(" + inputVar + "))){" + raiseWithArg(b, pathVar, (function (input) {
                      return {
                              TAG: "UnexpectedType",
                              expected: "Float",
                              received: toName(input)
                            };
                    }), inputVar) + "}",
              outputVar: inputVar,
              isAsync: false
            };
    }),
  isAsyncParseOperation: undefined,
  pf: parseTransformationFactory$3,
  sf: empty,
  r: 0,
  e: 0,
  s: initialSerialize,
  j: initialSerializeToJson,
  p: intitialParse,
  a: intitialParseAsync,
  m: emptyMetadataMap
};

function min$2(struct, maybeMessage, minValue) {
  var message = maybeMessage !== undefined ? maybeMessage : "Number must be greater than or equal to " + minValue.toString();
  var refiner = function (value) {
    if (value < minValue) {
      return fail(undefined, message);
    }
    
  };
  return addRefinement(struct, metadataId$3, {
              kind: {
                TAG: "Min",
                value: minValue
              },
              message: message
            }, refiner);
}

function max$2(struct, maybeMessage, maxValue) {
  var message = maybeMessage !== undefined ? maybeMessage : "Number must be lower than or equal to " + maxValue.toString();
  var refiner = function (value) {
    if (value > maxValue) {
      return fail(undefined, message);
    }
    
  };
  return addRefinement(struct, metadataId$3, {
              kind: {
                TAG: "Max",
                value: maxValue
              },
              message: message
            }, refiner);
}

function factory$5(innerStruct) {
  return {
          n: "Null",
          t: {
            TAG: "Null",
            _0: innerStruct
          },
          parseOperationFactory: (function (b, param, inputVar, pathVar) {
              var match = compileParser(b, innerStruct, inputVar, pathVar);
              var isInnerStructAsync = match.isAsync;
              var outputVar = $$var(b);
              return {
                      code: "if(" + inputVar + "!==null){" + match.code + syncTransform(b, match.outputVar, outputVar, isInnerStructAsync, Caml_option.some, undefined, undefined, undefined) + "}else{" + outputVar + "=" + (
                        isInnerStructAsync ? "()=>Promise.resolve(undefined)" : "undefined"
                      ) + "}",
                      outputVar: outputVar,
                      isAsync: isInnerStructAsync
                    };
            }),
          isAsyncParseOperation: undefined,
          pf: (function (ctx) {
              var planSyncTransformation$1 = function (fn) {
                planSyncTransformation(ctx, (function (input) {
                        if (input !== null) {
                          return Caml_option.some(fn(input));
                        }
                        
                      }));
              };
              var fn = getParseOperation(innerStruct);
              if (typeof fn !== "object") {
                return planSyncTransformation(ctx, (function ($$null) {
                              if ($$null === null) {
                                return ;
                              } else {
                                return Caml_option.some($$null);
                              }
                            }));
              }
              if (fn.TAG === "SyncOperation") {
                return planSyncTransformation$1(fn._0);
              }
              planSyncTransformation$1(fn._0);
              planAsyncTransformation(ctx, (function (input) {
                      if (input !== undefined) {
                        return input(undefined).then(function (value) {
                                    return Caml_option.some(value);
                                  });
                      } else {
                        return Promise.resolve(undefined);
                      }
                    }));
            }),
          sf: (function (ctx) {
              var fn = getSerializeOperation(innerStruct);
              if (fn !== undefined) {
                return planSyncTransformation(ctx, (function (input) {
                              if (input !== undefined) {
                                return fn(Caml_option.valFromOption(input));
                              } else {
                                return null;
                              }
                            }));
              } else {
                return planSyncTransformation(ctx, (function (input) {
                              if (input !== undefined) {
                                return Caml_option.valFromOption(input);
                              } else {
                                return null;
                              }
                            }));
              }
            }),
          r: 0,
          e: 0,
          s: initialSerialize,
          j: initialSerializeToJson,
          p: intitialParse,
          a: intitialParseAsync,
          m: emptyMetadataMap
        };
}

function factory$6(innerStruct) {
  return {
          n: "Option",
          t: {
            TAG: "Option",
            _0: innerStruct
          },
          parseOperationFactory: (function (b, param, inputVar, pathVar) {
              var match = compileParser(b, innerStruct, inputVar, pathVar);
              var isInnerStructAsync = match.isAsync;
              var outputVar = $$var(b);
              return {
                      code: "if(" + inputVar + "!==undefined){" + match.code + syncTransform(b, match.outputVar, outputVar, isInnerStructAsync, Caml_option.some, undefined, undefined, undefined) + "}else{" + outputVar + "=" + (
                        isInnerStructAsync ? "()=>Promise.resolve(" + inputVar + ")" : inputVar
                      ) + "}",
                      outputVar: outputVar,
                      isAsync: isInnerStructAsync
                    };
            }),
          isAsyncParseOperation: undefined,
          pf: (function (ctx) {
              var planSyncTransformation$1 = function (fn) {
                planSyncTransformation(ctx, (function (input) {
                        if (input !== undefined) {
                          return Caml_option.some(fn(Caml_option.valFromOption(input)));
                        }
                        
                      }));
              };
              var fn = getParseOperation(innerStruct);
              if (typeof fn !== "object") {
                return ;
              }
              if (fn.TAG === "SyncOperation") {
                return planSyncTransformation$1(fn._0);
              }
              planSyncTransformation$1(fn._0);
              planAsyncTransformation(ctx, (function (input) {
                      if (input !== undefined) {
                        return input(undefined).then(function (value) {
                                    return Caml_option.some(value);
                                  });
                      } else {
                        return Promise.resolve(undefined);
                      }
                    }));
            }),
          sf: (function (ctx) {
              var fn = getSerializeOperation(innerStruct);
              if (fn !== undefined) {
                return planSyncTransformation(ctx, (function (input) {
                              if (input !== undefined) {
                                return fn(Caml_option.valFromOption(input));
                              }
                              
                            }));
              } else {
                return planSyncTransformation(ctx, (function (input) {
                              if (input !== undefined) {
                                return Caml_option.valFromOption(input);
                              }
                              
                            }));
              }
            }),
          r: 0,
          e: 0,
          s: initialSerialize,
          j: initialSerializeToJson,
          p: intitialParse,
          a: intitialParseAsync,
          m: emptyMetadataMap
        };
}

var metadataId$4 = "rescript-struct:Array.refinements";

function refinements$3(struct) {
  var m = Js_dict.get(struct.m, metadataId$4);
  if (m !== undefined) {
    return m;
  } else {
    return [];
  }
}

function factory$7(innerStruct) {
  return {
          n: "Array",
          t: {
            TAG: "Array",
            _0: innerStruct
          },
          parseOperationFactory: (function (b, param, inputVar, pathVar) {
              var itemVar = varWithoutAllocation(b);
              var iteratorVar = varWithoutAllocation(b);
              var match = compileParser(b, innerStruct, itemVar, pathVar + "+'[\"'+" + iteratorVar + "+'\"]'");
              var syncOutputVar = varWithoutAllocation(b);
              var syncCode = "if(!Array.isArray(" + inputVar + ")){" + raiseWithArg(b, pathVar, (function (input) {
                      return {
                              TAG: "UnexpectedType",
                              expected: "Array",
                              received: toName(input)
                            };
                    }), inputVar) + "}let " + syncOutputVar + "=[];for(let " + iteratorVar + "=0;" + iteratorVar + "<" + inputVar + ".length;++" + iteratorVar + "){let " + itemVar + "=" + inputVar + "[" + iteratorVar + "];" + match.code + syncOutputVar + ".push(" + match.outputVar + ")}";
              if (!match.isAsync) {
                return {
                        code: syncCode,
                        outputVar: syncOutputVar,
                        isAsync: false
                      };
              }
              var outputVar = $$var(b);
              return {
                      code: syncCode + (outputVar + "=()=>Promise.all(" + syncOutputVar + ".map(t=>t()));"),
                      outputVar: outputVar,
                      isAsync: true
                    };
            }),
          isAsyncParseOperation: undefined,
          pf: (function (ctx) {
              planSyncTransformation(ctx, (function (input) {
                      if (Array.isArray(input) === false) {
                        return raiseUnexpectedTypeError(input, ctx.s);
                      } else {
                        return input;
                      }
                    }));
              var planSyncTransformation$1 = function (fn) {
                planSyncTransformation(ctx, (function (input) {
                        var newArray = [];
                        for(var idx = 0 ,idx_finish = input.length; idx < idx_finish; ++idx){
                          var innerData = input[idx];
                          try {
                            var value = fn(innerData);
                            newArray.push(value);
                          }
                          catch (raw_internalError){
                            var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                            if (internalError.RE_EXN_ID === Exception) {
                              var $$location = idx.toString();
                              throw {
                                    RE_EXN_ID: Exception,
                                    _1: prependPath(internalError._1, "[" + JSON.stringify($$location) + "]"),
                                    Error: new Error()
                                  };
                            }
                            throw internalError;
                          }
                        }
                        return newArray;
                      }));
              };
              var fn = getParseOperation(innerStruct);
              if (typeof fn !== "object") {
                return ;
              }
              if (fn.TAG === "SyncOperation") {
                return planSyncTransformation$1(fn._0);
              }
              planSyncTransformation$1(fn._0);
              planAsyncTransformation(ctx, (function (input) {
                      return Promise.all(input.map(function (asyncFn, idx) {
                                      return asyncFn(undefined).catch(function (exn) {
                                                  var tmp;
                                                  if (exn.RE_EXN_ID === Exception) {
                                                    var $$location = idx.toString();
                                                    tmp = {
                                                      RE_EXN_ID: Exception,
                                                      _1: prependPath(exn._1, "[" + JSON.stringify($$location) + "]")
                                                    };
                                                  } else {
                                                    tmp = exn;
                                                  }
                                                  throw tmp;
                                                });
                                    }));
                    }));
            }),
          sf: (function (ctx) {
              var fn = getSerializeOperation(innerStruct);
              if (fn !== undefined) {
                return planSyncTransformation(ctx, (function (input) {
                              var newArray = [];
                              for(var idx = 0 ,idx_finish = input.length; idx < idx_finish; ++idx){
                                var innerData = input[idx];
                                try {
                                  var value = fn(innerData);
                                  newArray.push(value);
                                }
                                catch (raw_internalError){
                                  var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                                  if (internalError.RE_EXN_ID === Exception) {
                                    var $$location = idx.toString();
                                    throw {
                                          RE_EXN_ID: Exception,
                                          _1: prependPath(internalError._1, "[" + JSON.stringify($$location) + "]"),
                                          Error: new Error()
                                        };
                                  }
                                  throw internalError;
                                }
                              }
                              return newArray;
                            }));
              }
              
            }),
          r: 0,
          e: 0,
          s: initialSerialize,
          j: initialSerializeToJson,
          p: intitialParse,
          a: intitialParseAsync,
          m: emptyMetadataMap
        };
}

function min$3(struct, maybeMessage, length) {
  var message = maybeMessage !== undefined ? maybeMessage : "Array must be " + length.toString() + " or more items long";
  var refiner = function (value) {
    if (value.length < length) {
      return fail(undefined, message);
    }
    
  };
  return addRefinement(struct, metadataId$4, {
              kind: {
                TAG: "Min",
                length: length
              },
              message: message
            }, refiner);
}

function max$3(struct, maybeMessage, length) {
  var message = maybeMessage !== undefined ? maybeMessage : "Array must be " + length.toString() + " or fewer items long";
  var refiner = function (value) {
    if (value.length > length) {
      return fail(undefined, message);
    }
    
  };
  return addRefinement(struct, metadataId$4, {
              kind: {
                TAG: "Max",
                length: length
              },
              message: message
            }, refiner);
}

function length$1(struct, maybeMessage, length$2) {
  var message = maybeMessage !== undefined ? maybeMessage : "Array must be exactly " + length$2.toString() + " items long";
  var refiner = function (value) {
    if (value.length !== length$2) {
      return fail(undefined, message);
    }
    
  };
  return addRefinement(struct, metadataId$4, {
              kind: {
                TAG: "Length",
                length: length$2
              },
              message: message
            }, refiner);
}

function factory$8(innerStruct) {
  return {
          n: "Dict",
          t: {
            TAG: "Dict",
            _0: innerStruct
          },
          parseOperationFactory: (function (b, param, inputVar, pathVar) {
              var itemVar = varWithoutAllocation(b);
              var keyVar = varWithoutAllocation(b);
              var match = compileParser(b, innerStruct, itemVar, pathVar + "+'[\"'+" + keyVar + "+'\"]'");
              var syncOutputVar = varWithoutAllocation(b);
              var syncCode = "if(!(typeof " + inputVar + "===\"object\"&&" + inputVar + "!==null&&!Array.isArray(" + inputVar + "))){" + raiseWithArg(b, pathVar, (function (input) {
                      return {
                              TAG: "UnexpectedType",
                              expected: "Dict",
                              received: toName(input)
                            };
                    }), inputVar) + "}let " + syncOutputVar + "={};for(let " + keyVar + " in " + inputVar + "){let " + itemVar + "=" + inputVar + "[" + keyVar + "];" + match.code + syncOutputVar + "[" + keyVar + "]=" + match.outputVar + "}";
              if (!match.isAsync) {
                return {
                        code: syncCode,
                        outputVar: syncOutputVar,
                        isAsync: false
                      };
              }
              var outputVar = $$var(b);
              var resolveVar = varWithoutAllocation(b);
              var rejectVar = varWithoutAllocation(b);
              var asyncParseResultVar = varWithoutAllocation(b);
              var counterVar = varWithoutAllocation(b);
              return {
                      code: syncCode + outputVar + "=()=>new Promise((" + resolveVar + "," + rejectVar + ")=>{let " + counterVar + "=Object.keys(" + syncOutputVar + ").length;for(let " + keyVar + " in " + syncOutputVar + "){" + syncOutputVar + "[" + keyVar + "]().then(" + asyncParseResultVar + "=>{" + syncOutputVar + "[" + keyVar + "]=" + asyncParseResultVar + ";if(" + counterVar + "--===1){" + resolveVar + "(" + syncOutputVar + ")}}," + rejectVar + ")}});",
                      outputVar: outputVar,
                      isAsync: true
                    };
            }),
          isAsyncParseOperation: undefined,
          pf: (function (ctx) {
              var planSyncTransformation$1 = function (fn) {
                planSyncTransformation(ctx, (function (input) {
                        var newDict = {};
                        var keys = Object.keys(input);
                        for(var idx = 0 ,idx_finish = keys.length; idx < idx_finish; ++idx){
                          var key = keys[idx];
                          var innerData = input[key];
                          try {
                            var value = fn(innerData);
                            newDict[key] = value;
                          }
                          catch (raw_internalError){
                            var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                            if (internalError.RE_EXN_ID === Exception) {
                              throw {
                                    RE_EXN_ID: Exception,
                                    _1: prependPath(internalError._1, "[" + JSON.stringify(key) + "]"),
                                    Error: new Error()
                                  };
                            }
                            throw internalError;
                          }
                        }
                        return newDict;
                      }));
              };
              planSyncTransformation(ctx, (function (input) {
                      if ((typeof input === "object" && input !== null && !Array.isArray(input)) === false) {
                        return raiseUnexpectedTypeError(input, ctx.s);
                      } else {
                        return input;
                      }
                    }));
              var fn = getParseOperation(innerStruct);
              if (typeof fn !== "object") {
                return ;
              }
              if (fn.TAG === "SyncOperation") {
                return planSyncTransformation$1(fn._0);
              }
              planSyncTransformation$1(fn._0);
              planAsyncTransformation(ctx, (function (input) {
                      var keys = Object.keys(input);
                      return Promise.all(keys.map(function (key) {
                                        var asyncFn = input[key];
                                        try {
                                          return asyncFn(undefined).catch(function (exn) {
                                                      throw exn.RE_EXN_ID === Exception ? ({
                                                                RE_EXN_ID: Exception,
                                                                _1: prependPath(exn._1, "[" + JSON.stringify(key) + "]")
                                                              }) : exn;
                                                    });
                                        }
                                        catch (raw_internalError){
                                          var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                                          if (internalError.RE_EXN_ID === Exception) {
                                            throw {
                                                  RE_EXN_ID: Exception,
                                                  _1: prependPath(internalError._1, "[" + JSON.stringify(key) + "]"),
                                                  Error: new Error()
                                                };
                                          }
                                          throw internalError;
                                        }
                                      })).then(function (values) {
                                  var tempDict = {};
                                  values.forEach(function (value, idx) {
                                        var key = keys[idx];
                                        tempDict[key] = value;
                                      });
                                  return tempDict;
                                });
                    }));
            }),
          sf: (function (ctx) {
              var fn = getSerializeOperation(innerStruct);
              if (fn !== undefined) {
                return planSyncTransformation(ctx, (function (input) {
                              var newDict = {};
                              var keys = Object.keys(input);
                              for(var idx = 0 ,idx_finish = keys.length; idx < idx_finish; ++idx){
                                var key = keys[idx];
                                var innerData = input[key];
                                try {
                                  var value = fn(innerData);
                                  newDict[key] = value;
                                }
                                catch (raw_internalError){
                                  var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                                  if (internalError.RE_EXN_ID === Exception) {
                                    throw {
                                          RE_EXN_ID: Exception,
                                          _1: prependPath(internalError._1, "[" + JSON.stringify(key) + "]"),
                                          Error: new Error()
                                        };
                                  }
                                  throw internalError;
                                }
                              }
                              return newDict;
                            }));
              }
              
            }),
          r: 0,
          e: 0,
          s: initialSerialize,
          j: initialSerializeToJson,
          p: intitialParse,
          a: intitialParseAsync,
          m: emptyMetadataMap
        };
}

var metadataId$5 = "rescript-struct:Default";

function factory$9(innerStruct, getDefaultValue) {
  var innerStruct$1 = factory$6(innerStruct);
  return set({
              n: innerStruct$1.n,
              t: innerStruct$1.t,
              parseOperationFactory: (function (b, param, inputVar, pathVar) {
                  var match = compileParser(b, innerStruct$1, inputVar, pathVar);
                  var isInnerStructAsync = match.isAsync;
                  var outputVar = $$var(b);
                  var defaultValVar = "e[" + (b.embeded.push(getDefaultValue) - 1) + "]()";
                  return {
                          code: "if(" + inputVar + "!==undefined){" + match.code + syncTransform(b, match.outputVar, outputVar, isInnerStructAsync, Caml_option.some, undefined, undefined, undefined) + "}else{" + outputVar + "=" + (
                            isInnerStructAsync ? "()=>Promise.resolve(" + defaultValVar + ")" : defaultValVar
                          ) + "}",
                          outputVar: outputVar,
                          isAsync: isInnerStructAsync
                        };
                }),
              isAsyncParseOperation: undefined,
              pf: (function (ctx) {
                  var fn = getParseOperation(innerStruct$1);
                  if (typeof fn !== "object") {
                    return planSyncTransformation(ctx, (function (input) {
                                  if (input !== undefined) {
                                    return Caml_option.valFromOption(input);
                                  } else {
                                    return getDefaultValue(undefined);
                                  }
                                }));
                  }
                  if (fn.TAG === "SyncOperation") {
                    var fn$1 = fn._0;
                    return planSyncTransformation(ctx, (function (input) {
                                  var v = fn$1(input);
                                  if (v !== undefined) {
                                    return Caml_option.valFromOption(v);
                                  } else {
                                    return getDefaultValue(undefined);
                                  }
                                }));
                  }
                  planSyncTransformation(ctx, fn._0);
                  planAsyncTransformation(ctx, (function (asyncFn) {
                          return asyncFn(undefined).then(function (value) {
                                      if (value !== undefined) {
                                        return Caml_option.valFromOption(value);
                                      } else {
                                        return getDefaultValue(undefined);
                                      }
                                    });
                        }));
                }),
              sf: (function (ctx) {
                  var fn = getSerializeOperation(innerStruct$1);
                  if (fn !== undefined) {
                    return planSyncTransformation(ctx, (function (input) {
                                  var value = Caml_option.some(input);
                                  return fn(value);
                                }));
                  } else {
                    return planSyncTransformation(ctx, (function (input) {
                                  return Caml_option.some(input);
                                }));
                  }
                }),
              r: 0,
              e: 0,
              s: initialSerialize,
              j: initialSerializeToJson,
              p: intitialParse,
              a: intitialParseAsync,
              m: emptyMetadataMap
            }, metadataId$5, getDefaultValue);
}

function classify$2(struct) {
  var getDefaultValue = Js_dict.get(struct.m, metadataId$5);
  if (getDefaultValue !== undefined) {
    return Caml_option.some(getDefaultValue(undefined));
  }
  
}

function factory$10(structs) {
  var numberOfStructs = structs.length;
  return {
          n: "Tuple",
          t: {
            TAG: "Tuple",
            _0: structs
          },
          parseOperationFactory: (function (b, param, inputVar, pathVar) {
              var codeRef = "if(!Array.isArray(" + inputVar + ")){" + raiseWithArg(b, pathVar, (function (input) {
                      return {
                              TAG: "UnexpectedType",
                              expected: "Tuple",
                              received: toName(input)
                            };
                    }), inputVar) + "}if(" + inputVar + ".length!==" + numberOfStructs + "){" + raiseWithArg(b, pathVar, (function (numberOfInputItems) {
                      return {
                              TAG: "TupleSize",
                              expected: numberOfStructs,
                              received: numberOfInputItems
                            };
                    }), inputVar + ".length") + "}";
              var len = structs.length;
              if (len !== 1) {
                if (len === 0) {
                  return {
                          code: codeRef,
                          outputVar: "void 0",
                          isAsync: false
                        };
                }
                var asyncItemVars = [];
                var syncOutputVar = varWithoutAllocation(b);
                codeRef = codeRef + ("let " + syncOutputVar + "=[];");
                for(var idx = 0 ,idx_finish = structs.length; idx < idx_finish; ++idx){
                  var itemStruct = structs[idx];
                  var match = compileParser(b, itemStruct, inputVar + "[" + idx + "]", pathVar + "+'[\"" + idx + "\"]'");
                  var destVar = syncOutputVar + "[" + idx + "]";
                  codeRef = codeRef + (match.code + destVar + "=" + match.outputVar + ";");
                  if (match.isAsync) {
                    asyncItemVars.push(destVar);
                  }
                  
                }
                if (asyncItemVars.length === 0) {
                  return {
                          code: codeRef,
                          outputVar: syncOutputVar,
                          isAsync: false
                        };
                }
                var outputVar = $$var(b);
                var resolveVar = varWithoutAllocation(b);
                var rejectVar = varWithoutAllocation(b);
                var asyncParseResultVar = varWithoutAllocation(b);
                var counterVar = varWithoutAllocation(b);
                return {
                        code: codeRef + outputVar + "=()=>new Promise((" + resolveVar + "," + rejectVar + ")=>{let " + counterVar + "=" + asyncItemVars.length.toString() + ";" + asyncItemVars.map(function (asyncItemVar) {
                                return asyncItemVar + "().then(" + asyncParseResultVar + "=>{" + asyncItemVar + "=" + asyncParseResultVar + ";if(" + counterVar + "--===1){" + resolveVar + "(" + syncOutputVar + ")}}," + rejectVar + ")";
                              }).join(";") + "});",
                        outputVar: outputVar,
                        isAsync: true
                      };
              }
              var itemStruct$1 = structs[0];
              var match$1 = compileParser(b, itemStruct$1, inputVar + "[0]", pathVar + "+'[\"0\"]'");
              return {
                      code: codeRef + match$1.code,
                      outputVar: match$1.outputVar,
                      isAsync: match$1.isAsync
                    };
            }),
          isAsyncParseOperation: undefined,
          pf: (function (ctx) {
              var noopOps = [];
              var syncOps = [];
              var asyncOps = [];
              for(var idx = 0 ,idx_finish = structs.length; idx < idx_finish; ++idx){
                var innerStruct = structs[idx];
                var fn = getParseOperation(innerStruct);
                if (typeof fn !== "object") {
                  noopOps.push(idx);
                } else if (fn.TAG === "SyncOperation") {
                  syncOps.push([
                        idx,
                        fn._0
                      ]);
                } else {
                  syncOps.push([
                        idx,
                        fn._0
                      ]);
                  asyncOps.push(idx);
                }
              }
              var withAsyncOps = asyncOps.length > 0;
              planSyncTransformation(ctx, (function (input) {
                      if (Array.isArray(input)) {
                        var numberOfInputItems = input.length;
                        if (numberOfStructs !== numberOfInputItems) {
                          raise$1({
                                TAG: "TupleSize",
                                expected: numberOfStructs,
                                received: numberOfInputItems
                              });
                        }
                        
                      } else {
                        raiseUnexpectedTypeError(input, ctx.s);
                      }
                      var newArray = [];
                      for(var idx = 0 ,idx_finish = syncOps.length; idx < idx_finish; ++idx){
                        var match = syncOps[idx];
                        var originalIdx = match[0];
                        var innerData = input[originalIdx];
                        try {
                          var value = match[1](innerData);
                          newArray[originalIdx] = value;
                        }
                        catch (raw_internalError){
                          var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                          if (internalError.RE_EXN_ID === Exception) {
                            var $$location = idx.toString();
                            throw {
                                  RE_EXN_ID: Exception,
                                  _1: prependPath(internalError._1, "[" + JSON.stringify($$location) + "]"),
                                  Error: new Error()
                                };
                          }
                          throw internalError;
                        }
                      }
                      for(var idx$1 = 0 ,idx_finish$1 = noopOps.length; idx$1 < idx_finish$1; ++idx$1){
                        var originalIdx$1 = noopOps[idx$1];
                        var innerData$1 = input[originalIdx$1];
                        newArray[originalIdx$1] = innerData$1;
                      }
                      if (withAsyncOps) {
                        return newArray;
                      } else if (numberOfStructs !== 0) {
                        if (numberOfStructs !== 1) {
                          return newArray;
                        } else {
                          return newArray[0];
                        }
                      } else {
                        return ;
                      }
                    }));
              if (withAsyncOps) {
                return planAsyncTransformation(ctx, (function (tempArray) {
                              return Promise.all(asyncOps.map(function (originalIdx) {
                                                return tempArray[originalIdx](undefined).catch(function (exn) {
                                                            var tmp;
                                                            if (exn.RE_EXN_ID === Exception) {
                                                              var $$location = originalIdx.toString();
                                                              tmp = {
                                                                RE_EXN_ID: Exception,
                                                                _1: prependPath(exn._1, "[" + JSON.stringify($$location) + "]")
                                                              };
                                                            } else {
                                                              tmp = exn;
                                                            }
                                                            throw tmp;
                                                          });
                                              })).then(function (values) {
                                          values.forEach(function (value, idx) {
                                                var originalIdx = asyncOps[idx];
                                                tempArray[originalIdx] = value;
                                              });
                                          if (tempArray.length <= 1) {
                                            return tempArray[0];
                                          } else {
                                            return tempArray;
                                          }
                                        });
                            }));
              }
              
            }),
          sf: (function (ctx) {
              var serializeOperations = [];
              for(var idx = 0 ,idx_finish = structs.length; idx < idx_finish; ++idx){
                serializeOperations.push(getSerializeOperation(structs[idx]));
              }
              planSyncTransformation(ctx, (function (input) {
                      var inputArray = numberOfStructs === 1 ? [input] : input;
                      var newArray = [];
                      for(var idx = 0 ,idx_finish = serializeOperations.length; idx < idx_finish; ++idx){
                        var innerData = inputArray[idx];
                        var serializeOperation = serializeOperations[idx];
                        if (serializeOperation !== undefined) {
                          try {
                            var value = serializeOperation(innerData);
                            newArray.push(value);
                          }
                          catch (raw_internalError){
                            var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                            if (internalError.RE_EXN_ID === Exception) {
                              var $$location = idx.toString();
                              throw {
                                    RE_EXN_ID: Exception,
                                    _1: prependPath(internalError._1, "[" + JSON.stringify($$location) + "]"),
                                    Error: new Error()
                                  };
                            }
                            throw internalError;
                          }
                        } else {
                          newArray.push(innerData);
                        }
                      }
                      return newArray;
                    }));
            }),
          r: 0,
          e: 0,
          s: initialSerialize,
          j: initialSerializeToJson,
          p: intitialParse,
          a: intitialParseAsync,
          m: emptyMetadataMap
        };
}

function factoryFromArgs(param) {
  return factory$10((Array.from(arguments)));
}

var Tuple = {
  factory: factory$10,
  factoryFromArgs: factoryFromArgs
};

var HackyValidValue = /* @__PURE__ */Caml_exceptions.create("S-RescriptStruct.Union.HackyValidValue");

function factory$11(structs) {
  if (structs.length < 2) {
    throw new Error("[rescript-struct] A Union struct factory require at least two structs.");
  }
  return {
          n: "Union",
          t: {
            TAG: "Union",
            _0: structs
          },
          parseOperationFactory: (function (b, selfStruct, inputVar, pathVar) {
              var structs = selfStruct.t._0;
              var errorVars = [];
              var asyncItems = {};
              var withAsyncItemRef = false;
              var outputVar = $$var(b);
              var codeRef = "";
              var codeEndRef = "";
              for(var idx = 0 ,idx_finish = structs.length; idx < idx_finish; ++idx){
                var itemStruct = structs[idx];
                var match = compileParser(b, itemStruct, inputVar, "\"\"");
                var isAsyncItem = match.isAsync;
                var itemOutputVar = match.outputVar;
                var errorVar = varWithoutAllocation(b);
                errorVars.push(errorVar);
                if (isAsyncItem) {
                  withAsyncItemRef = true;
                  asyncItems[idx] = itemOutputVar;
                }
                codeRef = codeRef + ("try{" + match.code + (
                    isAsyncItem ? "throw " : outputVar + "="
                  ) + itemOutputVar + "}catch(" + errorVar + "){if(" + errorVar + "&&" + errorVar + ".RE_EXN_ID===\"S-RescriptStruct.Error.Internal.Exception/1\"" + (
                    isAsyncItem ? "||" + errorVar + "===" + itemOutputVar : ""
                  ) + "){");
                codeEndRef = "}else{throw " + errorVar + "}}" + codeEndRef;
              }
              if (!withAsyncItemRef) {
                return {
                        code: codeRef + raiseWithArg(b, pathVar, (function (internalErrors) {
                                return {
                                        TAG: "InvalidUnion",
                                        _0: internalErrors.map(toParseError)
                                      };
                              }), "[" + errorVars.map(function (v) {
                                    return v + "._1";
                                  }).join(",") + "]") + codeEndRef,
                        outputVar: outputVar,
                        isAsync: false
                      };
              }
              var asyncOutputVar = $$var(b);
              codeRef = codeRef + (asyncOutputVar + "=()=>Promise.any([");
              for(var idx$1 = 0 ,idx_finish$1 = errorVars.length; idx$1 < idx_finish$1; ++idx$1){
                var errorVar$1 = errorVars[idx$1];
                var maybeAsyncVar = Js_dict.get(asyncItems, idx$1);
                if (idx$1 !== 0) {
                  codeRef = codeRef + ",";
                }
                if (maybeAsyncVar !== undefined) {
                  codeRef = codeRef + (errorVar$1 + "===" + maybeAsyncVar + "?" + errorVar$1 + "():");
                }
                codeRef = codeRef + ("Promise.reject(" + errorVar$1 + ")");
              }
              codeRef = codeRef + ("]).catch(t=>{t=t.errors;" + raiseWithArg(b, pathVar, (function (internalErrors) {
                        return {
                                TAG: "InvalidUnion",
                                _0: internalErrors.map(toParseError)
                              };
                      }), "[" + errorVars.map(function (param, idx) {
                            return "t[" + idx + "]._1";
                          }).join(",") + "]") + "})");
              return {
                      code: codeRef + codeEndRef + ("if(!" + asyncOutputVar + "){" + asyncOutputVar + "=()=>Promise.resolve(" + outputVar + ")}"),
                      outputVar: asyncOutputVar,
                      isAsync: true
                    };
            }),
          isAsyncParseOperation: undefined,
          pf: (function (ctx) {
              var structs = ctx.s.t._0;
              var noopOps = [];
              var syncOps = [];
              var asyncOps = [];
              for(var idx = 0 ,idx_finish = structs.length; idx < idx_finish; ++idx){
                var innerStruct = structs[idx];
                var fn = getParseOperation(innerStruct);
                if (typeof fn !== "object") {
                  noopOps.push(undefined);
                } else if (fn.TAG === "SyncOperation") {
                  syncOps.push([
                        idx,
                        fn._0
                      ]);
                } else {
                  asyncOps.push([
                        idx,
                        fn._0
                      ]);
                }
              }
              var withAsyncOps = asyncOps.length > 0;
              if (noopOps.length === 0) {
                planSyncTransformation(ctx, (function (input) {
                        var idxRef = 0;
                        var errorsRef = [];
                        var maybeNewValueRef;
                        while(idxRef < syncOps.length && maybeNewValueRef === undefined) {
                          var idx = idxRef;
                          var match = syncOps[idx];
                          try {
                            var newValue = match[1](input);
                            maybeNewValueRef = Caml_option.some(newValue);
                          }
                          catch (raw_internalError){
                            var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                            if (internalError.RE_EXN_ID === Exception) {
                              errorsRef[match[0]] = internalError._1;
                              idxRef = idxRef + 1;
                            } else {
                              throw internalError;
                            }
                          }
                        };
                        var match$1 = maybeNewValueRef;
                        if (match$1 !== undefined) {
                          if (withAsyncOps) {
                            return {
                                    maybeSyncValue: match$1,
                                    tempErrors: errorsRef,
                                    originalInput: input
                                  };
                          } else {
                            return Caml_option.valFromOption(match$1);
                          }
                        } else if (withAsyncOps) {
                          return {
                                  maybeSyncValue: match$1,
                                  tempErrors: errorsRef,
                                  originalInput: input
                                };
                        } else {
                          return raise$1({
                                      TAG: "InvalidUnion",
                                      _0: errorsRef.map(toParseError)
                                    });
                        }
                      }));
                if (withAsyncOps) {
                  return planAsyncTransformation(ctx, (function (input) {
                                var syncValue = input.maybeSyncValue;
                                if (syncValue !== undefined) {
                                  return Promise.resolve(Caml_option.valFromOption(syncValue));
                                } else {
                                  return Promise.all(asyncOps.map(function (param) {
                                                    var originalIdx = param[0];
                                                    try {
                                                      return param[1](input.originalInput)(undefined).then((function (value) {
                                                                    throw {
                                                                          RE_EXN_ID: HackyValidValue,
                                                                          _1: value,
                                                                          Error: new Error()
                                                                        };
                                                                  }), (function (exn) {
                                                                    if (exn.RE_EXN_ID === Exception) {
                                                                      var array = input.tempErrors;
                                                                      array[originalIdx] = exn._1;
                                                                      return ;
                                                                    }
                                                                    throw exn;
                                                                  }));
                                                    }
                                                    catch (raw_internalError){
                                                      var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                                                      if (internalError.RE_EXN_ID === Exception) {
                                                        var array = input.tempErrors;
                                                        return Promise.resolve((array[originalIdx] = internalError._1, undefined));
                                                      }
                                                      throw internalError;
                                                    }
                                                  })).then((function (param) {
                                                return raise$1({
                                                            TAG: "InvalidUnion",
                                                            _0: input.tempErrors.map(toParseError)
                                                          });
                                              }), (function (exn) {
                                                if (exn.RE_EXN_ID === HackyValidValue) {
                                                  return exn._1;
                                                }
                                                throw exn;
                                              }));
                                }
                              }));
                } else {
                  return ;
                }
              }
              
            }),
          sf: (function (ctx) {
              var serializeOperations = [];
              for(var idx = 0 ,idx_finish = structs.length; idx < idx_finish; ++idx){
                serializeOperations.push(getSerializeOperation(structs[idx]));
              }
              planSyncTransformation(ctx, (function (input) {
                      var idxRef = 0;
                      var errors = [];
                      var maybeNewValueRef;
                      while(idxRef < serializeOperations.length && maybeNewValueRef === undefined) {
                        var idx = idxRef;
                        var serializeOperation = serializeOperations[idx];
                        try {
                          var newValue = serializeOperation !== undefined ? serializeOperation(input) : input;
                          maybeNewValueRef = Caml_option.some(newValue);
                        }
                        catch (raw_internalError){
                          var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                          if (internalError.RE_EXN_ID === Exception) {
                            errors.push(internalError._1);
                            idxRef = idxRef + 1;
                          } else {
                            throw internalError;
                          }
                        }
                      };
                      var ok = maybeNewValueRef;
                      if (ok !== undefined) {
                        return Caml_option.valFromOption(ok);
                      } else {
                        return raise$1({
                                    TAG: "InvalidUnion",
                                    _0: errors.map(toSerializeError)
                                  });
                      }
                    }));
            }),
          r: 0,
          e: 0,
          s: initialSerialize,
          j: initialSerializeToJson,
          p: intitialParse,
          a: intitialParseAsync,
          m: emptyMetadataMap
        };
}

function list(innerStruct) {
  return transform(factory$7(innerStruct), Belt_List.fromArray, undefined, Belt_List.toArray, undefined);
}

function parseTransformationFactory$4(ctx) {
  planSyncTransformation(ctx, (function (input) {
          return input;
        }));
}

function parse(input, path) {
  var match = typeof input;
  switch (match) {
    case "number" :
        if (!Number.isNaN(input)) {
          return input;
        }
        break;
    case "object" :
        if (input === null) {
          return input;
        }
        if (Array.isArray(input)) {
          var output = [];
          for(var idx = 0 ,idx_finish = input.length; idx < idx_finish; ++idx){
            var inputItem = input[idx];
            var $$location = idx.toString();
            output.push(parse(inputItem, path + ("[" + JSON.stringify($$location) + "]")));
          }
          return output;
        }
        var keys = Object.keys(input);
        var output$1 = {};
        for(var idx$1 = 0 ,idx_finish$1 = keys.length; idx$1 < idx_finish$1; ++idx$1){
          var key = keys[idx$1];
          var field = input[key];
          output$1[key] = parse(field, path + ("[" + JSON.stringify(key) + "]"));
        }
        return output$1;
    case "boolean" :
    case "string" :
        return input;
    default:
      
  }
  throw {
        RE_EXN_ID: Exception,
        _1: {
          c: {
            TAG: "UnexpectedType",
            expected: "JSON",
            received: toName(input)
          },
          p: path
        },
        Error: new Error()
      };
}

var json = {
  n: "JSON",
  t: "JSON",
  parseOperationFactory: (function (b, param, inputVar, pathVar) {
      return {
              code: "e[" + (b.embeded.push(parse) - 1) + "](" + inputVar + "," + pathVar + ");",
              outputVar: inputVar,
              isAsync: false
            };
    }),
  isAsyncParseOperation: undefined,
  pf: parseTransformationFactory$4,
  sf: empty,
  r: 0,
  e: 0,
  s: initialSerialize,
  j: initialSerializeToJson,
  p: intitialParse,
  a: intitialParseAsync,
  m: emptyMetadataMap
};

function $$catch(struct, getFallbackValue) {
  return {
          n: struct.n,
          t: struct.t,
          parseOperationFactory: (function (b, param, inputVar, pathVar) {
              var match = compileParser(b, struct, inputVar, pathVar);
              var structOutputVar = match.outputVar;
              var structCode = match.code;
              var fallbackValVar = "e[" + (b.embeded.push(function (input, internalError) {
                      return getFallbackValue({
                                  error: toParseError(internalError),
                                  input: input
                                });
                    }) - 1) + "](" + inputVar + ",t._1)";
              if (!match.isAsync) {
                return {
                        code: "try{" + structCode + "}catch(t){if(t&&t.RE_EXN_ID===\"S-RescriptStruct.Error.Internal.Exception/1\"){" + structOutputVar + "=" + fallbackValVar + "}else{throw t}}",
                        outputVar: structOutputVar,
                        isAsync: false
                      };
              }
              var outputVar = $$var(b);
              return {
                      code: "try{" + structCode + outputVar + "=()=>{try{return " + structOutputVar + "().catch(t=>{if(t&&t.RE_EXN_ID===\"S-RescriptStruct.Error.Internal.Exception/1\"){return " + fallbackValVar + "}else{throw t}})}catch(t){if(t&&t.RE_EXN_ID===\"S-RescriptStruct.Error.Internal.Exception/1\"){return Promise.resolve(" + fallbackValVar + ")}else{throw t}}}}catch(t){if(t&&t.RE_EXN_ID===\"S-RescriptStruct.Error.Internal.Exception/1\"){" + outputVar + "=()=>Promise.resolve(" + fallbackValVar + ")}else{throw t}}",
                      outputVar: outputVar,
                      isAsync: true
                    };
            }),
          isAsyncParseOperation: undefined,
          pf: (function (ctx) {
              var fn = getParseOperation(struct);
              if (typeof fn !== "object") {
                return ;
              }
              if (fn.TAG === "SyncOperation") {
                var fn$1 = fn._0;
                return planSyncTransformation(ctx, (function (input) {
                              try {
                                return fn$1(input);
                              }
                              catch (raw_e){
                                var e = Caml_js_exceptions.internalToOCamlException(raw_e);
                                if (e.RE_EXN_ID === Exception) {
                                  return getFallbackValue({
                                              error: toParseError(e._1),
                                              input: input
                                            });
                                }
                                throw e;
                              }
                            }));
              }
              var fn$2 = fn._0;
              planSyncTransformation(ctx, (function (input) {
                      try {
                        return {
                                TAG: "Parsed",
                                input: input,
                                asyncFn: fn$2(input)
                              };
                      }
                      catch (raw_e){
                        var e = Caml_js_exceptions.internalToOCamlException(raw_e);
                        if (e.RE_EXN_ID === Exception) {
                          return {
                                  TAG: "Fallback",
                                  _0: getFallbackValue({
                                        error: toParseError(e._1),
                                        input: input
                                      })
                                };
                        }
                        throw e;
                      }
                    }));
              planAsyncTransformation(ctx, (function (syncResult) {
                      if (syncResult.TAG !== "Parsed") {
                        return Promise.resolve(syncResult._0);
                      }
                      var input = syncResult.input;
                      try {
                        return syncResult.asyncFn(undefined).catch(function (exn) {
                                    if (exn.RE_EXN_ID === Exception) {
                                      return getFallbackValue({
                                                  error: toParseError(exn._1),
                                                  input: input
                                                });
                                    }
                                    throw exn;
                                  });
                      }
                      catch (raw_e){
                        var e = Caml_js_exceptions.internalToOCamlException(raw_e);
                        if (e.RE_EXN_ID === Exception) {
                          return Promise.resolve(getFallbackValue({
                                          error: toParseError(e._1),
                                          input: input
                                        }));
                        }
                        throw e;
                      }
                    }));
            }),
          sf: struct.sf,
          r: 0,
          e: 0,
          s: initialSerialize,
          j: initialSerializeToJson,
          p: intitialParse,
          a: intitialParseAsync,
          m: struct.m
        };
}

var deprecationMetadataId = "rescript-struct:deprecation";

function deprecate(struct, message) {
  return set(struct, deprecationMetadataId, message);
}

function deprecation(struct) {
  return Js_dict.get(struct.m, deprecationMetadataId);
}

var descriptionMetadataId = "rescript-struct:description";

function describe(struct, description) {
  return set(struct, descriptionMetadataId, description);
}

function description(struct) {
  return Js_dict.get(struct.m, descriptionMetadataId);
}

function getExn(result) {
  if (result.TAG === "Ok") {
    return result._0;
  }
  var message = toString(result._0);
  throw new Error("[rescript-struct] " + message);
}

function mapErrorToString(result) {
  if (result.TAG === "Ok") {
    return result;
  } else {
    return {
            TAG: "Error",
            _0: toString(result._0)
          };
  }
}

var Result = {
  getExn: getExn,
  mapErrorToString: mapErrorToString
};

function toVariantName(struct) {
  var s = struct.t;
  if (typeof s !== "object") {
    switch (s) {
      case "Never" :
          return "Never";
      case "Unknown" :
          return "Unknown";
      case "String" :
          return "String";
      case "Int" :
          return "Int";
      case "Float" :
          return "Float";
      case "Bool" :
          return "Bool";
      case "JSON" :
          return "JSON";
      
    }
  } else {
    switch (s.TAG) {
      case "Literal" :
          var string = s._0;
          if (typeof string !== "object") {
            switch (string) {
              case "EmptyNull" :
                  return "EmptyNull";
              case "EmptyOption" :
                  return "EmptyOption";
              case "NaN" :
                  return "NaN";
              
            }
          } else {
            switch (string.TAG) {
              case "String" :
                  return string._0;
              case "Int" :
              case "Float" :
                  return string._0.toString();
              case "Bool" :
                  if (string._0) {
                    return "True";
                  } else {
                    return "False";
                  }
              
            }
          }
      case "Option" :
          return "OptionOf" + toVariantName(s._0);
      case "Null" :
          return "NullOf" + toVariantName(s._0);
      case "Array" :
          return "ArrayOf" + toVariantName(s._0);
      case "Object" :
          if (s.fieldNames.length !== 0) {
            return "Object";
          } else {
            return "EmptyObject";
          }
      case "Tuple" :
          if (s._0.length !== 0) {
            return "Tuple";
          } else {
            return "EmptyTuple";
          }
      case "Union" :
          return "Union";
      case "Dict" :
          return "DictOf" + toVariantName(s._0);
      
    }
  }
}

function internalInline(struct, maybeVariant, param) {
  var metadataMap = Object.assign({}, struct.m);
  var taggedLiteral = struct.t;
  var inlinedStruct;
  if (typeof taggedLiteral !== "object") {
    switch (taggedLiteral) {
      case "Never" :
          inlinedStruct = "S.never";
          break;
      case "Unknown" :
          inlinedStruct = "S.unknown";
          break;
      case "String" :
          inlinedStruct = "S.string";
          break;
      case "Int" :
          inlinedStruct = "S.int";
          break;
      case "Float" :
          inlinedStruct = "S.float";
          break;
      case "Bool" :
          inlinedStruct = "S.bool";
          break;
      case "JSON" :
          inlinedStruct = "S.json";
          break;
      
    }
  } else {
    switch (taggedLiteral.TAG) {
      case "Literal" :
          var taggedLiteral$1 = taggedLiteral._0;
          var inlinedLiteral;
          if (typeof taggedLiteral$1 !== "object") {
            switch (taggedLiteral$1) {
              case "EmptyNull" :
                  inlinedLiteral = "EmptyNull";
                  break;
              case "EmptyOption" :
                  inlinedLiteral = "EmptyOption";
                  break;
              case "NaN" :
                  inlinedLiteral = "NaN";
                  break;
              
            }
          } else {
            switch (taggedLiteral$1.TAG) {
              case "String" :
                  inlinedLiteral = "String(" + JSON.stringify(taggedLiteral$1._0) + ")";
                  break;
              case "Int" :
                  inlinedLiteral = "Int(" + taggedLiteral$1._0.toString() + ")";
                  break;
              case "Float" :
                  var $$float = taggedLiteral$1._0;
                  inlinedLiteral = "Float(" + ($$float.toString() + (
                      $$float % 1 === 0 ? "." : ""
                    )) + ")";
                  break;
              case "Bool" :
                  inlinedLiteral = "Bool(" + taggedLiteral$1._0.toString() + ")";
                  break;
              
            }
          }
          inlinedStruct = maybeVariant !== undefined ? "S.literalVariant(" + inlinedLiteral + ", " + maybeVariant + ")" : "S.literal(" + inlinedLiteral + ")";
          break;
      case "Option" :
          var internalInlinedStruct = internalInline(taggedLiteral._0, undefined, undefined);
          var defaultValue = classify$2(struct);
          if (defaultValue !== undefined) {
            var defaultValue$1 = Caml_option.valFromOption(defaultValue);
            Js_dict.unsafeDeleteKey(metadataMap, metadataId$5);
            inlinedStruct = internalInlinedStruct + ("->S.default(() => %raw(\`" + (
                defaultValue$1 === undefined ? "undefined" : JSON.stringify(defaultValue$1)
              ) + "\`))");
          } else {
            inlinedStruct = "S.option(" + internalInlinedStruct + ")";
          }
          break;
      case "Null" :
          inlinedStruct = "S.null(" + internalInline(taggedLiteral._0, undefined, undefined) + ")";
          break;
      case "Array" :
          inlinedStruct = "S.array(" + internalInline(taggedLiteral._0, undefined, undefined) + ")";
          break;
      case "Object" :
          var fieldNames = taggedLiteral.fieldNames;
          var fields = taggedLiteral.fields;
          inlinedStruct = fieldNames.length !== 0 ? "S.object(o =>\n  {\n    " + fieldNames.map(function (fieldName) {
                    return JSON.stringify(fieldName) + ": o.field(" + JSON.stringify(fieldName) + ", " + internalInline(fields[fieldName], undefined, undefined) + ")";
                  }).join(",\n    ") + ",\n  }\n)" : "S.object(_ => ())";
          break;
      case "Tuple" :
          var tupleStructs = taggedLiteral._0;
          if (tupleStructs.length !== 0) {
            var numberOfItems = tupleStructs.length;
            if (numberOfItems > 10) {
              throw new Error("[rescript-struct] The S.inline doesn't support tuples with more than 10 items.");
            }
            inlinedStruct = "S.tuple" + numberOfItems.toString() + "(. " + tupleStructs.map(function (s) {
                    return internalInline(s, undefined, undefined);
                  }).join(", ") + ")";
          } else {
            inlinedStruct = "S.tuple0(.)";
          }
          break;
      case "Union" :
          var variantNamesCounter = {};
          inlinedStruct = "S.union([" + taggedLiteral._0.map(function (s) {
                  var variantName = toVariantName(s);
                  var n = Js_dict.get(variantNamesCounter, variantName);
                  var numberOfVariantNames = n !== undefined ? n : 0;
                  variantNamesCounter[variantName] = numberOfVariantNames + 1;
                  var variantName$1 = numberOfVariantNames !== 0 ? variantName + (numberOfVariantNames + 1).toString() : variantName;
                  var inlinedVariant = "#" + JSON.stringify(variantName$1);
                  return internalInline(s, inlinedVariant, undefined);
                }).join(", ") + "])";
          break;
      case "Dict" :
          inlinedStruct = "S.dict(" + internalInline(taggedLiteral._0, undefined, undefined) + ")";
          break;
      
    }
  }
  var message = deprecation(struct);
  var inlinedStruct$1 = message !== undefined ? (Js_dict.unsafeDeleteKey(metadataMap, deprecationMetadataId), inlinedStruct + ("->S.deprecate(" + JSON.stringify(message) + ")")) : inlinedStruct;
  var message$1 = description(struct);
  var inlinedStruct$2 = message$1 !== undefined ? (Js_dict.unsafeDeleteKey(metadataMap, descriptionMetadataId), inlinedStruct$1 + ("->S.describe(" + (
          message$1 === undefined ? "undefined" : JSON.stringify(message$1)
        ) + ")")) : inlinedStruct$1;
  var match = classify$1(struct);
  var inlinedStruct$3;
  inlinedStruct$3 = match === "Strict" ? inlinedStruct$2 + "->S.Object.strict" : inlinedStruct$2;
  Js_dict.unsafeDeleteKey(metadataMap, metadataId);
  var match$1 = struct.t;
  var inlinedStruct$4;
  var exit = 0;
  if (typeof match$1 !== "object") {
    switch (match$1) {
      case "String" :
          exit = 1;
          break;
      case "Int" :
          exit = 2;
          break;
      case "Float" :
          exit = 3;
          break;
      default:
        inlinedStruct$4 = inlinedStruct$3;
    }
  } else {
    switch (match$1.TAG) {
      case "Literal" :
          var tmp = match$1._0;
          if (typeof tmp !== "object") {
            inlinedStruct$4 = inlinedStruct$3;
          } else {
            switch (tmp.TAG) {
              case "String" :
                  exit = 1;
                  break;
              case "Int" :
                  exit = 2;
                  break;
              case "Float" :
                  exit = 3;
                  break;
              default:
                inlinedStruct$4 = inlinedStruct$3;
            }
          }
          break;
      case "Array" :
          var refinements$4 = refinements$3(struct);
          if (refinements$4.length !== 0) {
            Js_dict.unsafeDeleteKey(metadataMap, metadataId$4);
            inlinedStruct$4 = inlinedStruct$3 + refinements$4.map(function (refinement) {
                    var match = refinement.kind;
                    switch (match.TAG) {
                      case "Min" :
                          return "->S.Array.min(~message=" + JSON.stringify(refinement.message) + ", " + match.length.toString() + ")";
                      case "Max" :
                          return "->S.Array.max(~message=" + JSON.stringify(refinement.message) + ", " + match.length.toString() + ")";
                      case "Length" :
                          return "->S.Array.length(~message=" + JSON.stringify(refinement.message) + ", " + match.length.toString() + ")";
                      
                    }
                  }).join("");
          } else {
            inlinedStruct$4 = inlinedStruct$3;
          }
          break;
      default:
        inlinedStruct$4 = inlinedStruct$3;
    }
  }
  switch (exit) {
    case 1 :
        var refinements$5 = refinements(struct);
        if (refinements$5.length !== 0) {
          Js_dict.unsafeDeleteKey(metadataMap, metadataId$1);
          inlinedStruct$4 = inlinedStruct$3 + refinements$5.map(function (refinement) {
                  var match = refinement.kind;
                  if (typeof match !== "object") {
                    switch (match) {
                      case "Email" :
                          return "->S.String.email(~message=" + JSON.stringify(refinement.message) + ", ())";
                      case "Uuid" :
                          return "->S.String.uuid(~message=" + JSON.stringify(refinement.message) + ", ())";
                      case "Cuid" :
                          return "->S.String.cuid(~message=" + JSON.stringify(refinement.message) + ", ())";
                      case "Url" :
                          return "->S.String.url(~message=" + JSON.stringify(refinement.message) + ", ())";
                      case "Datetime" :
                          return "->S.String.datetime(~message=" + JSON.stringify(refinement.message) + ", ())";
                      
                    }
                  } else {
                    switch (match.TAG) {
                      case "Min" :
                          return "->S.String.min(~message=" + JSON.stringify(refinement.message) + ", " + match.length.toString() + ")";
                      case "Max" :
                          return "->S.String.max(~message=" + JSON.stringify(refinement.message) + ", " + match.length.toString() + ")";
                      case "Length" :
                          return "->S.String.length(~message=" + JSON.stringify(refinement.message) + ", " + match.length.toString() + ")";
                      case "Pattern" :
                          return "->S.String.pattern(~message=" + JSON.stringify(refinement.message) + ", %re(" + JSON.stringify(match.re.toString()) + "))";
                      
                    }
                  }
                }).join("");
        } else {
          inlinedStruct$4 = inlinedStruct$3;
        }
        break;
    case 2 :
        var refinements$6 = refinements$1(struct);
        if (refinements$6.length !== 0) {
          Js_dict.unsafeDeleteKey(metadataMap, metadataId$2);
          inlinedStruct$4 = inlinedStruct$3 + refinements$6.map(function (refinement) {
                  var match = refinement.kind;
                  if (typeof match !== "object") {
                    return "->S.Int.port(~message=" + JSON.stringify(refinement.message) + ", ())";
                  } else if (match.TAG === "Min") {
                    return "->S.Int.min(~message=" + JSON.stringify(refinement.message) + ", " + match.value.toString() + ")";
                  } else {
                    return "->S.Int.max(~message=" + JSON.stringify(refinement.message) + ", " + match.value.toString() + ")";
                  }
                }).join("");
        } else {
          inlinedStruct$4 = inlinedStruct$3;
        }
        break;
    case 3 :
        var refinements$7 = refinements$2(struct);
        if (refinements$7.length !== 0) {
          Js_dict.unsafeDeleteKey(metadataMap, metadataId$3);
          inlinedStruct$4 = inlinedStruct$3 + refinements$7.map(function (refinement) {
                  var match = refinement.kind;
                  if (match.TAG === "Min") {
                    var value = match.value;
                    return "->S.Float.min(~message=" + JSON.stringify(refinement.message) + ", " + (value.toString() + (
                              value % 1 === 0 ? "." : ""
                            )) + ")";
                  }
                  var value$1 = match.value;
                  return "->S.Float.max(~message=" + JSON.stringify(refinement.message) + ", " + (value$1.toString() + (
                            value$1 % 1 === 0 ? "." : ""
                          )) + ")";
                }).join("");
        } else {
          inlinedStruct$4 = inlinedStruct$3;
        }
        break;
    
  }
  var inlinedStruct$5 = Object.keys(metadataMap).length !== 0 ? "{\n  let s = " + inlinedStruct$4 + "\n  let _ = %raw(\`s.m = " + JSON.stringify(metadataMap) + "\`)\n  s\n}" : inlinedStruct$4;
  var match$2 = struct.t;
  if (typeof match$2 === "object" && match$2.TAG === "Literal") {
    return inlinedStruct$5;
  }
  if (maybeVariant !== undefined) {
    return inlinedStruct$5 + ("->S.variant(v => " + maybeVariant + "(v))");
  } else {
    return inlinedStruct$5;
  }
}

function inline(struct) {
  return internalInline(struct, undefined, undefined);
}

var unit = factory$1("EmptyOption", undefined);

function tuple0() {
  return factory$10([]);
}

function tuple1(v0) {
  return factory$10([v0]);
}

function tuple2(v0, v1) {
  return factory$10([
              v0,
              v1
            ]);
}

function tuple3(v0, v1, v2) {
  return factory$10([
              v0,
              v1,
              v2
            ]);
}

var Path = {
  empty: "",
  toArray: toArray,
  fromArray: fromArray,
  fromLocation: fromLocation,
  concat: concat
};

var $$Error$1 = {
  toString: toString
};

var never = struct;

var unknown = struct$1;

var string = struct$2;

var bool = struct$3;

var $$int = struct$4;

var $$float = struct$5;

var literal = factory$2;

var literalVariant = factory$1;

var array = factory$7;

var dict = factory$8;

var option = factory$6;

var $$null = factory$5;

var jsonString = factory$4;

var union = factory$11;

var $$default = factory$9;

var variant = factory;

var parseWith = parseAnyWith;

var parseOrRaiseWith = parseAnyOrRaiseWith;

var parseAsyncWith = parseAnyAsyncWith;

var parseAsyncInStepsWith = parseAnyAsyncInStepsWith;

var Object_UnknownKeys = {
  classify: classify$1
};

var $$Object = {
  UnknownKeys: Object_UnknownKeys,
  factory: factory$3,
  strip: strip,
  strict: strict
};

var object = factory$3;

var tuple4 = factoryFromArgs;

var tuple5 = factoryFromArgs;

var tuple6 = factoryFromArgs;

var tuple7 = factoryFromArgs;

var tuple8 = factoryFromArgs;

var tuple9 = factoryFromArgs;

var tuple10 = factoryFromArgs;

var String_Refinement = {};

var $$String = {
  Refinement: String_Refinement,
  refinements: refinements,
  min: min,
  max: max,
  length: length,
  email: email,
  uuid: uuid,
  cuid: cuid,
  url: url,
  pattern: pattern,
  datetime: datetime,
  trim: trim
};

var Int_Refinement = {};

var Int = {
  Refinement: Int_Refinement,
  refinements: refinements$1,
  min: min$1,
  max: max$1,
  port: port
};

var Float_Refinement = {};

var Float = {
  Refinement: Float_Refinement,
  refinements: refinements$2,
  min: min$2,
  max: max$2
};

var Array_Refinement = {};

var $$Array = {
  Refinement: Array_Refinement,
  refinements: refinements$3,
  min: min$3,
  max: max$3,
  length: length$1
};

var Default = {
  classify: classify$2
};

export {
  Path ,
  $$Error$1 as $$Error,
  Raised ,
  never ,
  unknown ,
  unit ,
  string ,
  bool ,
  $$int ,
  $$float ,
  json ,
  literal ,
  literalVariant ,
  array ,
  list ,
  dict ,
  option ,
  $$null ,
  jsonString ,
  union ,
  $$default ,
  $$default as default,
  $$catch ,
  describe ,
  description ,
  deprecate ,
  deprecation ,
  transform ,
  advancedTransform ,
  advancedPreprocess ,
  custom ,
  refine ,
  variant ,
  parseWith ,
  parseAnyWith ,
  parseJsonStringWith ,
  parseOrRaiseWith ,
  parseAnyOrRaiseWith ,
  parseAsyncWith ,
  parseAnyAsyncWith ,
  parseAsyncInStepsWith ,
  parseAnyAsyncInStepsWith ,
  serializeWith ,
  serializeToUnknownWith ,
  serializeToJsonStringWith ,
  serializeOrRaiseWith ,
  serializeToUnknownOrRaiseWith ,
  isAsyncParse ,
  recursive ,
  classify ,
  name ,
  fail ,
  advancedFail ,
  $$Object ,
  object ,
  Tuple ,
  tuple0 ,
  tuple1 ,
  tuple2 ,
  tuple3 ,
  tuple4 ,
  tuple5 ,
  tuple6 ,
  tuple7 ,
  tuple8 ,
  tuple9 ,
  tuple10 ,
  $$String ,
  Int ,
  Float ,
  $$Array ,
  Default ,
  Result ,
  Metadata ,
  inline ,
}
/* unit Not a pure module */
