// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

var mapValues = ((dict, fn)=>{
      var key,newDict = {};
      for (key in dict) {
        newDict[key] = fn(dict[key])
      }
      return newDict
    });

function fromString(string) {
  return JSON.stringify(string);
}

function classify(value) {
  var typeOfValue = typeof value;
  if (typeOfValue === "symbol") {
    return {
            TAG: "Symbol",
            _0: value
          };
  } else if (typeOfValue === "boolean") {
    return {
            TAG: "Boolean",
            _0: value
          };
  } else if (typeOfValue === "string") {
    return {
            TAG: "String",
            _0: value
          };
  } else if (typeOfValue === "function") {
    return {
            TAG: "Function",
            _0: value
          };
  } else if (typeOfValue === "object") {
    if (value === null) {
      return "Null";
    } else if (Array.isArray(value)) {
      return {
              TAG: "Array",
              _0: value.map(function (i) {
                    return classify(i);
                  })
            };
    } else if (value.constructor === Object) {
      return {
              TAG: "Dict",
              _0: mapValues(value, classify)
            };
    } else {
      return {
              TAG: "Object",
              _0: value
            };
    }
  } else if (typeOfValue === "undefined") {
    return "Undefined";
  } else if (typeOfValue === "number") {
    if (Number.isNaN(value)) {
      return "NaN";
    } else {
      return {
              TAG: "Number",
              _0: value
            };
    }
  } else {
    return {
            TAG: "BigInt",
            _0: value
          };
  }
}

function value(literal) {
  if (typeof literal !== "object") {
    switch (literal) {
      case "Null" :
          return null;
      case "Undefined" :
          return undefined;
      case "NaN" :
          return NaN;
      
    }
  } else {
    switch (literal.TAG) {
      case "Array" :
          return literal._0.map(value);
      case "Dict" :
          return mapValues(literal._0, value);
      default:
        return literal._0;
    }
  }
}

function toText(literal) {
  if (typeof literal !== "object") {
    switch (literal) {
      case "Null" :
          return "null";
      case "Undefined" :
          return "undefined";
      case "NaN" :
          return "NaN";
      
    }
  } else {
    switch (literal.TAG) {
      case "String" :
          return JSON.stringify(literal._0);
      case "Number" :
      case "Boolean" :
          return literal._0;
      case "BigInt" :
          return literal._0 + "n";
      case "Symbol" :
          return literal._0.toString();
      case "Array" :
          return "[" + literal._0.map(toText).join(", ") + "]";
      case "Dict" :
          var v = literal._0;
          return "{" + Object.keys(v).map(function (key) {
                        return JSON.stringify(key) + ": " + toText(v[key]);
                      }).join(", ") + "}";
      case "Function" :
          return "[object Function]";
      case "Object" :
          return Object.prototype.toString.call(literal._0);
      
    }
  }
}

function toArray(path) {
  if (path === "") {
    return [];
  } else {
    return JSON.parse(path.split("\"][\"").join("\",\""));
  }
}

function fromLocation($$location) {
  return "[" + JSON.stringify($$location) + "]";
}

function fromArray(array) {
  var len = array.length;
  if (len !== 1) {
    if (len !== 0) {
      return "[" + array.map(fromString).join("][") + "]";
    } else {
      return "";
    }
  }
  var $$location = array[0];
  return "[" + JSON.stringify($$location) + "]";
}

function concat(path, concatedPath) {
  return path + concatedPath;
}

var symbol = Symbol("rescript-struct");

function toParseError(internalError) {
  return {
          operation: "Parsing",
          code: internalError.c,
          path: internalError.p
        };
}

function toSerializeError(internalError) {
  return {
          operation: "Serializing",
          code: internalError.c,
          path: internalError.p
        };
}

function getOrRethrow(jsExn) {
  if ((jsExn&&jsExn.s===symbol)) {
    return jsExn;
  }
  throw jsExn;
}

function prependLocationOrRethrow(jsExn, $$location) {
  var error = getOrRethrow(jsExn);
  var path = "[" + JSON.stringify($$location) + "]" + error.p;
  throw {
        c: error.c,
        p: path,
        s: symbol
      };
}

function panic($$location) {
  throw new Error("[rescript-struct] " + ("For a " + $$location + " either a parser, or a serializer is required"));
}

function classify$1(struct) {
  return struct.t;
}

var emptyMetadataMap = {};

function noop(_b, param, inputVar, outputVar, param$1) {
  return outputVar + "=" + inputVar + ";";
}

function varsScope(b, fn) {
  var prevVarsAllocation = b.v;
  b.v = "";
  var code = fn(b);
  var varsAllocation = b.v;
  var code$1 = varsAllocation === "" ? code : "let " + varsAllocation + ";" + code;
  b.v = prevVarsAllocation;
  return code$1;
}

function $$var(b) {
  var newCounter = b.c + 1;
  b.c = newCounter;
  var v = "v" + newCounter;
  var varsAllocation = b.v;
  b.v = varsAllocation === "" ? v : varsAllocation + "," + v;
  return v;
}

function varWithoutAllocation(b) {
  var newCounter = b.c + 1;
  b.c = newCounter;
  return "v" + newCounter;
}

function internalTransformRethrow(b, pathVar) {
  return "if(t&&t.s===s){t.p=" + pathVar + "+t.p}throw t";
}

function embedSyncOperation(b, inputVar, outputVar, pathVar, fn, isSafeOpt, isRefineOpt, param) {
  var isSafe = isSafeOpt !== undefined ? isSafeOpt : false;
  var isRefine = isRefineOpt !== undefined ? isRefineOpt : false;
  var tmp;
  if (b.a.has(inputVar)) {
    b.a.add(outputVar);
    var code = outputVar + "=()=>" + inputVar + "().then(" + (
      isRefine ? "t=>{" + ("e[" + (b.e.push(fn) - 1) + "]") + "(t);return " + inputVar + "}" : "e[" + (b.e.push(fn) - 1) + "]"
    ) + ")";
    tmp = isSafe || pathVar === "\"\"" ? code : code + ".catch(t=>{" + internalTransformRethrow(b, pathVar) + "})";
  } else {
    var code$1 = isRefine ? "e[" + (b.e.push(fn) - 1) + "](" + inputVar + ");" + outputVar + "=" + inputVar + ";" : outputVar + "=" + ("e[" + (b.e.push(fn) - 1) + "]") + "(" + inputVar + ")";
    tmp = isSafe || pathVar === "\"\"" ? code$1 : "try{" + code$1 + "}catch(t){" + internalTransformRethrow(b, pathVar) + "}";
  }
  return tmp + ";";
}

function embedAsyncOperation(b, inputVar, outputVar, pathVar, fn, isRefineOpt, param) {
  var isRefine = isRefineOpt !== undefined ? isRefineOpt : false;
  var asyncVars = b.a;
  var isAsyncInput = asyncVars.has(inputVar);
  asyncVars.add(outputVar);
  if (isAsyncInput) {
    var code = outputVar + "=()=>" + inputVar + "().then(t=>" + ("e[" + (b.e.push(fn) - 1) + "]") + "(t)()" + (
      isRefine ? ".then(_=>t)" : ""
    ) + ")";
    var tmp = pathVar === "\"\"" ? code : code + ".catch(t=>{" + internalTransformRethrow(b, pathVar) + "})";
    return tmp + ";";
  }
  if (pathVar === "\"\"") {
    var code$1 = "e[" + (b.e.push(fn) - 1) + "](" + inputVar + ")";
    if (!isRefine) {
      return outputVar + "=" + code$1 + ";";
    }
    var syncResultVar = $$var(b);
    return syncResultVar + "=" + code$1 + ";" + outputVar + "=()=>" + syncResultVar + "().then(_=>" + inputVar + ");";
  }
  var syncResultVar$1 = $$var(b);
  var code$2 = syncResultVar$1 + "=" + ("e[" + (b.e.push(fn) - 1) + "]") + "(" + inputVar + ");";
  return "try{" + code$2 + outputVar + "=()=>{try{return " + syncResultVar$1 + "()" + (
          isRefine ? ".then(_=>" + inputVar + ")" : ""
        ) + ".catch(t=>{" + internalTransformRethrow(b, pathVar) + "})}catch(t){" + internalTransformRethrow(b, pathVar) + "}}}catch(t){" + internalTransformRethrow(b, pathVar) + "};";
}

function raiseWithArg(b, pathVar, fn, arg) {
  return "e[" + (b.e.push(function (path, arg) {
                var code = fn(arg);
                throw {
                      c: code,
                      p: path,
                      s: symbol
                    };
              }) - 1) + "](" + pathVar + "," + arg + ")";
}

function raise(b, pathVar, code) {
  return "e[" + (b.e.push(function (path) {
                throw {
                      c: code,
                      p: path,
                      s: symbol
                    };
              }) - 1) + "](" + pathVar + ")";
}

function run(b, builder, struct, inputVar, outputVar, pathVar) {
  var asyncVarsCountBefore = b.a.size;
  var code = builder(b, struct, inputVar, outputVar, pathVar);
  var isAsync = b.a.size > asyncVarsCountBefore;
  if (isAsync) {
    b.a.add(outputVar);
  }
  if (struct.pb === builder) {
    struct.i = isAsync;
  }
  return code;
}

function build(builder, struct) {
  var intitialInputVar = "i";
  var intitialOutputVar = "o";
  var b = {
    c: -1,
    v: intitialOutputVar,
    a: new Set(),
    e: []
  };
  var code = run(b, builder, struct, intitialInputVar, intitialOutputVar, "\"\"");
  var inlinedFunction = intitialInputVar + "=>{var " + b.v + ";" + code + "return " + intitialOutputVar + "}";
  console.log(inlinedFunction);
  return new Function("e", "s", "return " + inlinedFunction)(b.e, symbol);
}

function compileParser(struct, builder) {
  var operation = build(builder, struct);
  var isAsync = struct.i;
  struct.p = isAsync ? (function (param) {
        throw {
              c: "UnexpectedAsync",
              p: "",
              s: symbol
            };
      }) : operation;
  struct.a = isAsync ? operation : (function (input) {
        var syncValue = operation(input);
        return function () {
          return Promise.resolve(syncValue);
        };
      });
}

function compileSerializer(struct, builder) {
  var operation = build(builder, struct);
  struct.s = operation;
}

function loop(_struct) {
  while(true) {
    var struct = _struct;
    var literal = struct.t;
    if (typeof literal !== "object") {
      throw symbol;
    }
    switch (literal.TAG) {
      case "Literal" :
          return literal._0;
      case "Object" :
          return {
                  TAG: "Dict",
                  _0: mapValues(literal.fields, loop)
                };
      case "Tuple" :
          return {
                  TAG: "Array",
                  _0: literal._0.map(function (a) {
                        return loop(a);
                      })
                };
      case "Union" :
          _struct = literal._0[0];
          continue ;
      default:
        throw symbol;
    }
  };
}

function toLiteral(struct) {
  try {
    return loop(struct);
  }
  catch (raw_jsExn){
    var jsExn = Caml_js_exceptions.internalToOCamlException(raw_jsExn);
    if (jsExn.RE_EXN_ID === Js_exn.$$Error) {
      var jsExn$1 = jsExn._1;
      if (jsExn$1 === symbol) {
        return ;
      }
      throw jsExn$1;
    }
    throw jsExn;
  }
}

function isAsyncParse(struct) {
  var v = struct.i;
  if (v !== 0) {
    return v;
  }
  compileParser(struct, struct.pb);
  return struct.i;
}

function initialSerialize(input) {
  var struct = this;
  compileSerializer(struct, struct.sb);
  return struct.s(input);
}

function validateJsonableStruct(_struct, rootStruct, _isRootOpt, _param) {
  while(true) {
    var isRootOpt = _isRootOpt;
    var struct = _struct;
    var isRoot = isRootOpt !== undefined ? isRootOpt : false;
    if (!(isRoot || rootStruct !== struct)) {
      return ;
    }
    var childrenStructs = struct.t;
    var exit = 0;
    if (typeof childrenStructs !== "object") {
      if (childrenStructs !== "Unknown") {
        return ;
      }
      exit = 2;
    } else {
      switch (childrenStructs.TAG) {
        case "Literal" :
            var tmp = childrenStructs._0;
            if (typeof tmp !== "object") {
              if (tmp === "Null") {
                return ;
              }
              exit = 2;
            } else {
              switch (tmp.TAG) {
                case "String" :
                case "Number" :
                case "Boolean" :
                    return ;
                default:
                  exit = 2;
              }
            }
            break;
        case "Option" :
            exit = 2;
            break;
        case "Object" :
            var fieldNames = childrenStructs.fieldNames;
            var fields = childrenStructs.fields;
            for(var idx = 0 ,idx_finish = fieldNames.length; idx < idx_finish; ++idx){
              var fieldName = fieldNames[idx];
              var fieldStruct = fields[fieldName];
              try {
                var s = fieldStruct.t;
                var tmp$1;
                tmp$1 = typeof s !== "object" || s.TAG !== "Option" ? fieldStruct : s._0;
                validateJsonableStruct(tmp$1, rootStruct, undefined, undefined);
              }
              catch (raw_jsExn){
                var jsExn = Caml_js_exceptions.internalToOCamlException(raw_jsExn);
                if (jsExn.RE_EXN_ID === Js_exn.$$Error) {
                  prependLocationOrRethrow(jsExn._1, fieldName);
                } else {
                  throw jsExn;
                }
              }
            }
            return ;
        case "Tuple" :
            childrenStructs._0.forEach(function (childStruct, i) {
                  try {
                    return validateJsonableStruct(childStruct, rootStruct, undefined, undefined);
                  }
                  catch (raw_jsExn){
                    var jsExn = Caml_js_exceptions.internalToOCamlException(raw_jsExn);
                    if (jsExn.RE_EXN_ID === Js_exn.$$Error) {
                      return prependLocationOrRethrow(jsExn._1, i.toString());
                    }
                    throw jsExn;
                  }
                });
            return ;
        case "Union" :
            childrenStructs._0.forEach(function (childStruct) {
                  validateJsonableStruct(childStruct, rootStruct, undefined, undefined);
                });
            return ;
        case "Null" :
        case "Array" :
        case "Dict" :
            exit = 1;
            break;
        
      }
    }
    switch (exit) {
      case 1 :
          _param = undefined;
          _isRootOpt = undefined;
          _struct = childrenStructs._0;
          continue ;
      case 2 :
          throw {
                c: {
                  TAG: "InvalidJsonStruct",
                  _0: struct
                },
                p: "",
                s: symbol
              };
      
    }
  };
}

function initialSerializeToJson(input) {
  var struct = this;
  try {
    validateJsonableStruct(struct, struct, true, undefined);
    if (struct.s === initialSerialize) {
      compileSerializer(struct, struct.sb);
    }
    struct.j = struct.s;
  }
  catch (raw_jsExn){
    var jsExn = Caml_js_exceptions.internalToOCamlException(raw_jsExn);
    if (jsExn.RE_EXN_ID === Js_exn.$$Error) {
      var error = getOrRethrow(jsExn._1);
      struct.j = (function (param) {
          throw error;
        });
    } else {
      throw jsExn;
    }
  }
  return struct.j(input);
}

function intitialParse(input) {
  var struct = this;
  compileParser(struct, struct.pb);
  return struct.p(input);
}

function intitialParseAsync(input) {
  var struct = this;
  compileParser(struct, struct.pb);
  return struct.a(input);
}

function advancedFail(error) {
  throw {
        c: error.code,
        p: error.path,
        s: symbol
      };
}

function fail(pathOpt, message) {
  var path = pathOpt !== undefined ? pathOpt : "";
  throw {
        c: {
          TAG: "OperationFailed",
          _0: message
        },
        p: path,
        s: symbol
      };
}

var Raised = /* @__PURE__ */Caml_exceptions.create("S-RescriptStruct.Raised");

function parseAnyWith(any, struct) {
  try {
    return {
            TAG: "Ok",
            _0: struct.p(any)
          };
  }
  catch (raw_jsExn){
    var jsExn = Caml_js_exceptions.internalToOCamlException(raw_jsExn);
    if (jsExn.RE_EXN_ID === Js_exn.$$Error) {
      return {
              TAG: "Error",
              _0: toParseError(getOrRethrow(jsExn._1))
            };
    }
    throw jsExn;
  }
}

function parseAnyOrRaiseWith(any, struct) {
  try {
    return struct.p(any);
  }
  catch (raw_jsExn){
    var jsExn = Caml_js_exceptions.internalToOCamlException(raw_jsExn);
    if (jsExn.RE_EXN_ID === Js_exn.$$Error) {
      throw {
            RE_EXN_ID: Raised,
            _1: toParseError(getOrRethrow(jsExn._1)),
            Error: new Error()
          };
    }
    throw jsExn;
  }
}

function asyncPrepareOk(value) {
  return {
          TAG: "Ok",
          _0: value
        };
}

function asyncPrepareError(jsExn) {
  return {
          TAG: "Error",
          _0: toParseError(getOrRethrow(jsExn))
        };
}

function parseAnyAsyncWith(any, struct) {
  try {
    return struct.a(any)(undefined).then(asyncPrepareOk, asyncPrepareError);
  }
  catch (raw_jsExn){
    var jsExn = Caml_js_exceptions.internalToOCamlException(raw_jsExn);
    if (jsExn.RE_EXN_ID === Js_exn.$$Error) {
      return Promise.resolve({
                  TAG: "Error",
                  _0: toParseError(getOrRethrow(jsExn._1))
                });
    }
    throw jsExn;
  }
}

function parseAnyAsyncInStepsWith(any, struct) {
  try {
    var asyncFn = struct.a(any);
    return {
            TAG: "Ok",
            _0: (function () {
                return asyncFn(undefined).then(asyncPrepareOk, asyncPrepareError);
              })
          };
  }
  catch (raw_jsExn){
    var jsExn = Caml_js_exceptions.internalToOCamlException(raw_jsExn);
    if (jsExn.RE_EXN_ID === Js_exn.$$Error) {
      return {
              TAG: "Error",
              _0: toParseError(getOrRethrow(jsExn._1))
            };
    }
    throw jsExn;
  }
}

function serializeToUnknownWith(value, struct) {
  try {
    return {
            TAG: "Ok",
            _0: struct.s(value)
          };
  }
  catch (raw_jsExn){
    var jsExn = Caml_js_exceptions.internalToOCamlException(raw_jsExn);
    if (jsExn.RE_EXN_ID === Js_exn.$$Error) {
      return {
              TAG: "Error",
              _0: toSerializeError(getOrRethrow(jsExn._1))
            };
    }
    throw jsExn;
  }
}

function serializeOrRaiseWith(value, struct) {
  try {
    return struct.j(value);
  }
  catch (raw_jsExn){
    var jsExn = Caml_js_exceptions.internalToOCamlException(raw_jsExn);
    if (jsExn.RE_EXN_ID === Js_exn.$$Error) {
      throw {
            RE_EXN_ID: Raised,
            _1: toSerializeError(getOrRethrow(jsExn._1)),
            Error: new Error()
          };
    }
    throw jsExn;
  }
}

function serializeToUnknownOrRaiseWith(value, struct) {
  try {
    return struct.s(value);
  }
  catch (raw_jsExn){
    var jsExn = Caml_js_exceptions.internalToOCamlException(raw_jsExn);
    if (jsExn.RE_EXN_ID === Js_exn.$$Error) {
      throw {
            RE_EXN_ID: Raised,
            _1: toSerializeError(getOrRethrow(jsExn._1)),
            Error: new Error()
          };
    }
    throw jsExn;
  }
}

function serializeWith(value, struct) {
  try {
    return {
            TAG: "Ok",
            _0: struct.j(value)
          };
  }
  catch (raw_jsExn){
    var jsExn = Caml_js_exceptions.internalToOCamlException(raw_jsExn);
    if (jsExn.RE_EXN_ID === Js_exn.$$Error) {
      return {
              TAG: "Error",
              _0: toSerializeError(getOrRethrow(jsExn._1))
            };
    }
    throw jsExn;
  }
}

function serializeToJsonStringWith(value, spaceOpt, struct) {
  var space = spaceOpt !== undefined ? spaceOpt : 0;
  var json = serializeWith(value, struct);
  if (json.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: JSON.stringify(json._0, null, space)
          };
  } else {
    return json;
  }
}

function parseJsonStringWith(json, struct) {
  var json$1;
  try {
    json$1 = {
      TAG: "Ok",
      _0: JSON.parse(json)
    };
  }
  catch (raw_error){
    var error = Caml_js_exceptions.internalToOCamlException(raw_error);
    if (error.RE_EXN_ID === Js_exn.$$Error) {
      json$1 = {
        TAG: "Error",
        _0: {
          operation: "Parsing",
          code: {
            TAG: "OperationFailed",
            _0: error._1.message
          },
          path: ""
        }
      };
    } else {
      throw error;
    }
  }
  if (json$1.TAG === "Ok") {
    return parseAnyWith(json$1._0, struct);
  } else {
    return json$1;
  }
}

function recursive(fn) {
  var placeholder = ({m:emptyMetadataMap});
  var struct = fn(placeholder);
  Object.assign(placeholder, struct);
  var builder = placeholder.pb;
  placeholder.pb = (function (b, selfStruct, inputVar, outputVar, pathVar) {
      selfStruct.pb = noop;
      var asyncVars = new Set();
      builder({
            c: -1,
            v: "",
            a: asyncVars,
            e: []
          }, selfStruct, inputVar, outputVar, pathVar);
      var isAsync = asyncVars.size > 0;
      selfStruct.pb = (function (b, selfStruct, inputVar, outputVar, pathVar) {
          if (isAsync) {
            return embedAsyncOperation(b, inputVar, outputVar, pathVar, (function (input) {
                          return selfStruct.a(input);
                        }), undefined, undefined);
          } else {
            return embedSyncOperation(b, inputVar, outputVar, pathVar, (function (input) {
                          return selfStruct.p(input);
                        }), undefined, undefined, undefined);
          }
        });
      compileParser(selfStruct, builder);
      selfStruct.pb = builder;
      if (isAsync) {
        return embedAsyncOperation(b, inputVar, outputVar, pathVar, selfStruct.a, undefined, undefined);
      } else {
        return embedSyncOperation(b, inputVar, outputVar, pathVar, selfStruct.p, undefined, undefined, undefined);
      }
    });
  var builder$1 = placeholder.sb;
  placeholder.sb = (function (b, selfStruct, inputVar, outputVar, pathVar) {
      selfStruct.sb = (function (b, selfStruct, inputVar, outputVar, pathVar) {
          return embedSyncOperation(b, inputVar, outputVar, pathVar, (function (input) {
                        return selfStruct.s(input);
                      }), undefined, undefined, undefined);
        });
      compileSerializer(selfStruct, builder$1);
      selfStruct.sb = builder$1;
      return embedSyncOperation(b, inputVar, outputVar, pathVar, selfStruct.s, undefined, undefined, undefined);
    });
  return placeholder;
}

function make(namespace, name) {
  return namespace + ":" + name;
}

var Id = {
  make: make
};

var make1 = ((id,metadata)=>({[id]:metadata}));

function get(struct, id) {
  return Js_dict.get(struct.m, id);
}

function set(struct, id, metadata) {
  var metadataMap;
  if (struct.m === emptyMetadataMap) {
    metadataMap = make1(id, metadata);
  } else {
    var copy = Object.assign({}, struct.m);
    copy[id] = metadata;
    metadataMap = copy;
  }
  return {
          t: struct.t,
          pb: struct.pb,
          sb: struct.sb,
          i: 0,
          s: initialSerialize,
          j: initialSerializeToJson,
          p: intitialParse,
          a: intitialParseAsync,
          m: metadataMap
        };
}

var nameMetadataId = "rescript-struct:name";

function name(struct) {
  var n = Js_dict.get(struct.m, nameMetadataId);
  if (n !== undefined) {
    return n;
  }
  var tagged = struct.t;
  if (typeof tagged !== "object") {
    return tagged;
  }
  switch (tagged.TAG) {
    case "Literal" :
        return "Literal(" + toText(tagged._0) + ")";
    case "Option" :
        return "Option(" + name(tagged._0) + ")";
    case "Null" :
        return "Null(" + name(tagged._0) + ")";
    case "Array" :
        return "Array(" + name(tagged._0) + ")";
    case "Object" :
        var fields = tagged.fields;
        return "Object({" + tagged.fieldNames.map(function (fieldName) {
                      var fieldStruct = fields[fieldName];
                      return JSON.stringify(fieldName) + ": " + name(fieldStruct);
                    }).join(", ") + "})";
    case "Tuple" :
        return "Tuple(" + tagged._0.map(function (s) {
                      return name(s);
                    }).join(", ") + ")";
    case "Union" :
        return "Union(" + tagged._0.map(function (s) {
                      return name(s);
                    }).join(", ") + ")";
    case "Dict" :
        return "Dict(" + name(tagged._0) + ")";
    
  }
}

function setName(struct, name) {
  return set(struct, nameMetadataId, name);
}

function refine(struct, maybeParser, maybeAsyncParser, maybeSerializer, param) {
  if (maybeParser === undefined && maybeAsyncParser === undefined && maybeSerializer === undefined) {
    panic("struct factory Refine");
  }
  return {
          t: struct.t,
          pb: maybeParser !== undefined ? (
              maybeAsyncParser !== undefined ? (function (b, param, inputVar, outputVar, pathVar) {
                    var childOutputVar = $$var(b);
                    var code = run(b, struct.pb, struct, inputVar, childOutputVar, pathVar);
                    return code + embedSyncOperation(b, childOutputVar, outputVar, pathVar, maybeParser, undefined, true, undefined) + embedAsyncOperation(b, childOutputVar, outputVar, pathVar, (function (i) {
                                  return function () {
                                    return maybeAsyncParser(i);
                                  };
                                }), true, undefined);
                  }) : (function (b, param, inputVar, outputVar, pathVar) {
                    var childOutputVar = $$var(b);
                    var code = run(b, struct.pb, struct, inputVar, childOutputVar, pathVar);
                    return code + embedSyncOperation(b, childOutputVar, outputVar, pathVar, maybeParser, undefined, true, undefined);
                  })
            ) : (
              maybeAsyncParser !== undefined ? (function (b, param, inputVar, outputVar, pathVar) {
                    var childOutputVar = $$var(b);
                    var code = run(b, struct.pb, struct, inputVar, childOutputVar, pathVar);
                    return code + embedAsyncOperation(b, childOutputVar, outputVar, pathVar, (function (i) {
                                  return function () {
                                    return maybeAsyncParser(i);
                                  };
                                }), true, undefined);
                  }) : struct.pb
            ),
          sb: maybeSerializer !== undefined ? (function (b, param, inputVar, outputVar, pathVar) {
                var transformResultVar = $$var(b);
                var code = run(b, struct.pb, struct, transformResultVar, outputVar, pathVar);
                return embedSyncOperation(b, inputVar, transformResultVar, pathVar, maybeSerializer, undefined, true, undefined) + code;
              }) : struct.sb,
          i: 0,
          s: initialSerialize,
          j: initialSerializeToJson,
          p: intitialParse,
          a: intitialParseAsync,
          m: struct.m
        };
}

function addRefinement(struct, metadataId, refinement, refiner) {
  var refinements = Js_dict.get(struct.m, metadataId);
  return refine(set(struct, metadataId, refinements !== undefined ? refinements.concat(refinement) : [refinement]), refiner, undefined, refiner, undefined);
}

function advancedTransform(struct, maybeParser, maybeSerializer, param) {
  if (maybeParser === undefined && maybeSerializer === undefined) {
    panic("struct factory Transform");
  }
  return {
          t: struct.t,
          pb: (function (b, selfStruct, inputVar, outputVar, pathVar) {
              if (maybeParser === undefined) {
                return raise(b, pathVar, "MissingParser") + ";";
              }
              var syncTransformation = maybeParser(selfStruct);
              if (typeof syncTransformation !== "object") {
                return run(b, struct.pb, struct, inputVar, outputVar, pathVar);
              }
              if (syncTransformation.TAG === "Sync") {
                var childOutputVar = $$var(b);
                var code = run(b, struct.pb, struct, inputVar, childOutputVar, pathVar);
                return code + embedSyncOperation(b, childOutputVar, outputVar, pathVar, syncTransformation._0, undefined, undefined, undefined);
              }
              var asyncParser = syncTransformation._0;
              var childOutputVar$1 = $$var(b);
              var code$1 = run(b, struct.pb, struct, inputVar, childOutputVar$1, pathVar);
              return code$1 + embedAsyncOperation(b, childOutputVar$1, outputVar, pathVar, (function (i) {
                            return function () {
                              return asyncParser(i);
                            };
                          }), undefined, undefined);
            }),
          sb: (function (b, selfStruct, inputVar, outputVar, pathVar) {
              if (maybeSerializer === undefined) {
                return raise(b, pathVar, "MissingSerializer") + ";";
              }
              var fn = maybeSerializer(selfStruct);
              if (typeof fn !== "object") {
                return run(b, struct.sb, struct, inputVar, outputVar, pathVar);
              }
              if (fn.TAG !== "Sync") {
                return raise(b, pathVar, "MissingSerializer") + ";";
              }
              var transformOutputVar = $$var(b);
              var code = run(b, struct.sb, struct, transformOutputVar, outputVar, pathVar);
              return embedSyncOperation(b, inputVar, transformOutputVar, pathVar, fn._0, undefined, undefined, undefined) + code;
            }),
          i: 0,
          s: initialSerialize,
          j: initialSerializeToJson,
          p: intitialParse,
          a: intitialParseAsync,
          m: struct.m
        };
}

function transform(struct, maybeParser, maybeAsyncParser, maybeSerializer, param) {
  if (maybeParser === undefined && maybeAsyncParser === undefined && maybeSerializer === undefined) {
    panic("struct factory Transform");
  }
  var tmp;
  if (maybeParser !== undefined) {
    if (maybeAsyncParser !== undefined) {
      throw new Error("[rescript-struct] The S.transform doesn't support the `parser` and `asyncParser` arguments simultaneously. Move `asyncParser` to another S.transform.");
    }
    tmp = (function (b, param, inputVar, outputVar, pathVar) {
        var childOutputVar = $$var(b);
        var code = run(b, struct.pb, struct, inputVar, childOutputVar, pathVar);
        return code + embedSyncOperation(b, childOutputVar, outputVar, pathVar, maybeParser, undefined, undefined, undefined);
      });
  } else {
    tmp = maybeAsyncParser !== undefined ? (function (b, param, inputVar, outputVar, pathVar) {
          var childOutputVar = $$var(b);
          var code = run(b, struct.pb, struct, inputVar, childOutputVar, pathVar);
          return code + embedAsyncOperation(b, childOutputVar, outputVar, pathVar, (function (i) {
                        return function () {
                          return maybeAsyncParser(i);
                        };
                      }), undefined, undefined);
        }) : (function (b, param, param$1, param$2, pathVar) {
          return raise(b, pathVar, "MissingParser") + ";";
        });
  }
  return {
          t: struct.t,
          pb: tmp,
          sb: maybeSerializer !== undefined ? (function (b, param, inputVar, outputVar, pathVar) {
                var transformOutputVar = $$var(b);
                var code = run(b, struct.sb, struct, transformOutputVar, outputVar, pathVar);
                return embedSyncOperation(b, inputVar, transformOutputVar, pathVar, maybeSerializer, undefined, undefined, undefined) + code;
              }) : (function (b, param, param$1, param$2, pathVar) {
                return raise(b, pathVar, "MissingSerializer") + ";";
              }),
          i: 0,
          s: initialSerialize,
          j: initialSerializeToJson,
          p: intitialParse,
          a: intitialParseAsync,
          m: struct.m
        };
}

function advancedPreprocess(struct, maybeParser, maybeSerializer, param) {
  if (maybeParser === undefined && maybeSerializer === undefined) {
    panic("struct factory Preprocess");
  }
  var unionStructs = struct.t;
  if (typeof unionStructs === "object" && unionStructs.TAG === "Union") {
    return {
            t: {
              TAG: "Union",
              _0: unionStructs._0.map(function (unionStruct) {
                    return advancedPreprocess(unionStruct, maybeParser, maybeSerializer, undefined);
                  })
            },
            pb: struct.pb,
            sb: struct.sb,
            i: 0,
            s: initialSerialize,
            j: initialSerializeToJson,
            p: intitialParse,
            a: intitialParseAsync,
            m: struct.m
          };
  }
  return {
          t: struct.t,
          pb: (function (b, selfStruct, inputVar, outputVar, pathVar) {
              if (maybeParser === undefined) {
                return raise(b, pathVar, "MissingParser") + ";";
              }
              var syncTransformation = maybeParser(selfStruct);
              if (typeof syncTransformation !== "object") {
                return run(b, struct.pb, struct, inputVar, outputVar, pathVar);
              }
              if (syncTransformation.TAG === "Sync") {
                var parseResultVar = $$var(b);
                var code = run(b, struct.pb, struct, parseResultVar, outputVar, pathVar);
                return embedSyncOperation(b, inputVar, parseResultVar, pathVar, syncTransformation._0, undefined, undefined, undefined) + code;
              }
              var asyncParser = syncTransformation._0;
              var parseResultVar$1 = $$var(b);
              var childOutputVar = $$var(b);
              var code$1 = run(b, struct.pb, struct, "t", childOutputVar, pathVar);
              var isAsync = struct.i;
              return embedAsyncOperation(b, inputVar, parseResultVar$1, pathVar, (function (i) {
                            return function () {
                              return asyncParser(i);
                            };
                          }), undefined, undefined) + outputVar + "=()=>" + parseResultVar$1 + "().then(t=>{" + code$1 + "return " + (
                      isAsync ? childOutputVar + "()" : childOutputVar
                    ) + "});";
            }),
          sb: (function (b, selfStruct, inputVar, outputVar, pathVar) {
              if (maybeSerializer === undefined) {
                return raise(b, pathVar, "MissingSerializer") + ";";
              }
              var fn = maybeSerializer(selfStruct);
              if (typeof fn !== "object") {
                return run(b, struct.sb, struct, inputVar, outputVar, pathVar);
              }
              if (fn.TAG !== "Sync") {
                return raise(b, pathVar, "MissingSerializer") + ";";
              }
              var structOuputVar = $$var(b);
              var code = run(b, struct.sb, struct, inputVar, structOuputVar, pathVar);
              return code + embedSyncOperation(b, structOuputVar, outputVar, pathVar, fn._0, undefined, undefined, undefined);
            }),
          i: 0,
          s: initialSerialize,
          j: initialSerializeToJson,
          p: intitialParse,
          a: intitialParseAsync,
          m: struct.m
        };
}

function custom(name, maybeParser, maybeAsyncParser, maybeSerializer, param) {
  if (maybeParser === undefined && maybeAsyncParser === undefined && maybeSerializer === undefined) {
    panic("Custom struct factory");
  }
  var tmp;
  if (maybeParser !== undefined) {
    if (maybeAsyncParser !== undefined) {
      throw new Error("[rescript-struct] The S.custom doesn't support the `parser` and `asyncParser` arguments simultaneously. Keep only `asyncParser`.");
    }
    tmp = (function (b, param, inputVar, outputVar, pathVar) {
        return embedSyncOperation(b, inputVar, outputVar, pathVar, maybeParser, undefined, undefined, undefined);
      });
  } else {
    tmp = maybeAsyncParser !== undefined ? (function (b, param, inputVar, outputVar, pathVar) {
          return embedAsyncOperation(b, inputVar, outputVar, pathVar, (function (input) {
                        return function () {
                          return maybeAsyncParser(input);
                        };
                      }), undefined, undefined);
        }) : (function (b, param, param$1, param$2, pathVar) {
          return raise(b, pathVar, "MissingParser") + ";";
        });
  }
  return {
          t: "Unknown",
          pb: tmp,
          sb: maybeSerializer !== undefined ? (function (b, param, inputVar, outputVar, pathVar) {
                return embedSyncOperation(b, inputVar, outputVar, pathVar, maybeSerializer, undefined, undefined, undefined);
              }) : (function (b, param, param$1, param$2, pathVar) {
                return raise(b, pathVar, "MissingSerializer") + ";";
              }),
          i: 0,
          s: initialSerialize,
          j: initialSerializeToJson,
          p: intitialParse,
          a: intitialParseAsync,
          m: make1(nameMetadataId, name)
        };
}

function literalCheckBuilder(b, value, inputVar) {
  if (Number.isNaN(value)) {
    return "Number.isNaN(" + inputVar + ")";
  }
  var check = inputVar + "===" + ("e[" + (b.e.push(value) - 1) + "]");
  if (Array.isArray(value)) {
    return "(" + check + "||Array.isArray(" + inputVar + ")&&" + inputVar + ".length===" + value.length + (
            value.length > 0 ? "&&" + value.map(function (item, idx) {
                      return literalCheckBuilder(b, item, inputVar + "[" + idx + "]");
                    }).join("&&") : ""
          ) + ")";
  }
  if (!(value !== null && typeof value === "object" && value.constructor === Object)) {
    return check;
  }
  var keys = Object.keys(value);
  var numberOfKeys = keys.length;
  return "(" + check + "||" + inputVar + ".constructor===Object&&Object.keys(" + inputVar + ").length===" + numberOfKeys + (
          numberOfKeys > 0 ? "&&" + keys.map(function (key) {
                    var inputVar = $$var(b);
                    return "(" + inputVar + "=" + inputVar + "[" + JSON.stringify(key) + "]," + literalCheckBuilder(b, value[key], inputVar) + ")";
                  }).join("&&") : ""
        ) + ")";
}

function factory(value) {
  var literal = classify(value);
  var operationBuilder = function (b, param, inputVar, outputVar, pathVar) {
    return literalCheckBuilder(b, value, inputVar) + "||" + raiseWithArg(b, pathVar, (function (input) {
                  return {
                          TAG: "InvalidLiteral",
                          expected: literal,
                          received: input
                        };
                }), inputVar) + ";" + outputVar + "=" + inputVar + ";";
  };
  return {
          t: {
            TAG: "Literal",
            _0: literal
          },
          pb: operationBuilder,
          sb: operationBuilder,
          i: 0,
          s: initialSerialize,
          j: initialSerializeToJson,
          p: intitialParse,
          a: intitialParseAsync,
          m: emptyMetadataMap
        };
}

function analyzeDefinition(definition, definerCtx, path) {
  if (definition === definerCtx) {
    if (definerCtx.r) {
      throw new Error("[rescript-struct] The variant's value is registered multiple times. If you want to duplicate it, use S.transform instead.");
    }
    definerCtx.a = path;
    definerCtx.r = true;
    return ;
  }
  if (typeof definition === "object" && definition !== null) {
    var definitionFieldNames = Object.keys(definition);
    for(var idx = 0 ,idx_finish = definitionFieldNames.length; idx < idx_finish; ++idx){
      var definitionFieldName = definitionFieldNames[idx];
      var fieldDefinition = definition[definitionFieldName];
      analyzeDefinition(fieldDefinition, definerCtx, path + ("[" + JSON.stringify(definitionFieldName) + "]"));
    }
    return ;
  }
  definerCtx.c.push({
        v: definition,
        p: path
      });
}

function factory$1(struct, definer) {
  var definerCtx = {
    a: "",
    r: false,
    c: []
  };
  var definition = definer(definerCtx);
  analyzeDefinition(definition, definerCtx, "");
  return {
          t: struct.t,
          pb: (function (b, param, inputVar, outputVar, pathVar) {
              var childOutputVar = $$var(b);
              var code = run(b, struct.pb, struct, inputVar, childOutputVar, pathVar);
              return code + embedSyncOperation(b, childOutputVar, outputVar, pathVar, definer, true, undefined, undefined);
            }),
          sb: (function (b, selfStruct, inputVar, outputVar, pathVar) {
              var valuePath = definerCtx.a;
              var isValueRegistered = definerCtx.r;
              var constantDefinitions = definerCtx.c;
              var childInputVar = $$var(b);
              var childCode = run(b, struct.sb, struct, childInputVar, outputVar, pathVar);
              var codeRef = "";
              for(var idx = 0 ,idx_finish = constantDefinitions.length; idx < idx_finish; ++idx){
                var match = constantDefinitions[idx];
                var path = match.p;
                var value$1 = match.v;
                codeRef = codeRef + ("if(" + inputVar + path + "!==" + ("e[" + (b.e.push(value$1) - 1) + "]") + "){" + raiseWithArg(b, pathVar + "+" + JSON.stringify(path), (function(value$1){
                      return function (input) {
                        return {
                                TAG: "InvalidLiteral",
                                expected: classify(value$1),
                                received: input
                              };
                      }
                      }(value$1)), inputVar + path) + "}");
              }
              var tmp;
              if (isValueRegistered) {
                tmp = childInputVar + "=" + inputVar + valuePath;
              } else {
                var literal = toLiteral(selfStruct);
                if (literal !== undefined) {
                  var value$2 = value(literal);
                  tmp = childInputVar + "=" + ("e[" + (b.e.push(value$2) - 1) + "]");
                } else {
                  tmp = raise(b, pathVar, "MissingSerializer");
                }
              }
              return codeRef + tmp + ";" + childCode;
            }),
          i: 0,
          s: initialSerialize,
          j: initialSerializeToJson,
          p: intitialParse,
          a: intitialParseAsync,
          m: struct.m
        };
}

var metadataId = "rescript-struct:Object.UnknownKeys";

function classify$2(struct) {
  var t = Js_dict.get(struct.m, metadataId);
  if (t !== undefined) {
    return t;
  } else {
    return "Strip";
  }
}

function analyzeDefinition$1(definition, definerCtx, path) {
  if (definerCtx.s.has(definition)) {
    if (definition.r) {
      throw new Error("[rescript-struct] " + ("The field " + definition.i + " is registered multiple times. If you want to duplicate a field, use S.transform instead."));
    }
    definition.p = path;
    definition.r = true;
    return ;
  }
  if (typeof definition === "object" && definition !== null) {
    definerCtx.p.push(path);
    definerCtx.v.push(Array.isArray(definition) ? "[]" : "{}");
    var definitionFieldNames = Object.keys(definition);
    for(var idx = 0 ,idx_finish = definitionFieldNames.length; idx < idx_finish; ++idx){
      var definitionFieldName = definitionFieldNames[idx];
      var fieldDefinition = definition[definitionFieldName];
      analyzeDefinition$1(fieldDefinition, definerCtx, path + ("[" + JSON.stringify(definitionFieldName) + "]"));
    }
    return ;
  }
  definerCtx.c.push({
        v: definition,
        p: path
      });
}

function factory$2(definer) {
  var fields = {};
  var fieldNames = [];
  var fieldDefinitions = [];
  var fieldDefinitionsSet = new Set();
  var field = function (fieldName, struct) {
    if (fields.hasOwnProperty(fieldName)) {
      throw new Error("[rescript-struct] " + ("The field \"" + fieldName + "\" is defined multiple times. If you want to duplicate a field, use S.transform instead."));
    }
    var fieldDefinition = {
      s: struct,
      i: JSON.stringify(fieldName),
      p: "",
      r: false
    };
    fields[fieldName] = struct;
    fieldNames.push(fieldName);
    fieldDefinitions.push(fieldDefinition);
    fieldDefinitionsSet.add(fieldDefinition);
    return fieldDefinition;
  };
  var tag = function (tag$1, asValue) {
    field(tag$1, factory(asValue));
  };
  var definerCtx_p = [];
  var definerCtx_v = [];
  var definerCtx_c = [];
  var definerCtx = {
    n: fieldNames,
    h: fields,
    d: fieldDefinitions,
    p: definerCtx_p,
    v: definerCtx_v,
    c: definerCtx_c,
    s: fieldDefinitionsSet,
    f: field,
    t: tag
  };
  var definition = definer(definerCtx);
  analyzeDefinition$1(definition, definerCtx, "");
  return {
          t: {
            TAG: "Object",
            fields: fields,
            fieldNames: fieldNames
          },
          pb: (function (b, selfStruct, inputVar, outputVar, pathVar) {
              var constantDefinitions = definerCtx_c;
              var inlinedPreparationValues = definerCtx_v;
              var preparationPathes = definerCtx_p;
              var fieldDefinitions$1 = fieldDefinitions;
              var asyncFieldVars = [];
              var syncOutputVar = $$var(b);
              var codeRef = "if(!(typeof " + inputVar + "===\"object\"&&" + inputVar + "!==null&&!Array.isArray(" + inputVar + "))){" + raiseWithArg(b, pathVar, (function (input) {
                      return {
                              TAG: "InvalidType",
                              expected: selfStruct,
                              received: input
                            };
                    }), inputVar) + "}";
              for(var idx = 0 ,idx_finish = preparationPathes.length; idx < idx_finish; ++idx){
                var preparationPath = preparationPathes[idx];
                var preparationInlinedValue = inlinedPreparationValues[idx];
                codeRef = codeRef + (syncOutputVar + preparationPath + "=" + preparationInlinedValue + ";");
              }
              for(var idx$1 = 0 ,idx_finish$1 = fieldDefinitions$1.length; idx$1 < idx_finish$1; ++idx$1){
                var fieldDefinition = fieldDefinitions$1[idx$1];
                var inlinedFieldName = fieldDefinition.i;
                var fieldStruct = fieldDefinition.s;
                var path = fieldDefinition.p;
                var isRegistered = fieldDefinition.r;
                var fieldInputVar = $$var(b);
                var fieldOuputVar = $$var(b);
                var fieldCode = run(b, fieldStruct.pb, fieldStruct, fieldInputVar, fieldOuputVar, pathVar + "+'['+" + JSON.stringify(inlinedFieldName) + "+']'");
                var isAsyncField = fieldStruct.i;
                codeRef = codeRef + (fieldInputVar + "=" + inputVar + "[" + inlinedFieldName + "];") + fieldCode + (
                  isRegistered ? syncOutputVar + path + "=" + fieldOuputVar + ";" : ""
                );
                if (isAsyncField) {
                  asyncFieldVars.push(isRegistered ? syncOutputVar + path : fieldOuputVar);
                }
                
              }
              var withUnknownKeysRefinement = classify$2(selfStruct) === "Strict";
              if (withUnknownKeysRefinement) {
                if (fieldDefinitions$1.length !== 0) {
                  var keyVar = $$var(b);
                  codeRef = codeRef + ("for(" + keyVar + " in " + inputVar + "){if(!(");
                  for(var idx$2 = 0 ,idx_finish$2 = fieldDefinitions$1.length; idx$2 < idx_finish$2; ++idx$2){
                    var fieldDefinition$1 = fieldDefinitions$1[idx$2];
                    if (idx$2 !== 0) {
                      codeRef = codeRef + "||";
                    }
                    codeRef = codeRef + (keyVar + "===" + fieldDefinition$1.i);
                  }
                  codeRef = codeRef + (")){" + raiseWithArg(b, pathVar, (function (exccessFieldName) {
                            return {
                                    TAG: "ExcessField",
                                    _0: exccessFieldName
                                  };
                          }), keyVar) + "}}");
                } else {
                  var keyVar$1 = $$var(b);
                  codeRef = codeRef + ("for(" + keyVar$1 + " in " + inputVar + "){" + raiseWithArg(b, pathVar, (function (exccessFieldName) {
                            return {
                                    TAG: "ExcessField",
                                    _0: exccessFieldName
                                  };
                          }), keyVar$1) + "}");
                }
              }
              for(var idx$3 = 0 ,idx_finish$3 = constantDefinitions.length; idx$3 < idx_finish$3; ++idx$3){
                var match = constantDefinitions[idx$3];
                codeRef = codeRef + (syncOutputVar + match.p + "=" + ("e[" + (b.e.push(match.v) - 1) + "]") + ";");
              }
              if (asyncFieldVars.length === 0) {
                return codeRef + outputVar + "=" + syncOutputVar + ";";
              }
              var resolveVar = varWithoutAllocation(b);
              var rejectVar = varWithoutAllocation(b);
              var asyncParseResultVar = varWithoutAllocation(b);
              var counterVar = varWithoutAllocation(b);
              return codeRef + outputVar + "=()=>new Promise((" + resolveVar + "," + rejectVar + ")=>{let " + counterVar + "=" + asyncFieldVars.length.toString() + ";" + asyncFieldVars.map(function (asyncFieldVar) {
                            return asyncFieldVar + "().then(" + asyncParseResultVar + "=>{" + asyncFieldVar + "=" + asyncParseResultVar + ";if(" + counterVar + "--===1){" + resolveVar + "(" + syncOutputVar + ")}}," + rejectVar + ")";
                          }).join(";") + "});";
            }),
          sb: (function (b, param, inputVar, outputVar, pathVar) {
              var constantDefinitions = definerCtx_c;
              var fieldDefinitions$1 = fieldDefinitions;
              var codeRef = "";
              for(var idx = 0 ,idx_finish = constantDefinitions.length; idx < idx_finish; ++idx){
                var match = constantDefinitions[idx];
                var path = match.p;
                var value$1 = match.v;
                codeRef = codeRef + ("if(" + inputVar + path + "!==" + ("e[" + (b.e.push(value$1) - 1) + "]") + "){" + raiseWithArg(b, pathVar + "+" + JSON.stringify(path), (function(value$1){
                      return function (input) {
                        return {
                                TAG: "InvalidLiteral",
                                expected: classify(value$1),
                                received: input
                              };
                      }
                      }(value$1)), inputVar + path) + "}");
              }
              codeRef = codeRef + (outputVar + "={};");
              for(var idx$1 = 0 ,idx_finish$1 = fieldDefinitions$1.length; idx$1 < idx_finish$1; ++idx$1){
                var fieldDefinition = fieldDefinitions$1[idx$1];
                var fieldStruct = fieldDefinition.s;
                var path$1 = fieldDefinition.p;
                var isRegistered = fieldDefinition.r;
                var fieldPathVar = pathVar + "+" + JSON.stringify(path$1);
                var destinationVar = outputVar + "[" + fieldDefinition.i + "]";
                var tmp;
                if (isRegistered) {
                  var fieldOuputVar = $$var(b);
                  var fieldCode = run(b, fieldStruct.sb, fieldStruct, destinationVar, fieldOuputVar, fieldPathVar);
                  tmp = destinationVar + "=" + inputVar + path$1 + ";" + fieldCode + (
                    destinationVar === fieldOuputVar ? "" : destinationVar + "=" + fieldOuputVar + ";"
                  );
                } else {
                  var literal = toLiteral(fieldStruct);
                  var tmp$1;
                  if (literal !== undefined) {
                    var value$2 = value(literal);
                    tmp$1 = destinationVar + "=" + ("e[" + (b.e.push(value$2) - 1) + "]");
                  } else {
                    tmp$1 = raise(b, pathVar, "MissingSerializer");
                  }
                  tmp = tmp$1 + ";";
                }
                codeRef = codeRef + tmp;
              }
              return codeRef;
            }),
          i: 0,
          s: initialSerialize,
          j: initialSerializeToJson,
          p: intitialParse,
          a: intitialParseAsync,
          m: emptyMetadataMap
        };
}

function strip(struct) {
  return set(struct, metadataId, "Strip");
}

function strict(struct) {
  return set(struct, metadataId, "Strict");
}

function builder(b, selfStruct, inputVar, param, pathVar) {
  return raiseWithArg(b, pathVar, (function (input) {
                return {
                        TAG: "InvalidType",
                        expected: selfStruct,
                        received: input
                      };
              }), inputVar) + ";";
}

var struct = {
  t: "Never",
  pb: builder,
  sb: builder,
  i: 0,
  s: initialSerialize,
  j: initialSerializeToJson,
  p: intitialParse,
  a: intitialParseAsync,
  m: emptyMetadataMap
};

var struct$1 = {
  t: "Unknown",
  pb: noop,
  sb: noop,
  i: 0,
  s: initialSerialize,
  j: initialSerializeToJson,
  p: intitialParse,
  a: intitialParseAsync,
  m: emptyMetadataMap
};

var metadataId$1 = "rescript-struct:String.refinements";

function refinements(struct) {
  var m = Js_dict.get(struct.m, metadataId$1);
  if (m !== undefined) {
    return m;
  } else {
    return [];
  }
}

var cuidRegex = /^c[^\s-]{8,}$/i;

var uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;

var emailRegex = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;

var datetimeRe = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?Z$/;

function parseOperationBuilder(b, selfStruct, inputVar, outputVar, pathVar) {
  return "if(typeof " + inputVar + "!==\"string\"){" + raiseWithArg(b, pathVar, (function (input) {
                return {
                        TAG: "InvalidType",
                        expected: selfStruct,
                        received: input
                      };
              }), inputVar) + "}" + outputVar + "=" + inputVar + ";";
}

var struct$2 = {
  t: "String",
  pb: parseOperationBuilder,
  sb: noop,
  i: 0,
  s: initialSerialize,
  j: initialSerializeToJson,
  p: intitialParse,
  a: intitialParseAsync,
  m: emptyMetadataMap
};

function min(struct, maybeMessage, length) {
  var message = maybeMessage !== undefined ? maybeMessage : "String must be " + length.toString() + " or more characters long";
  var refiner = function (value) {
    if (value.length < length) {
      return fail(undefined, message);
    }
    
  };
  return addRefinement(struct, metadataId$1, {
              kind: {
                TAG: "Min",
                length: length
              },
              message: message
            }, refiner);
}

function max(struct, maybeMessage, length) {
  var message = maybeMessage !== undefined ? maybeMessage : "String must be " + length.toString() + " or fewer characters long";
  var refiner = function (value) {
    if (value.length > length) {
      return fail(undefined, message);
    }
    
  };
  return addRefinement(struct, metadataId$1, {
              kind: {
                TAG: "Max",
                length: length
              },
              message: message
            }, refiner);
}

function length(struct, maybeMessage, length$1) {
  var message = maybeMessage !== undefined ? maybeMessage : "String must be exactly " + length$1.toString() + " characters long";
  var refiner = function (value) {
    if (value.length !== length$1) {
      return fail(undefined, message);
    }
    
  };
  return addRefinement(struct, metadataId$1, {
              kind: {
                TAG: "Length",
                length: length$1
              },
              message: message
            }, refiner);
}

function email(struct, messageOpt, param) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid email address";
  var refiner = function (value) {
    if (!emailRegex.test(value)) {
      return fail(undefined, message);
    }
    
  };
  return addRefinement(struct, metadataId$1, {
              kind: "Email",
              message: message
            }, refiner);
}

function uuid(struct, messageOpt, param) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid UUID";
  var refiner = function (value) {
    if (!uuidRegex.test(value)) {
      return fail(undefined, message);
    }
    
  };
  return addRefinement(struct, metadataId$1, {
              kind: "Uuid",
              message: message
            }, refiner);
}

function cuid(struct, messageOpt, param) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid CUID";
  var refiner = function (value) {
    if (!cuidRegex.test(value)) {
      return fail(undefined, message);
    }
    
  };
  return addRefinement(struct, metadataId$1, {
              kind: "Cuid",
              message: message
            }, refiner);
}

function url(struct, messageOpt, param) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid url";
  var refiner = function (value) {
    var tmp;
    try {
      new URL(value);
      tmp = true;
    }
    catch (exn){
      tmp = false;
    }
    if (!tmp) {
      return fail(undefined, message);
    }
    
  };
  return addRefinement(struct, metadataId$1, {
              kind: "Url",
              message: message
            }, refiner);
}

function pattern(struct, messageOpt, re) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid";
  var refiner = function (value) {
    re.lastIndex = 0;
    if (!re.test(value)) {
      return fail(undefined, message);
    }
    
  };
  return addRefinement(struct, metadataId$1, {
              kind: {
                TAG: "Pattern",
                re: re
              },
              message: message
            }, refiner);
}

function datetime(struct, messageOpt, param) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid datetime string! Must be UTC";
  var refinement = {
    kind: "Datetime",
    message: message
  };
  var refinements = Js_dict.get(struct.m, metadataId$1);
  return transform(set(struct, metadataId$1, refinements !== undefined ? refinements.concat(refinement) : [refinement]), (function (string) {
                if (!datetimeRe.test(string)) {
                  fail(undefined, message);
                }
                return new Date(string);
              }), undefined, (function (date) {
                return date.toISOString();
              }), undefined);
}

function trim(struct, param) {
  var transformer = function (string) {
    return string.trim();
  };
  return transform(struct, transformer, undefined, transformer, undefined);
}

function factory$3(childStruct) {
  return {
          t: "String",
          pb: (function (b, selfStruct, inputVar, outputVar, pathVar) {
              var jsonStringVar = $$var(b);
              var stringParserCode = run(b, parseOperationBuilder, selfStruct, inputVar, jsonStringVar, pathVar);
              var jsonVar = $$var(b);
              var childCode = run(b, childStruct.pb, childStruct, jsonVar, outputVar, pathVar);
              return stringParserCode + "try{" + jsonVar + "=JSON.parse(" + jsonStringVar + ")}catch(t){" + raiseWithArg(b, pathVar, (function (message) {
                            return {
                                    TAG: "OperationFailed",
                                    _0: message
                                  };
                          }), "t.message") + "}" + childCode;
            }),
          sb: (function (b, param, inputVar, outputVar, pathVar) {
              var childOutputVar = $$var(b);
              var childCode = run(b, childStruct.pb, childStruct, inputVar, childOutputVar, pathVar);
              return childCode + outputVar + "=JSON.stringify(" + childOutputVar + ");";
            }),
          i: 0,
          s: initialSerialize,
          j: initialSerializeToJson,
          p: intitialParse,
          a: intitialParseAsync,
          m: emptyMetadataMap
        };
}

var struct$3 = {
  t: "Bool",
  pb: (function (b, selfStruct, inputVar, outputVar, pathVar) {
      return "if(typeof " + inputVar + "!==\"boolean\"){" + raiseWithArg(b, pathVar, (function (input) {
                    return {
                            TAG: "InvalidType",
                            expected: selfStruct,
                            received: input
                          };
                  }), inputVar) + "}" + outputVar + "=" + inputVar + ";";
    }),
  sb: noop,
  i: 0,
  s: initialSerialize,
  j: initialSerializeToJson,
  p: intitialParse,
  a: intitialParseAsync,
  m: emptyMetadataMap
};

var metadataId$2 = "rescript-struct:Int.refinements";

function refinements$1(struct) {
  var m = Js_dict.get(struct.m, metadataId$2);
  if (m !== undefined) {
    return m;
  } else {
    return [];
  }
}

var struct$4 = {
  t: "Int",
  pb: (function (b, selfStruct, inputVar, outputVar, pathVar) {
      return "if(!(typeof " + inputVar + "===\"number\"&&" + inputVar + "<2147483648&&" + inputVar + ">-2147483649&&" + inputVar + "%1===0)){" + raiseWithArg(b, pathVar, (function (input) {
                    return {
                            TAG: "InvalidType",
                            expected: selfStruct,
                            received: input
                          };
                  }), inputVar) + "}" + outputVar + "=" + inputVar + ";";
    }),
  sb: noop,
  i: 0,
  s: initialSerialize,
  j: initialSerializeToJson,
  p: intitialParse,
  a: intitialParseAsync,
  m: emptyMetadataMap
};

function min$1(struct, maybeMessage, minValue) {
  var message = maybeMessage !== undefined ? maybeMessage : "Number must be greater than or equal to " + minValue.toString();
  var refiner = function (value) {
    if (value < minValue) {
      return fail(undefined, message);
    }
    
  };
  return addRefinement(struct, metadataId$2, {
              kind: {
                TAG: "Min",
                value: minValue
              },
              message: message
            }, refiner);
}

function max$1(struct, maybeMessage, maxValue) {
  var message = maybeMessage !== undefined ? maybeMessage : "Number must be lower than or equal to " + maxValue.toString();
  var refiner = function (value) {
    if (value > maxValue) {
      return fail(undefined, message);
    }
    
  };
  return addRefinement(struct, metadataId$2, {
              kind: {
                TAG: "Max",
                value: maxValue
              },
              message: message
            }, refiner);
}

function port(struct, messageOpt, param) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid port";
  var refiner = function (value) {
    if (value < 1 || value > 65535) {
      return fail(undefined, message);
    }
    
  };
  return addRefinement(struct, metadataId$2, {
              kind: "Port",
              message: message
            }, refiner);
}

var metadataId$3 = "rescript-struct:Float.refinements";

function refinements$2(struct) {
  var m = Js_dict.get(struct.m, metadataId$3);
  if (m !== undefined) {
    return m;
  } else {
    return [];
  }
}

var struct$5 = {
  t: "Float",
  pb: (function (b, selfStruct, inputVar, outputVar, pathVar) {
      return "if(!(typeof " + inputVar + "===\"number\"&&!Number.isNaN(" + inputVar + "))){" + raiseWithArg(b, pathVar, (function (input) {
                    return {
                            TAG: "InvalidType",
                            expected: selfStruct,
                            received: input
                          };
                  }), inputVar) + "}" + outputVar + "=" + inputVar + ";";
    }),
  sb: noop,
  i: 0,
  s: initialSerialize,
  j: initialSerializeToJson,
  p: intitialParse,
  a: intitialParseAsync,
  m: emptyMetadataMap
};

function min$2(struct, maybeMessage, minValue) {
  var message = maybeMessage !== undefined ? maybeMessage : "Number must be greater than or equal to " + minValue.toString();
  var refiner = function (value) {
    if (value < minValue) {
      return fail(undefined, message);
    }
    
  };
  return addRefinement(struct, metadataId$3, {
              kind: {
                TAG: "Min",
                value: minValue
              },
              message: message
            }, refiner);
}

function max$2(struct, maybeMessage, maxValue) {
  var message = maybeMessage !== undefined ? maybeMessage : "Number must be lower than or equal to " + maxValue.toString();
  var refiner = function (value) {
    if (value > maxValue) {
      return fail(undefined, message);
    }
    
  };
  return addRefinement(struct, metadataId$3, {
              kind: {
                TAG: "Max",
                value: maxValue
              },
              message: message
            }, refiner);
}

function factory$4(childStruct) {
  return {
          t: {
            TAG: "Null",
            _0: childStruct
          },
          pb: (function (b, param, inputVar, outputVar, pathVar) {
              var childOutputVar = $$var(b);
              var childCode = run(b, childStruct.pb, childStruct, inputVar, childOutputVar, pathVar);
              var isAsyncChild = childStruct.i;
              return "if(" + inputVar + "!==null){" + childCode + embedSyncOperation(b, childOutputVar, outputVar, pathVar, Caml_option.some, true, undefined, undefined) + "}else{" + outputVar + "=" + (
                      isAsyncChild ? "()=>Promise.resolve(void 0)" : "void 0"
                    ) + "}";
            }),
          sb: (function (b, param, inputVar, outputVar, pathVar) {
              var childOutputVar = $$var(b);
              var childCode = run(b, childStruct.sb, childStruct, inputVar, childOutputVar, pathVar);
              var value = Caml_option.valFromOption;
              return "if(" + inputVar + "!==void 0){" + inputVar + "=" + ("e[" + (b.e.push(value) - 1) + "]") + "(" + inputVar + ");" + childCode + outputVar + "=" + childOutputVar + "}else{" + outputVar + "=null}";
            }),
          i: 0,
          s: initialSerialize,
          j: initialSerializeToJson,
          p: intitialParse,
          a: intitialParseAsync,
          m: emptyMetadataMap
        };
}

function factory$5(childStruct) {
  return {
          t: {
            TAG: "Option",
            _0: childStruct
          },
          pb: (function (b, param, inputVar, outputVar, pathVar) {
              var childOutputVar = $$var(b);
              var childCode = run(b, childStruct.pb, childStruct, inputVar, childOutputVar, pathVar);
              var isChildAsync = childStruct.i;
              return "if(" + inputVar + "!==void 0){" + childCode + embedSyncOperation(b, childOutputVar, outputVar, pathVar, Caml_option.some, true, undefined, undefined) + "}else{" + outputVar + "=" + (
                      isChildAsync ? "()=>Promise.resolve(" + inputVar + ")" : inputVar
                    ) + "}";
            }),
          sb: (function (b, param, inputVar, outputVar, pathVar) {
              var childOutputVar = $$var(b);
              var childCode = run(b, childStruct.sb, childStruct, inputVar, childOutputVar, pathVar);
              var value = Caml_option.valFromOption;
              return "if(" + inputVar + "!==void 0){" + inputVar + "=" + ("e[" + (b.e.push(value) - 1) + "]") + "(" + inputVar + ");" + childCode + outputVar + "=" + childOutputVar + "}else{" + outputVar + "=void 0}";
            }),
          i: 0,
          s: initialSerialize,
          j: initialSerializeToJson,
          p: intitialParse,
          a: intitialParseAsync,
          m: emptyMetadataMap
        };
}

var metadataId$4 = "rescript-struct:Array.refinements";

function refinements$3(struct) {
  var m = Js_dict.get(struct.m, metadataId$4);
  if (m !== undefined) {
    return m;
  } else {
    return [];
  }
}

function factory$6(childStruct) {
  return {
          t: {
            TAG: "Array",
            _0: childStruct
          },
          pb: (function (b, selfStruct, inputVar, outputVar, pathVar) {
              var iteratorVar = varWithoutAllocation(b);
              var code = "if(!Array.isArray(" + inputVar + ")){" + raiseWithArg(b, pathVar, (function (input) {
                      return {
                              TAG: "InvalidType",
                              expected: selfStruct,
                              received: input
                            };
                    }), inputVar) + "}" + outputVar + "=[];for(let " + iteratorVar + "=0;" + iteratorVar + "<" + inputVar + ".length;++" + iteratorVar + "){" + varsScope(b, (function (b) {
                      var itemVar = $$var(b);
                      var childOutputVar = $$var(b);
                      var childCode = run(b, childStruct.pb, childStruct, itemVar, childOutputVar, pathVar + "+'[\"'+" + iteratorVar + "+'\"]'");
                      return itemVar + "=" + inputVar + "[" + iteratorVar + "];" + childCode + outputVar + ".push(" + childOutputVar + ")";
                    })) + "}";
              var isAsync = childStruct.i;
              if (!isAsync) {
                return code;
              }
              var syncOutputVar = $$var(b);
              return code + (syncOutputVar + "=" + outputVar + ";" + outputVar + "=()=>Promise.all(" + syncOutputVar + ".map(t=>t()));");
            }),
          sb: (function (b, param, inputVar, outputVar, pathVar) {
              var iteratorVar = varWithoutAllocation(b);
              return outputVar + "=[];for(let " + iteratorVar + "=0;" + iteratorVar + "<" + inputVar + ".length;++" + iteratorVar + "){" + varsScope(b, (function (b) {
                            var itemVar = $$var(b);
                            var childOutputVar = $$var(b);
                            var code = run(b, childStruct.sb, childStruct, itemVar, childOutputVar, pathVar + "+'[\"'+" + iteratorVar + "+'\"]'");
                            return itemVar + "=" + inputVar + "[" + iteratorVar + "];" + code + outputVar + ".push(" + childOutputVar + ")";
                          })) + "}";
            }),
          i: 0,
          s: initialSerialize,
          j: initialSerializeToJson,
          p: intitialParse,
          a: intitialParseAsync,
          m: emptyMetadataMap
        };
}

function min$3(struct, maybeMessage, length) {
  var message = maybeMessage !== undefined ? maybeMessage : "Array must be " + length.toString() + " or more items long";
  var refiner = function (value) {
    if (value.length < length) {
      return fail(undefined, message);
    }
    
  };
  return addRefinement(struct, metadataId$4, {
              kind: {
                TAG: "Min",
                length: length
              },
              message: message
            }, refiner);
}

function max$3(struct, maybeMessage, length) {
  var message = maybeMessage !== undefined ? maybeMessage : "Array must be " + length.toString() + " or fewer items long";
  var refiner = function (value) {
    if (value.length > length) {
      return fail(undefined, message);
    }
    
  };
  return addRefinement(struct, metadataId$4, {
              kind: {
                TAG: "Max",
                length: length
              },
              message: message
            }, refiner);
}

function length$1(struct, maybeMessage, length$2) {
  var message = maybeMessage !== undefined ? maybeMessage : "Array must be exactly " + length$2.toString() + " items long";
  var refiner = function (value) {
    if (value.length !== length$2) {
      return fail(undefined, message);
    }
    
  };
  return addRefinement(struct, metadataId$4, {
              kind: {
                TAG: "Length",
                length: length$2
              },
              message: message
            }, refiner);
}

function factory$7(childStruct) {
  return {
          t: {
            TAG: "Dict",
            _0: childStruct
          },
          pb: (function (b, selfStruct, inputVar, outputVar, pathVar) {
              var keyVar = varWithoutAllocation(b);
              var code = "if(!(typeof " + inputVar + "===\"object\"&&" + inputVar + "!==null&&!Array.isArray(" + inputVar + "))){" + raiseWithArg(b, pathVar, (function (input) {
                      return {
                              TAG: "InvalidType",
                              expected: selfStruct,
                              received: input
                            };
                    }), inputVar) + "}" + outputVar + "={};for(let " + keyVar + " in " + inputVar + "){" + varsScope(b, (function (b) {
                      var itemVar = $$var(b);
                      var childOutputVar = $$var(b);
                      var childCode = run(b, childStruct.pb, childStruct, itemVar, childOutputVar, pathVar + "+'[\"'+" + keyVar + "+'\"]'");
                      return itemVar + "=" + inputVar + "[" + keyVar + "];" + childCode + outputVar + "[" + keyVar + "]=" + childOutputVar;
                    })) + "}";
              var isAsync = childStruct.i;
              if (!isAsync) {
                return code;
              }
              var resolveVar = varWithoutAllocation(b);
              var rejectVar = varWithoutAllocation(b);
              var asyncParseResultVar = varWithoutAllocation(b);
              var counterVar = varWithoutAllocation(b);
              var syncOutputVar = $$var(b);
              return code + syncOutputVar + "=" + outputVar + ";" + outputVar + "=()=>new Promise((" + resolveVar + "," + rejectVar + ")=>{let " + counterVar + "=Object.keys(" + syncOutputVar + ").length;for(let " + keyVar + " in " + syncOutputVar + "){" + syncOutputVar + "[" + keyVar + "]().then(" + asyncParseResultVar + "=>{" + syncOutputVar + "[" + keyVar + "]=" + asyncParseResultVar + ";if(" + counterVar + "--===1){" + resolveVar + "(" + syncOutputVar + ")}}," + rejectVar + ")}});";
            }),
          sb: (function (b, param, inputVar, outputVar, pathVar) {
              var keyVar = varWithoutAllocation(b);
              return outputVar + "={};for(let " + keyVar + " in " + inputVar + "){" + varsScope(b, (function (b) {
                            var itemVar = $$var(b);
                            var childOutputVar = $$var(b);
                            var childCode = run(b, childStruct.sb, childStruct, itemVar, childOutputVar, pathVar + "+'[\"'+" + keyVar + "+'\"]'");
                            return itemVar + "=" + inputVar + "[" + keyVar + "];" + childCode + outputVar + "[" + keyVar + "]=" + childOutputVar;
                          })) + "}";
            }),
          i: 0,
          s: initialSerialize,
          j: initialSerializeToJson,
          p: intitialParse,
          a: intitialParseAsync,
          m: emptyMetadataMap
        };
}

var metadataId$5 = "rescript-struct:Default";

function factory$8(childStruct, getDefaultValue) {
  var childStruct$1 = factory$5(childStruct);
  return set({
              t: childStruct$1.t,
              pb: (function (b, param, inputVar, outputVar, pathVar) {
                  var childOutputVar = $$var(b);
                  var childCode = run(b, childStruct$1.pb, childStruct$1, inputVar, childOutputVar, pathVar);
                  var isChildAsync = childStruct$1.i;
                  var defaultValVar = "e[" + (b.e.push(getDefaultValue) - 1) + "]()";
                  return "if(" + inputVar + "!==void 0){" + childCode + embedSyncOperation(b, childOutputVar, outputVar, pathVar, Caml_option.some, true, undefined, undefined) + "}else{" + outputVar + "=" + (
                          isChildAsync ? "()=>Promise.resolve(" + defaultValVar + ")" : defaultValVar
                        ) + "}";
                }),
              sb: childStruct$1.sb,
              i: 0,
              s: initialSerialize,
              j: initialSerializeToJson,
              p: intitialParse,
              a: intitialParseAsync,
              m: emptyMetadataMap
            }, metadataId$5, getDefaultValue);
}

function classify$3(struct) {
  var getDefaultValue = Js_dict.get(struct.m, metadataId$5);
  if (getDefaultValue !== undefined) {
    return Caml_option.some(getDefaultValue(undefined));
  }
  
}

function factory$9(structs) {
  var numberOfStructs = structs.length;
  var len = structs.length;
  return {
          t: {
            TAG: "Tuple",
            _0: structs
          },
          pb: (function (b, selfStruct, inputVar, outputVar, pathVar) {
              var codeRef = "if(!Array.isArray(" + inputVar + ")){" + raiseWithArg(b, pathVar, (function (input) {
                      return {
                              TAG: "InvalidType",
                              expected: selfStruct,
                              received: input
                            };
                    }), inputVar) + "}if(" + inputVar + ".length!==" + numberOfStructs + "){" + raiseWithArg(b, pathVar, (function (numberOfInputItems) {
                      return {
                              TAG: "InvalidTupleSize",
                              expected: numberOfStructs,
                              received: numberOfInputItems
                            };
                    }), inputVar + ".length") + "}";
              var len = structs.length;
              if (len !== 1) {
                if (len === 0) {
                  return codeRef + (outputVar + "=void 0;");
                }
                var asyncItemVars = [];
                var syncOutputVar = $$var(b);
                codeRef = codeRef + (syncOutputVar + "=[];");
                for(var idx = 0 ,idx_finish = structs.length; idx < idx_finish; ++idx){
                  var itemStruct = structs[idx];
                  var childOutputVar = $$var(b);
                  var childCode = run(b, itemStruct.pb, itemStruct, inputVar + "[" + idx + "]", childOutputVar, pathVar + "+'[\"" + idx + "\"]'");
                  var isAsyncItem = itemStruct.i;
                  var destVar = syncOutputVar + "[" + idx + "]";
                  codeRef = codeRef + (childCode + destVar + "=" + childOutputVar + ";");
                  if (isAsyncItem) {
                    asyncItemVars.push(destVar);
                  }
                  
                }
                if (asyncItemVars.length === 0) {
                  return codeRef + (outputVar + "=" + syncOutputVar + ";");
                }
                var resolveVar = varWithoutAllocation(b);
                var rejectVar = varWithoutAllocation(b);
                var asyncParseResultVar = varWithoutAllocation(b);
                var counterVar = varWithoutAllocation(b);
                return codeRef + outputVar + "=()=>new Promise((" + resolveVar + "," + rejectVar + ")=>{let " + counterVar + "=" + asyncItemVars.length.toString() + ";" + asyncItemVars.map(function (asyncItemVar) {
                              return asyncItemVar + "().then(" + asyncParseResultVar + "=>{" + asyncItemVar + "=" + asyncParseResultVar + ";if(" + counterVar + "--===1){" + resolveVar + "(" + syncOutputVar + ")}}," + rejectVar + ")";
                            }).join(";") + "});";
              }
              var itemStruct$1 = structs[0];
              var childCode$1 = run(b, itemStruct$1.pb, itemStruct$1, inputVar + "[0]", outputVar, pathVar + "+'[\"0\"]'");
              return codeRef + childCode$1;
            }),
          sb: len !== 1 ? (
              len !== 0 ? noop : (function (_b, param, param$1, outputVar, param$2) {
                    return outputVar + "=[];";
                  })
            ) : (function (_b, param, inputVar, outputVar, param$1) {
                return outputVar + "=[" + inputVar + "];";
              }),
          i: 0,
          s: initialSerialize,
          j: initialSerializeToJson,
          p: intitialParse,
          a: intitialParseAsync,
          m: emptyMetadataMap
        };
}

function factoryFromArgs() {
  var structs = (Array.from(arguments));
  return factory$9(structs);
}

var Tuple = {
  factory: factory$9,
  factoryFromArgs: factoryFromArgs
};

function factory$10(structs) {
  if (structs.length < 2) {
    throw new Error("[rescript-struct] A Union struct factory require at least two structs.");
  }
  return {
          t: {
            TAG: "Union",
            _0: structs
          },
          pb: (function (b, selfStruct, inputVar, outputVar, pathVar) {
              var structs = selfStruct.t._0;
              var errorVars = [];
              var asyncItems = {};
              var withAsyncItemRef = false;
              var syncOutputVar = $$var(b);
              var codeRef = "";
              var codeEndRef = "";
              for(var idx = 0 ,idx_finish = structs.length; idx < idx_finish; ++idx){
                var itemStruct = structs[idx];
                var childOutputVar = $$var(b);
                var childCode = run(b, itemStruct.pb, itemStruct, inputVar, childOutputVar, "\"\"");
                var isAsyncItem = itemStruct.i;
                var errorVar = varWithoutAllocation(b);
                errorVars.push(errorVar);
                if (isAsyncItem) {
                  withAsyncItemRef = true;
                  asyncItems[idx] = childOutputVar;
                }
                codeRef = codeRef + ("try{" + childCode + (
                    isAsyncItem ? "throw " : syncOutputVar + "="
                  ) + childOutputVar + "}catch(" + errorVar + "){if(" + (errorVar + "&&" + errorVar + ".s===s") + (
                    isAsyncItem ? "||" + errorVar + "===" + childOutputVar : ""
                  ) + "){");
                codeEndRef = "}else{throw " + errorVar + "}}" + codeEndRef;
              }
              if (!withAsyncItemRef) {
                return codeRef + raiseWithArg(b, pathVar, (function (internalErrors) {
                              return {
                                      TAG: "InvalidUnion",
                                      _0: internalErrors.map(toParseError)
                                    };
                            }), "[" + errorVars.toString() + "]") + codeEndRef + (outputVar + "=" + syncOutputVar + ";");
              }
              codeRef = codeRef + (outputVar + "=()=>Promise.any([");
              for(var idx$1 = 0 ,idx_finish$1 = errorVars.length; idx$1 < idx_finish$1; ++idx$1){
                var errorVar$1 = errorVars[idx$1];
                var maybeAsyncVar = Js_dict.get(asyncItems, idx$1);
                if (idx$1 !== 0) {
                  codeRef = codeRef + ",";
                }
                if (maybeAsyncVar !== undefined) {
                  codeRef = codeRef + (errorVar$1 + "===" + maybeAsyncVar + "?" + errorVar$1 + "():");
                }
                codeRef = codeRef + ("Promise.reject(" + errorVar$1 + ")");
              }
              codeRef = codeRef + ("]).catch(t=>{" + raiseWithArg(b, pathVar, (function (internalErrors) {
                        return {
                                TAG: "InvalidUnion",
                                _0: internalErrors.map(toParseError)
                              };
                      }), "t.errors") + "})");
              return codeRef + codeEndRef + ("if(!" + outputVar + "){" + outputVar + "=()=>Promise.resolve(" + syncOutputVar + ")}");
            }),
          sb: (function (b, selfStruct, inputVar, outputVar, pathVar) {
              var structs = selfStruct.t._0;
              var errorVars = [];
              var codeRef = "";
              var codeEndRef = "";
              for(var idx = 0 ,idx_finish = structs.length; idx < idx_finish; ++idx){
                var itemStruct = structs[idx];
                var childOutputVar = $$var(b);
                var childCode = run(b, itemStruct.sb, itemStruct, inputVar, childOutputVar, "\"\"");
                var errorVar = varWithoutAllocation(b);
                errorVars.push(errorVar);
                codeRef = codeRef + ("try{" + childCode + outputVar + "=" + childOutputVar + "}catch(" + errorVar + "){if(" + (errorVar + "&&" + errorVar + ".s===s") + "){");
                codeEndRef = "}else{throw " + errorVar + "}}" + codeEndRef;
              }
              return codeRef + raiseWithArg(b, pathVar, (function (internalErrors) {
                            return {
                                    TAG: "InvalidUnion",
                                    _0: internalErrors.map(toSerializeError)
                                  };
                          }), "[" + errorVars.toString() + "]") + codeEndRef;
            }),
          i: 0,
          s: initialSerialize,
          j: initialSerializeToJson,
          p: intitialParse,
          a: intitialParseAsync,
          m: emptyMetadataMap
        };
}

function list(childStruct) {
  return transform(factory$6(childStruct), Belt_List.fromArray, undefined, Belt_List.toArray, undefined);
}

var json = {
  t: "JSON",
  pb: (function (b, selfStruct, inputVar, outputVar, pathVar) {
      var parse = function (input, path) {
        var match = typeof input;
        if (match === "string" || match === "boolean") {
          return input;
        }
        if (match === "object") {
          if (input === null) {
            return input;
          }
          if (Array.isArray(input)) {
            var output = [];
            for(var idx = 0 ,idx_finish = input.length; idx < idx_finish; ++idx){
              var inputItem = input[idx];
              var $$location = idx.toString();
              output.push(parse(inputItem, path + ("[" + JSON.stringify($$location) + "]")));
            }
            return output;
          }
          var keys = Object.keys(input);
          var output$1 = {};
          for(var idx$1 = 0 ,idx_finish$1 = keys.length; idx$1 < idx_finish$1; ++idx$1){
            var key = keys[idx$1];
            var field = input[key];
            output$1[key] = parse(field, path + ("[" + JSON.stringify(key) + "]"));
          }
          return output$1;
        }
        if (match === "number") {
          if (!Number.isNaN(input)) {
            return input;
          }
          throw {
                c: {
                  TAG: "InvalidType",
                  expected: selfStruct,
                  received: input
                },
                p: path,
                s: symbol
              };
        }
        throw {
              c: {
                TAG: "InvalidType",
                expected: selfStruct,
                received: input
              },
              p: path,
              s: symbol
            };
      };
      return outputVar + "=" + ("e[" + (b.e.push(parse) - 1) + "]") + "(" + inputVar + "," + pathVar + ");";
    }),
  sb: noop,
  i: 0,
  s: initialSerialize,
  j: initialSerializeToJson,
  p: intitialParse,
  a: intitialParseAsync,
  m: emptyMetadataMap
};

function $$catch(struct, getFallbackValue) {
  return {
          t: struct.t,
          pb: (function (b, param, inputVar, outputVar, pathVar) {
              var childOutputVar = $$var(b);
              var childCode = run(b, struct.pb, struct, inputVar, childOutputVar, pathVar);
              var isAsync = struct.i;
              var fallbackValVar = "e[" + (b.e.push(function (input, internalError) {
                      return getFallbackValue({
                                  error: toParseError(internalError),
                                  input: input
                                });
                    }) - 1) + "](" + inputVar + ",t)";
              if (isAsync) {
                return "try{" + childCode + outputVar + "=()=>{try{return " + childOutputVar + "().catch(t=>{if(t&&t.s===s){return " + fallbackValVar + "}else{throw t}})}catch(t){if(t&&t.s===s){return Promise.resolve(" + fallbackValVar + ")}else{throw t}}}}catch(t){if(t&&t.s===s){" + outputVar + "=()=>Promise.resolve(" + fallbackValVar + ")}else{throw t}}";
              } else {
                return "try{" + childCode + "}catch(t){if(t&&t.s===s){" + childOutputVar + "=" + fallbackValVar + "}else{throw t}}" + outputVar + "=" + childOutputVar + ";";
              }
            }),
          sb: struct.sb,
          i: 0,
          s: initialSerialize,
          j: initialSerializeToJson,
          p: intitialParse,
          a: intitialParseAsync,
          m: struct.m
        };
}

var deprecationMetadataId = "rescript-struct:deprecation";

function deprecate(struct, message) {
  return set(struct, deprecationMetadataId, message);
}

function deprecation(struct) {
  return Js_dict.get(struct.m, deprecationMetadataId);
}

var descriptionMetadataId = "rescript-struct:description";

function describe(struct, description) {
  return set(struct, descriptionMetadataId, description);
}

function description(struct) {
  return Js_dict.get(struct.m, descriptionMetadataId);
}

function toReason(nestedLevelOpt, error) {
  var nestedLevel = nestedLevelOpt !== undefined ? nestedLevelOpt : 0;
  var reason = error.code;
  if (typeof reason !== "object") {
    switch (reason) {
      case "MissingParser" :
          return "Struct parser is missing";
      case "MissingSerializer" :
          return "Struct serializer is missing";
      case "UnexpectedAsync" :
          return "Encountered unexpected asynchronous transform or refine. Use S.parseAsyncWith instead of S.parseWith";
      
    }
  } else {
    switch (reason.TAG) {
      case "OperationFailed" :
          return reason._0;
      case "InvalidType" :
          return "Expected " + name(reason.expected) + ", received " + toText(classify(reason.received));
      case "InvalidLiteral" :
          return "Expected " + toText(reason.expected) + ", received " + toText(classify(reason.received));
      case "InvalidTupleSize" :
          return "Expected Tuple with " + reason.expected.toString() + " items, received " + reason.received.toString();
      case "ExcessField" :
          return "Encountered disallowed excess key \"" + reason._0 + "\" on an object. Use Deprecated to ignore a specific field, or S.Object.strip to ignore excess keys completely";
      case "InvalidUnion" :
          var lineBreak = "\n" + " ".repeat((nestedLevel << 1));
          var array = reason._0.map(function (error) {
                var reason = toReason(nestedLevel + 1, error);
                var nonEmptyPath = error.path;
                var $$location = nonEmptyPath === "" ? "" : "Failed at " + nonEmptyPath + ". ";
                return "- " + $$location + reason;
              });
          var reasons = Array.from(new Set(array));
          return "Invalid union with following errors" + lineBreak + reasons.join(lineBreak);
      case "InvalidJsonStruct" :
          return "The struct " + name(reason._0) + " is not compatible with JSON";
      
    }
  }
}

function toString(error) {
  var match = error.operation;
  var operation;
  operation = match === "Serializing" ? "serializing" : "parsing";
  var reason = toReason(undefined, error);
  var nonEmptyPath = error.path;
  var pathText = nonEmptyPath === "" ? "root" : nonEmptyPath;
  return "Failed " + operation + " at " + pathText + ". Reason: " + reason;
}

function getExn(result) {
  if (result.TAG === "Ok") {
    return result._0;
  }
  var message = toString(result._0);
  throw new Error("[rescript-struct] " + message);
}

function mapErrorToString(result) {
  if (result.TAG === "Ok") {
    return result;
  } else {
    return {
            TAG: "Error",
            _0: toString(result._0)
          };
  }
}

var Result = {
  getExn: getExn,
  mapErrorToString: mapErrorToString
};

function internalInline(struct, maybeVariant, param) {
  var metadataMap = Object.assign({}, struct.m);
  var taggedLiteral = struct.t;
  var inlinedStruct;
  if (typeof taggedLiteral !== "object") {
    switch (taggedLiteral) {
      case "Never" :
          inlinedStruct = "S.never";
          break;
      case "Unknown" :
          inlinedStruct = "S.unknown";
          break;
      case "String" :
          inlinedStruct = "S.string";
          break;
      case "Int" :
          inlinedStruct = "S.int";
          break;
      case "Float" :
          inlinedStruct = "S.float";
          break;
      case "Bool" :
          inlinedStruct = "S.bool";
          break;
      case "JSON" :
          inlinedStruct = "S.json";
          break;
      
    }
  } else {
    switch (taggedLiteral.TAG) {
      case "Literal" :
          var taggedLiteral$1 = taggedLiteral._0;
          var inlinedLiteral;
          if (typeof taggedLiteral$1 !== "object") {
            switch (taggedLiteral$1) {
              case "Null" :
                  inlinedLiteral = "EmptyNull";
                  break;
              case "Undefined" :
                  inlinedLiteral = "Undefined";
                  break;
              case "NaN" :
                  inlinedLiteral = "NaN";
                  break;
              
            }
          } else {
            switch (taggedLiteral$1.TAG) {
              case "String" :
                  inlinedLiteral = "String(" + JSON.stringify(taggedLiteral$1._0) + ")";
                  break;
              case "Number" :
                  var $$float = taggedLiteral$1._0;
                  inlinedLiteral = "Number(" + ($$float.toString() + (
                      $$float % 1 === 0 ? "." : ""
                    )) + ")";
                  break;
              case "Boolean" :
                  inlinedLiteral = "Bool(" + taggedLiteral$1._0.toString() + ")";
                  break;
              default:
                inlinedLiteral = "NaN";
            }
          }
          inlinedStruct = maybeVariant !== undefined ? "S.literalVariant(" + inlinedLiteral + ", " + maybeVariant + ")" : "S.literal(" + inlinedLiteral + ")";
          break;
      case "Option" :
          var internalInlinedStruct = internalInline(taggedLiteral._0, undefined, undefined);
          var defaultValue = classify$3(struct);
          if (defaultValue !== undefined) {
            var defaultValue$1 = Caml_option.valFromOption(defaultValue);
            Js_dict.unsafeDeleteKey(metadataMap, metadataId$5);
            inlinedStruct = internalInlinedStruct + ("->S.default(() => %raw(\`" + (
                defaultValue$1 === (void 0) ? "undefined" : JSON.stringify(defaultValue$1)
              ) + "\`))");
          } else {
            inlinedStruct = "S.option(" + internalInlinedStruct + ")";
          }
          break;
      case "Null" :
          inlinedStruct = "S.null(" + internalInline(taggedLiteral._0, undefined, undefined) + ")";
          break;
      case "Array" :
          inlinedStruct = "S.array(" + internalInline(taggedLiteral._0, undefined, undefined) + ")";
          break;
      case "Object" :
          var fieldNames = taggedLiteral.fieldNames;
          var fields = taggedLiteral.fields;
          inlinedStruct = fieldNames.length !== 0 ? "S.object(o =>\n  {\n    " + fieldNames.map(function (fieldName) {
                    return JSON.stringify(fieldName) + ": o.field(" + JSON.stringify(fieldName) + ", " + internalInline(fields[fieldName], undefined, undefined) + ")";
                  }).join(",\n    ") + ",\n  }\n)" : "S.object(_ => ())";
          break;
      case "Tuple" :
          var tupleStructs = taggedLiteral._0;
          if (tupleStructs.length !== 0) {
            var numberOfItems = tupleStructs.length;
            if (numberOfItems > 10) {
              throw new Error("[rescript-struct] The S.inline doesn't support tuples with more than 10 items.");
            }
            inlinedStruct = "S.tuple" + numberOfItems.toString() + "(. " + tupleStructs.map(function (s) {
                    return internalInline(s, undefined, undefined);
                  }).join(", ") + ")";
          } else {
            inlinedStruct = "S.tuple0(.)";
          }
          break;
      case "Union" :
          var variantNamesCounter = {};
          inlinedStruct = "S.union([" + taggedLiteral._0.map(function (s) {
                  var variantName = name(s);
                  var n = Js_dict.get(variantNamesCounter, variantName);
                  var numberOfVariantNames = n !== undefined ? n : 0;
                  variantNamesCounter[variantName] = numberOfVariantNames + 1;
                  var variantName$1 = numberOfVariantNames !== 0 ? variantName + (numberOfVariantNames + 1).toString() : variantName;
                  var inlinedVariant = "#" + JSON.stringify(variantName$1);
                  return internalInline(s, inlinedVariant, undefined);
                }).join(", ") + "])";
          break;
      case "Dict" :
          inlinedStruct = "S.dict(" + internalInline(taggedLiteral._0, undefined, undefined) + ")";
          break;
      
    }
  }
  var message = deprecation(struct);
  var inlinedStruct$1 = message !== undefined ? (Js_dict.unsafeDeleteKey(metadataMap, deprecationMetadataId), inlinedStruct + ("->S.deprecate(" + JSON.stringify(message) + ")")) : inlinedStruct;
  var message$1 = description(struct);
  var inlinedStruct$2 = message$1 !== undefined ? (Js_dict.unsafeDeleteKey(metadataMap, descriptionMetadataId), inlinedStruct$1 + ("->S.describe(" + (
          message$1 === (void 0) ? "undefined" : JSON.stringify(message$1)
        ) + ")")) : inlinedStruct$1;
  var match = classify$2(struct);
  var inlinedStruct$3;
  inlinedStruct$3 = match === "Strict" ? inlinedStruct$2 + "->S.Object.strict" : inlinedStruct$2;
  Js_dict.unsafeDeleteKey(metadataMap, metadataId);
  var match$1 = struct.t;
  var inlinedStruct$4;
  var exit = 0;
  if (typeof match$1 !== "object") {
    switch (match$1) {
      case "String" :
          exit = 1;
          break;
      case "Int" :
          var refinements$4 = refinements$1(struct);
          if (refinements$4.length !== 0) {
            Js_dict.unsafeDeleteKey(metadataMap, metadataId$2);
            inlinedStruct$4 = inlinedStruct$3 + refinements$4.map(function (refinement) {
                    var match = refinement.kind;
                    if (typeof match !== "object") {
                      return "->S.Int.port(~message=" + JSON.stringify(refinement.message) + ", ())";
                    } else if (match.TAG === "Min") {
                      return "->S.Int.min(~message=" + JSON.stringify(refinement.message) + ", " + match.value.toString() + ")";
                    } else {
                      return "->S.Int.max(~message=" + JSON.stringify(refinement.message) + ", " + match.value.toString() + ")";
                    }
                  }).join("");
          } else {
            inlinedStruct$4 = inlinedStruct$3;
          }
          break;
      case "Float" :
          var refinements$5 = refinements$2(struct);
          if (refinements$5.length !== 0) {
            Js_dict.unsafeDeleteKey(metadataMap, metadataId$3);
            inlinedStruct$4 = inlinedStruct$3 + refinements$5.map(function (refinement) {
                    var match = refinement.kind;
                    if (match.TAG === "Min") {
                      var value = match.value;
                      return "->S.Float.min(~message=" + JSON.stringify(refinement.message) + ", " + (value.toString() + (
                                value % 1 === 0 ? "." : ""
                              )) + ")";
                    }
                    var value$1 = match.value;
                    return "->S.Float.max(~message=" + JSON.stringify(refinement.message) + ", " + (value$1.toString() + (
                              value$1 % 1 === 0 ? "." : ""
                            )) + ")";
                  }).join("");
          } else {
            inlinedStruct$4 = inlinedStruct$3;
          }
          break;
      default:
        inlinedStruct$4 = inlinedStruct$3;
    }
  } else {
    switch (match$1.TAG) {
      case "Literal" :
          var tmp = match$1._0;
          if (typeof tmp !== "object" || tmp.TAG !== "String") {
            inlinedStruct$4 = inlinedStruct$3;
          } else {
            exit = 1;
          }
          break;
      case "Array" :
          var refinements$6 = refinements$3(struct);
          if (refinements$6.length !== 0) {
            Js_dict.unsafeDeleteKey(metadataMap, metadataId$4);
            inlinedStruct$4 = inlinedStruct$3 + refinements$6.map(function (refinement) {
                    var match = refinement.kind;
                    switch (match.TAG) {
                      case "Min" :
                          return "->S.Array.min(~message=" + JSON.stringify(refinement.message) + ", " + match.length.toString() + ")";
                      case "Max" :
                          return "->S.Array.max(~message=" + JSON.stringify(refinement.message) + ", " + match.length.toString() + ")";
                      case "Length" :
                          return "->S.Array.length(~message=" + JSON.stringify(refinement.message) + ", " + match.length.toString() + ")";
                      
                    }
                  }).join("");
          } else {
            inlinedStruct$4 = inlinedStruct$3;
          }
          break;
      default:
        inlinedStruct$4 = inlinedStruct$3;
    }
  }
  if (exit === 1) {
    var refinements$7 = refinements(struct);
    if (refinements$7.length !== 0) {
      Js_dict.unsafeDeleteKey(metadataMap, metadataId$1);
      inlinedStruct$4 = inlinedStruct$3 + refinements$7.map(function (refinement) {
              var match = refinement.kind;
              if (typeof match !== "object") {
                switch (match) {
                  case "Email" :
                      return "->S.String.email(~message=" + JSON.stringify(refinement.message) + ", ())";
                  case "Uuid" :
                      return "->S.String.uuid(~message=" + JSON.stringify(refinement.message) + ", ())";
                  case "Cuid" :
                      return "->S.String.cuid(~message=" + JSON.stringify(refinement.message) + ", ())";
                  case "Url" :
                      return "->S.String.url(~message=" + JSON.stringify(refinement.message) + ", ())";
                  case "Datetime" :
                      return "->S.String.datetime(~message=" + JSON.stringify(refinement.message) + ", ())";
                  
                }
              } else {
                switch (match.TAG) {
                  case "Min" :
                      return "->S.String.min(~message=" + JSON.stringify(refinement.message) + ", " + match.length.toString() + ")";
                  case "Max" :
                      return "->S.String.max(~message=" + JSON.stringify(refinement.message) + ", " + match.length.toString() + ")";
                  case "Length" :
                      return "->S.String.length(~message=" + JSON.stringify(refinement.message) + ", " + match.length.toString() + ")";
                  case "Pattern" :
                      return "->S.String.pattern(~message=" + JSON.stringify(refinement.message) + ", %re(" + JSON.stringify(match.re.toString()) + "))";
                  
                }
              }
            }).join("");
    } else {
      inlinedStruct$4 = inlinedStruct$3;
    }
  }
  var inlinedStruct$5 = Object.keys(metadataMap).length !== 0 ? "{\n  let s = " + inlinedStruct$4 + "\n  let _ = %raw(\`s.m = " + JSON.stringify(metadataMap) + "\`)\n  s\n}" : inlinedStruct$4;
  var match$2 = struct.t;
  if (typeof match$2 === "object" && match$2.TAG === "Literal") {
    return inlinedStruct$5;
  }
  if (maybeVariant !== undefined) {
    return inlinedStruct$5 + ("->S.variant(v => " + maybeVariant + "(v))");
  } else {
    return inlinedStruct$5;
  }
}

function inline(struct) {
  return internalInline(struct, undefined, undefined);
}

var unit = factory((void 0));

function tuple0() {
  return factory$9([]);
}

function tuple1(v0) {
  return factory$9([v0]);
}

function tuple2(v0, v1) {
  return factory$9([
              v0,
              v1
            ]);
}

function tuple3(v0, v1, v2) {
  return factory$9([
              v0,
              v1,
              v2
            ]);
}

var Path = {
  empty: "",
  toArray: toArray,
  fromArray: fromArray,
  fromLocation: fromLocation,
  concat: concat
};

var $$Error$1 = {
  toString: toString
};

var never = struct;

var unknown = struct$1;

var string = struct$2;

var bool = struct$3;

var $$int = struct$4;

var $$float = struct$5;

var literal = factory;

var array = factory$6;

var dict = factory$7;

var option = factory$5;

var $$null = factory$4;

var jsonString = factory$3;

var union = factory$10;

var $$default = factory$8;

var variant = factory$1;

var parseWith = parseAnyWith;

var parseOrRaiseWith = parseAnyOrRaiseWith;

var parseAsyncWith = parseAnyAsyncWith;

var parseAsyncInStepsWith = parseAnyAsyncInStepsWith;

var Object_UnknownKeys = {
  classify: classify$2
};

var $$Object = {
  UnknownKeys: Object_UnknownKeys,
  factory: factory$2,
  strip: strip,
  strict: strict
};

var object = factory$2;

var tuple4 = factoryFromArgs;

var tuple5 = factoryFromArgs;

var tuple6 = factoryFromArgs;

var tuple7 = factoryFromArgs;

var tuple8 = factoryFromArgs;

var tuple9 = factoryFromArgs;

var tuple10 = factoryFromArgs;

var String_Refinement = {};

var $$String = {
  Refinement: String_Refinement,
  refinements: refinements,
  min: min,
  max: max,
  length: length,
  email: email,
  uuid: uuid,
  cuid: cuid,
  url: url,
  pattern: pattern,
  datetime: datetime,
  trim: trim
};

var Int_Refinement = {};

var Int = {
  Refinement: Int_Refinement,
  refinements: refinements$1,
  min: min$1,
  max: max$1,
  port: port
};

var Float_Refinement = {};

var Float = {
  Refinement: Float_Refinement,
  refinements: refinements$2,
  min: min$2,
  max: max$2
};

var Array_Refinement = {};

var $$Array = {
  Refinement: Array_Refinement,
  refinements: refinements$3,
  min: min$3,
  max: max$3,
  length: length$1
};

var Default = {
  classify: classify$3
};

var Metadata = {
  Id: Id,
  get: get,
  set: set
};

export {
  Path ,
  $$Error$1 as $$Error,
  Raised ,
  never ,
  unknown ,
  unit ,
  string ,
  bool ,
  $$int ,
  $$float ,
  json ,
  literal ,
  array ,
  list ,
  dict ,
  option ,
  $$null ,
  jsonString ,
  union ,
  $$default ,
  $$default as default,
  $$catch ,
  describe ,
  description ,
  deprecate ,
  deprecation ,
  transform ,
  advancedTransform ,
  advancedPreprocess ,
  custom ,
  refine ,
  variant ,
  parseWith ,
  parseAnyWith ,
  parseJsonStringWith ,
  parseOrRaiseWith ,
  parseAnyOrRaiseWith ,
  parseAsyncWith ,
  parseAnyAsyncWith ,
  parseAsyncInStepsWith ,
  parseAnyAsyncInStepsWith ,
  serializeWith ,
  serializeToUnknownWith ,
  serializeToJsonStringWith ,
  serializeOrRaiseWith ,
  serializeToUnknownOrRaiseWith ,
  isAsyncParse ,
  recursive ,
  classify$1 as classify,
  name ,
  setName ,
  fail ,
  advancedFail ,
  $$Object ,
  object ,
  Tuple ,
  tuple0 ,
  tuple1 ,
  tuple2 ,
  tuple3 ,
  tuple4 ,
  tuple5 ,
  tuple6 ,
  tuple7 ,
  tuple8 ,
  tuple9 ,
  tuple10 ,
  $$String ,
  Int ,
  Float ,
  $$Array ,
  Default ,
  Result ,
  Metadata ,
  inline ,
}
/* symbol Not a pure module */
