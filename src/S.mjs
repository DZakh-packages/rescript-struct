// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Js_types from "rescript/lib/es6/js_types.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

var Exception = /* @__PURE__ */Caml_exceptions.create("S.Error.Internal.Exception");

function raise(code) {
  throw {
        RE_EXN_ID: Exception,
        _1: {
          code: code,
          path: []
        },
        Error: new Error()
      };
}

function toParseError(internalError) {
  return {
          operation: /* Parsing */1,
          code: internalError.code,
          path: internalError.path
        };
}

function toSerializeError(internalError) {
  return {
          operation: /* Serializing */0,
          code: internalError.code,
          path: internalError.path
        };
}

function prependLocation(error, $$location) {
  return {
          code: error.code,
          path: [$$location].concat(error.path)
        };
}

function stringify(any) {
  if (any === undefined) {
    return "undefined";
  }
  var string = JSON.stringify(Caml_option.valFromOption(any));
  if (string !== undefined) {
    return string;
  } else {
    return "???";
  }
}

function raise$1(expected, received) {
  return raise({
              TAG: /* UnexpectedValue */2,
              expected: stringify(expected),
              received: stringify(received)
            });
}

function panic($$location) {
  throw new Error("[rescript-struct] " + ("For a " + $$location + " either a parser, or a serializer is required") + "");
}

function panic$1(param) {
  throw new Error("[rescript-struct] Unreachable");
}

function panic$2(param) {
  throw new Error("[rescript-struct] A Union struct factory require at least two structs");
}

function formatPath(path) {
  if (path.length === 0) {
    return "root";
  } else {
    return path.map(function (pathItem) {
                  return "[" + pathItem + "]";
                }).join("");
  }
}

function prependLocation$1(error, $$location) {
  return {
          operation: error.operation,
          code: error.code,
          path: [$$location].concat(error.path)
        };
}

function raiseCustom(error) {
  throw {
        RE_EXN_ID: Exception,
        _1: error,
        Error: new Error()
      };
}

function raise$2(message) {
  throw {
        RE_EXN_ID: Exception,
        _1: {
          code: {
            TAG: /* OperationFailed */0,
            _0: message
          },
          path: []
        },
        Error: new Error()
      };
}

function toReason(nestedLevelOpt, error) {
  var nestedLevel = nestedLevelOpt !== undefined ? nestedLevelOpt : 0;
  var reason = error.code;
  if (typeof reason === "number") {
    switch (reason) {
      case /* MissingParser */0 :
          return "Struct parser is missing";
      case /* MissingSerializer */1 :
          return "Struct serializer is missing";
      case /* UnexpectedAsync */2 :
          return "Encountered unexpected asynchronous transform or refine. Use parseAsyncWith instead of parseWith";
      
    }
  } else {
    switch (reason.TAG | 0) {
      case /* OperationFailed */0 :
          return reason._0;
      case /* UnexpectedType */1 :
      case /* UnexpectedValue */2 :
          break;
      case /* TupleSize */3 :
          return "Expected Tuple with " + reason.expected.toString() + " items, received " + reason.received.toString() + "";
      case /* ExcessField */4 :
          return "Encountered disallowed excess key \"" + reason._0 + "\" on an object. Use Deprecated to ignore a specific field, or S.Object.strip to ignore excess keys completely";
      case /* InvalidUnion */5 :
          var lineBreak = "\n" + " ".repeat((nestedLevel << 1)) + "";
          var array = reason._0.map(function (error) {
                var reason = toReason(nestedLevel + 1, error);
                var nonEmptyPath = error.path;
                var $$location = nonEmptyPath.length !== 0 ? "Failed at " + formatPath(nonEmptyPath) + ". " : "";
                return "- " + $$location + "" + reason + "";
              });
          var reasons = Array.from(new Set(array));
          return "Invalid union with following errors" + lineBreak + "" + reasons.join(lineBreak) + "";
      
    }
  }
  return "Expected " + reason.expected + ", received " + reason.received + "";
}

function toString(error) {
  var match = error.operation;
  var operation = match ? "parsing" : "serializing";
  var reason = toReason(undefined, error);
  var pathText = formatPath(error.path);
  return "Failed " + operation + " at " + pathText + ". Reason: " + reason + "";
}

var Raised = /* @__PURE__ */Caml_exceptions.create("S.Raised");

function planAsyncMigration(ctx, migration) {
  if (ctx.i === -1) {
    ctx.i = ctx.m.length;
  }
  ctx.m.push(migration);
}

function planMissingParserMigration(ctx) {
  ctx.m.push(function (param) {
        return raise(/* MissingParser */0);
      });
}

function planMissingSerializerMigration(ctx) {
  ctx.m.push(function (param) {
        return raise(/* MissingSerializer */1);
      });
}

function empty(param, param$1) {
  
}

function compile(migrationFactory, struct) {
  var ctx = {
    m: [],
    i: -1
  };
  migrationFactory(ctx, struct);
  var migrations = ctx.m;
  var firstAsyncMigrationIdx = ctx.i;
  if (migrations.length === 0) {
    return /* NoopOperation */0;
  }
  var lastMigrationIdx = migrations.length - 1 | 0;
  var lastSyncMigrationIdx = firstAsyncMigrationIdx === -1 ? lastMigrationIdx : firstAsyncMigrationIdx - 1 | 0;
  var syncOperation = lastSyncMigrationIdx < 1 ? migrations[0] : (function (input) {
        var tempOuputRef = input;
        for(var idx = 0; idx <= lastSyncMigrationIdx; ++idx){
          var migration = migrations[idx];
          var newValue = migration(tempOuputRef);
          tempOuputRef = newValue;
        }
        return tempOuputRef;
      });
  if (firstAsyncMigrationIdx === -1) {
    return {
            TAG: /* SyncOperation */0,
            _0: syncOperation
          };
  } else {
    return {
            TAG: /* AsyncOperation */1,
            _0: (function (input) {
                var syncOutput = firstAsyncMigrationIdx !== 0 ? syncOperation(input) : input;
                return function () {
                  var tempOuputRef = Promise.resolve(syncOutput);
                  for(var idx = firstAsyncMigrationIdx; idx <= lastMigrationIdx; ++idx){
                    var migration = migrations[idx];
                    tempOuputRef = tempOuputRef.then(migration);
                  }
                  return tempOuputRef;
                };
              })
          };
  }
}

function classify(struct) {
  return struct.t;
}

function name(struct) {
  return struct.n;
}

function isAsyncParse(struct) {
  var match = struct.p;
  if (typeof match === "number" || match.TAG === /* SyncOperation */0) {
    return false;
  } else {
    return true;
  }
}

function raiseUnexpectedTypeError(input, struct) {
  var number = Js_types.classify(input);
  var tmp;
  if (typeof number === "number") {
    switch (number) {
      case /* JSFalse */0 :
      case /* JSTrue */1 :
          tmp = "Bool";
          break;
      case /* JSNull */2 :
          tmp = "Null";
          break;
      case /* JSUndefined */3 :
          tmp = "Option";
          break;
      
    }
  } else {
    switch (number.TAG | 0) {
      case /* JSNumber */0 :
          tmp = Number.isNaN(number._0) ? "NaN Literal (NaN)" : "Float";
          break;
      case /* JSString */1 :
          tmp = "String";
          break;
      case /* JSFunction */2 :
          tmp = "Function";
          break;
      case /* JSObject */3 :
          tmp = "Object";
          break;
      case /* JSSymbol */4 :
          tmp = "Symbol";
          break;
      case /* JSBigInt */5 :
          tmp = "BigInt";
          break;
      
    }
  }
  return raise({
              TAG: /* UnexpectedType */1,
              expected: struct.n,
              received: tmp
            });
}

function make(name, tagged, parseMigrationFactory, serializeMigrationFactory, maybeMetadataDict, param) {
  var struct_s = undefined;
  var struct_p = undefined;
  var struct = {
    n: name,
    t: tagged,
    pf: parseMigrationFactory,
    sf: serializeMigrationFactory,
    s: struct_s,
    p: struct_p,
    m: maybeMetadataDict
  };
  return {
          n: name,
          t: tagged,
          pf: parseMigrationFactory,
          sf: serializeMigrationFactory,
          s: compile(serializeMigrationFactory, struct),
          p: compile(parseMigrationFactory, struct),
          m: maybeMetadataDict
        };
}

function parseWith(any, struct) {
  try {
    var fn = struct.p;
    if (typeof fn === "number") {
      return {
              TAG: /* Ok */0,
              _0: any
            };
    } else if (fn.TAG === /* SyncOperation */0) {
      return {
              TAG: /* Ok */0,
              _0: fn._0(any)
            };
    } else {
      return raise(/* UnexpectedAsync */2);
    }
  }
  catch (raw_internalError){
    var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
    if (internalError.RE_EXN_ID === Exception) {
      return {
              TAG: /* Error */1,
              _0: toParseError(internalError._1)
            };
    }
    throw internalError;
  }
}

function parseOrRaiseWith(any, struct) {
  try {
    var fn = struct.p;
    if (typeof fn === "number") {
      return any;
    } else if (fn.TAG === /* SyncOperation */0) {
      return fn._0(any);
    } else {
      return raise(/* UnexpectedAsync */2);
    }
  }
  catch (raw_internalError){
    var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
    if (internalError.RE_EXN_ID === Exception) {
      throw {
            RE_EXN_ID: Raised,
            _1: toParseError(internalError._1),
            Error: new Error()
          };
    }
    throw internalError;
  }
}

function parseAsyncWith(any, struct) {
  try {
    var fn = struct.p;
    if (typeof fn === "number") {
      return Promise.resolve({
                  TAG: /* Ok */0,
                  _0: any
                });
    } else if (fn.TAG === /* SyncOperation */0) {
      return Promise.resolve({
                  TAG: /* Ok */0,
                  _0: fn._0(any)
                });
    } else {
      return fn._0(any)().then(function (value) {
                    return {
                            TAG: /* Ok */0,
                            _0: value
                          };
                  }).catch(function (exn) {
                  if (exn.RE_EXN_ID === Exception) {
                    return {
                            TAG: /* Error */1,
                            _0: toParseError(exn._1)
                          };
                  }
                  throw exn;
                });
    }
  }
  catch (raw_internalError){
    var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
    if (internalError.RE_EXN_ID === Exception) {
      return Promise.resolve({
                  TAG: /* Error */1,
                  _0: toParseError(internalError._1)
                });
    }
    throw internalError;
  }
}

function parseAsyncInStepsWith(any, struct) {
  try {
    var fn = struct.p;
    var tmp;
    if (typeof fn === "number") {
      tmp = (function (param) {
          return Promise.resolve({
                      TAG: /* Ok */0,
                      _0: any
                    });
        });
    } else if (fn.TAG === /* SyncOperation */0) {
      var syncValue = fn._0(any);
      tmp = (function (param) {
          return Promise.resolve({
                      TAG: /* Ok */0,
                      _0: syncValue
                    });
        });
    } else {
      var asyncFn = fn._0(any);
      tmp = (function (param) {
          return asyncFn().then(function (value) {
                        return {
                                TAG: /* Ok */0,
                                _0: value
                              };
                      }).catch(function (exn) {
                      if (exn.RE_EXN_ID === Exception) {
                        return {
                                TAG: /* Error */1,
                                _0: toParseError(exn._1)
                              };
                      }
                      throw exn;
                    });
        });
    }
    return {
            TAG: /* Ok */0,
            _0: tmp
          };
  }
  catch (raw_internalError){
    var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
    if (internalError.RE_EXN_ID === Exception) {
      return {
              TAG: /* Error */1,
              _0: toParseError(internalError._1)
            };
    }
    throw internalError;
  }
}

function serializeWith(value, struct) {
  try {
    var fn = struct.s;
    var tmp;
    tmp = typeof fn === "number" ? value : (
        fn.TAG === /* SyncOperation */0 ? fn._0(value) : panic$1(undefined)
      );
    return {
            TAG: /* Ok */0,
            _0: tmp
          };
  }
  catch (raw_internalError){
    var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
    if (internalError.RE_EXN_ID === Exception) {
      return {
              TAG: /* Error */1,
              _0: toSerializeError(internalError._1)
            };
    }
    throw internalError;
  }
}

function serializeOrRaiseWith(value, struct) {
  try {
    var fn = struct.s;
    if (typeof fn === "number") {
      return value;
    } else if (fn.TAG === /* SyncOperation */0) {
      return fn._0(value);
    } else {
      return panic$1(undefined);
    }
  }
  catch (raw_internalError){
    var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
    if (internalError.RE_EXN_ID === Exception) {
      throw {
            RE_EXN_ID: Raised,
            _1: toSerializeError(internalError._1),
            Error: new Error()
          };
    }
    throw internalError;
  }
}

function make$1(namespace, name) {
  return "" + namespace + ":" + name + "";
}

var Id = {
  make: make$1
};

function get(struct, id) {
  var option = struct.m;
  if (option !== undefined) {
    return Js_dict.get(Caml_option.valFromOption(option), id);
  }
  
}

function set(struct, id, metadata, withParserUpdate, withSerializerUpdate) {
  var metadataChange = {};
  var structWithNewMetadata_n = struct.n;
  var structWithNewMetadata_t = struct.t;
  var structWithNewMetadata_pf = struct.pf;
  var structWithNewMetadata_sf = struct.sf;
  var structWithNewMetadata_s = struct.s;
  var structWithNewMetadata_p = struct.p;
  var structWithNewMetadata_m = Caml_option.some(Object.assign({}, struct.m, (metadataChange[id] = metadata, metadataChange)));
  var structWithNewMetadata = {
    n: structWithNewMetadata_n,
    t: structWithNewMetadata_t,
    pf: structWithNewMetadata_pf,
    sf: structWithNewMetadata_sf,
    s: structWithNewMetadata_s,
    p: structWithNewMetadata_p,
    m: structWithNewMetadata_m
  };
  if (!withParserUpdate && !withSerializerUpdate) {
    return structWithNewMetadata;
  }
  return {
          n: structWithNewMetadata_n,
          t: structWithNewMetadata_t,
          pf: structWithNewMetadata_pf,
          sf: structWithNewMetadata_sf,
          s: withSerializerUpdate ? compile(structWithNewMetadata_sf, structWithNewMetadata) : structWithNewMetadata_s,
          p: withParserUpdate ? compile(structWithNewMetadata_pf, structWithNewMetadata) : structWithNewMetadata_p,
          m: structWithNewMetadata_m
        };
}

function refine(struct, maybeRefineParser, maybeRefineSerializer, param) {
  if (maybeRefineParser === undefined && maybeRefineSerializer === undefined) {
    panic("struct factory Refine");
  }
  return make(struct.n, struct.t, maybeRefineParser !== undefined ? (function (ctx, compilingStruct) {
                  struct.pf(ctx, compilingStruct);
                  ctx.m.push(function (input) {
                        maybeRefineParser(input);
                        return input;
                      });
                }) : struct.pf, maybeRefineSerializer !== undefined ? (function (ctx, compilingStruct) {
                  ctx.m.push(function (input) {
                        maybeRefineSerializer(input);
                        return input;
                      });
                  struct.sf(ctx, compilingStruct);
                }) : struct.sf, struct.m, undefined);
}

function asyncRefine(struct, parser, param) {
  return make(struct.n, struct.t, (function (ctx, compilingStruct) {
                struct.pf(ctx, compilingStruct);
                planAsyncMigration(ctx, (function (input) {
                        return parser(input).then(function (param) {
                                    return input;
                                  });
                      }));
              }), struct.sf, struct.m, undefined);
}

function transform(struct, maybeTransformParser, maybeTransformSerializer, param) {
  if (maybeTransformParser === undefined && maybeTransformSerializer === undefined) {
    panic("struct factory Transform");
  }
  return make(struct.n, struct.t, (function (ctx, compilingStruct) {
                struct.pf(ctx, compilingStruct);
                if (maybeTransformParser !== undefined) {
                  ctx.m.push(maybeTransformParser);
                  return ;
                } else {
                  return planMissingParserMigration(ctx);
                }
              }), (function (ctx, compilingStruct) {
                if (maybeTransformSerializer !== undefined) {
                  ctx.m.push(maybeTransformSerializer);
                } else {
                  planMissingSerializerMigration(ctx);
                }
                struct.sf(ctx, compilingStruct);
              }), struct.m, undefined);
}

function advancedTransform(struct, maybeTransformParser, maybeTransformSerializer, param) {
  if (maybeTransformParser === undefined && maybeTransformSerializer === undefined) {
    panic("struct factory Transform");
  }
  return make(struct.n, struct.t, (function (ctx, compilingStruct) {
                struct.pf(ctx, compilingStruct);
                if (maybeTransformParser === undefined) {
                  return planMissingParserMigration(ctx);
                }
                var syncMigration = maybeTransformParser(compilingStruct);
                if (syncMigration.TAG !== /* Sync */0) {
                  return planAsyncMigration(ctx, syncMigration._0);
                }
                ctx.m.push(syncMigration._0);
              }), (function (ctx, compilingStruct) {
                if (maybeTransformSerializer !== undefined) {
                  var syncMigration = maybeTransformSerializer(compilingStruct);
                  if (syncMigration.TAG === /* Sync */0) {
                    ctx.m.push(syncMigration._0);
                  } else {
                    planAsyncMigration(ctx, syncMigration._0);
                  }
                } else {
                  planMissingSerializerMigration(ctx);
                }
                struct.sf(ctx, compilingStruct);
              }), struct.m, undefined);
}

function advancedPreprocess(struct, maybePreprocessParser, maybePreprocessSerializer, param) {
  if (maybePreprocessParser === undefined && maybePreprocessSerializer === undefined) {
    panic("struct factory Preprocess");
  }
  var unionStructs = struct.t;
  if (typeof unionStructs !== "number" && unionStructs.TAG === /* Union */5) {
    return make(struct.n, {
                TAG: /* Union */5,
                _0: unionStructs._0.map(function (unionStruct) {
                      return advancedPreprocess(unionStruct, maybePreprocessParser, maybePreprocessSerializer, undefined);
                    })
              }, struct.pf, struct.sf, struct.m, undefined);
  }
  return make(struct.n, struct.t, (function (ctx, compilingStruct) {
                if (maybePreprocessParser !== undefined) {
                  var syncMigration = maybePreprocessParser(compilingStruct);
                  if (syncMigration.TAG === /* Sync */0) {
                    ctx.m.push(syncMigration._0);
                  } else {
                    planAsyncMigration(ctx, syncMigration._0);
                  }
                } else {
                  planMissingParserMigration(ctx);
                }
                struct.pf(ctx, compilingStruct);
              }), (function (ctx, compilingStruct) {
                struct.sf(ctx, compilingStruct);
                if (maybePreprocessSerializer === undefined) {
                  return planMissingSerializerMigration(ctx);
                }
                var syncMigration = maybePreprocessSerializer(compilingStruct);
                if (syncMigration.TAG !== /* Sync */0) {
                  return planAsyncMigration(ctx, syncMigration._0);
                }
                ctx.m.push(syncMigration._0);
              }), struct.m, undefined);
}

function custom(name, maybeCustomParser, maybeCustomSerializer, param) {
  if (maybeCustomParser === undefined && maybeCustomSerializer === undefined) {
    panic("Custom struct factory");
  }
  return make(name, /* Unknown */1, (function (ctx, param) {
                if (maybeCustomParser !== undefined) {
                  ctx.m.push(Caml_option.valFromOption(maybeCustomParser));
                  return ;
                } else {
                  return planMissingParserMigration(ctx);
                }
              }), (function (ctx, param) {
                if (maybeCustomSerializer !== undefined) {
                  ctx.m.push(Caml_option.valFromOption(maybeCustomSerializer));
                  return ;
                } else {
                  return planMissingSerializerMigration(ctx);
                }
              }), undefined, undefined);
}

var metadataId = "rescript-struct:Literal";

function classify$1(struct) {
  return get(struct, metadataId);
}

function factory(innerLiteral, variant) {
  var makeParseMigrationFactory = function (literalValue, test) {
    return function (ctx, struct) {
      ctx.m.push(function (input) {
            if (test(input)) {
              if (literalValue === input) {
                return variant;
              } else {
                return raise$1(literalValue, input);
              }
            } else {
              return raiseUnexpectedTypeError(input, struct);
            }
          });
    };
  };
  var makeSerializeMigrationFactory = function (output) {
    return function (ctx, param) {
      ctx.m.push(function (input) {
            if (input === variant) {
              return output;
            } else {
              return raise$1(variant, input);
            }
          });
    };
  };
  var tmp;
  if (typeof innerLiteral === "number") {
    switch (innerLiteral) {
      case /* EmptyNull */0 :
          tmp = make("EmptyNull Literal (null)", /* Literal */6, (function (ctx, struct) {
                  ctx.m.push(function (input) {
                        if (input === null) {
                          return variant;
                        } else {
                          return raiseUnexpectedTypeError(input, struct);
                        }
                      });
                }), makeSerializeMigrationFactory(null), undefined, undefined);
          break;
      case /* EmptyOption */1 :
          tmp = make("EmptyOption Literal (undefined)", /* Literal */6, (function (ctx, struct) {
                  ctx.m.push(function (input) {
                        if (input === undefined) {
                          return variant;
                        } else {
                          return raiseUnexpectedTypeError(input, struct);
                        }
                      });
                }), makeSerializeMigrationFactory(undefined), undefined, undefined);
          break;
      case /* NaN */2 :
          tmp = make("NaN Literal (NaN)", /* Literal */6, (function (ctx, struct) {
                  ctx.m.push(function (input) {
                        if (Number.isNaN(input)) {
                          return variant;
                        } else {
                          return raiseUnexpectedTypeError(input, struct);
                        }
                      });
                }), makeSerializeMigrationFactory(NaN), undefined, undefined);
          break;
      
    }
  } else {
    switch (innerLiteral.TAG | 0) {
      case /* String */0 :
          var string = innerLiteral._0;
          tmp = make("String Literal (\"" + string + "\")", /* Literal */6, makeParseMigrationFactory(string, (function (input) {
                      return typeof input === "string";
                    })), makeSerializeMigrationFactory(string), undefined, undefined);
          break;
      case /* Int */1 :
          var $$int = innerLiteral._0;
          tmp = make("Int Literal (" + $$int.toString() + ")", /* Literal */6, makeParseMigrationFactory($$int, (function (input) {
                      if (typeof input === "number" && input < 2147483648 && input > -2147483649) {
                        return input === Math.trunc(input);
                      } else {
                        return false;
                      }
                    })), makeSerializeMigrationFactory($$int), undefined, undefined);
          break;
      case /* Float */2 :
          var $$float = innerLiteral._0;
          tmp = make("Float Literal (" + $$float.toString() + ")", /* Literal */6, makeParseMigrationFactory($$float, (function (input) {
                      return typeof input === "number";
                    })), makeSerializeMigrationFactory($$float), undefined, undefined);
          break;
      case /* Bool */3 :
          var bool = innerLiteral._0;
          tmp = make("Bool Literal (" + bool + ")", /* Literal */6, makeParseMigrationFactory(bool, (function (input) {
                      return typeof input === "boolean";
                    })), makeSerializeMigrationFactory(bool), undefined, undefined);
          break;
      
    }
  }
  return set(tmp, metadataId, innerLiteral, false, false);
}

function factory$1(innerLiteral) {
  if (typeof innerLiteral === "number") {
    return factory(innerLiteral, undefined);
  } else {
    return factory(innerLiteral, innerLiteral._0);
  }
}

var metadataId$1 = "rescript-struct:Object_UnknownKeys";

function classify$2(struct) {
  var option = get(struct, metadataId$1);
  if (option !== undefined) {
    return Caml_option.valFromOption(option);
  } else {
    return /* Strip */1;
  }
}

var getMaybeExcessKey = (function(object, innerStructsDict) {
    for (var key in object) {
      if (!Object.prototype.hasOwnProperty.call(innerStructsDict, key)) {
        return key
      }
    }
  });

function factory$2(param) {
  var fieldsArray = arguments;
  var fields = Js_dict.fromArray(fieldsArray);
  var fieldNames = Object.keys(fields);
  return make("Object", {
              TAG: /* Object */3,
              fields: fields,
              fieldNames: fieldNames
            }, (function (ctx, struct) {
                var unknownKeys = classify$2(struct);
                var noopOps = [];
                var syncOps = [];
                var asyncOps = [];
                for(var idx = 0 ,idx_finish = fieldNames.length; idx < idx_finish; ++idx){
                  var fieldName = fieldNames[idx];
                  var fieldStruct = fields[fieldName];
                  var fn = fieldStruct.p;
                  if (typeof fn === "number") {
                    noopOps.push([
                          idx,
                          fieldName
                        ]);
                  } else if (fn.TAG === /* SyncOperation */0) {
                    syncOps.push([
                          idx,
                          fieldName,
                          fn._0
                        ]);
                  } else {
                    syncOps.push([
                          idx,
                          fieldName,
                          fn._0
                        ]);
                    asyncOps.push([
                          idx,
                          fieldName
                        ]);
                  }
                }
                var withAsyncOps = asyncOps.length > 0;
                ctx.m.push(function (input) {
                      if ((typeof input === "object" && !Array.isArray(input) && input !== null) === false) {
                        raiseUnexpectedTypeError(input, struct);
                      }
                      var newArray = [];
                      for(var idx = 0 ,idx_finish = syncOps.length; idx < idx_finish; ++idx){
                        var match = syncOps[idx];
                        var fieldName = match[1];
                        var fieldData = input[fieldName];
                        try {
                          var value = match[2](fieldData);
                          newArray[match[0]] = value;
                        }
                        catch (raw_internalError){
                          var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                          if (internalError.RE_EXN_ID === Exception) {
                            throw {
                                  RE_EXN_ID: Exception,
                                  _1: prependLocation(internalError._1, fieldName),
                                  Error: new Error()
                                };
                          }
                          throw internalError;
                        }
                      }
                      for(var idx$1 = 0 ,idx_finish$1 = noopOps.length; idx$1 < idx_finish$1; ++idx$1){
                        var match$1 = noopOps[idx$1];
                        var fieldData$1 = input[match$1[1]];
                        newArray[match$1[0]] = fieldData$1;
                      }
                      if (unknownKeys === /* Strict */0) {
                        var excessKey = getMaybeExcessKey(input, fields);
                        if (excessKey !== undefined) {
                          raise({
                                TAG: /* ExcessField */4,
                                _0: excessKey
                              });
                        }
                        
                      }
                      if (withAsyncOps || newArray.length > 1) {
                        return newArray;
                      } else {
                        return newArray[0];
                      }
                    });
                if (withAsyncOps) {
                  return planAsyncMigration(ctx, (function (tempArray) {
                                return Promise.all(asyncOps.map(function (param) {
                                                  var fieldName = param[1];
                                                  return tempArray[param[0]]().catch(function (exn) {
                                                              throw exn.RE_EXN_ID === Exception ? ({
                                                                        RE_EXN_ID: Exception,
                                                                        _1: prependLocation(exn._1, fieldName)
                                                                      }) : exn;
                                                            });
                                                })).then(function (asyncFieldValues) {
                                            asyncFieldValues.forEach(function (fieldValue, idx) {
                                                  var match = asyncOps[idx];
                                                  tempArray[match[0]] = fieldValue;
                                                });
                                            return tempArray;
                                          });
                              }));
                }
                
              }), (function (ctx, param) {
                ctx.m.push(function (input) {
                      var unknown = {};
                      var fieldValues = fieldNames.length <= 1 ? [input] : input;
                      for(var idx = 0 ,idx_finish = fieldNames.length; idx < idx_finish; ++idx){
                        var fieldName = fieldNames[idx];
                        var fieldStruct = fields[fieldName];
                        var fieldValue = fieldValues[idx];
                        var fn = fieldStruct.s;
                        if (typeof fn === "number") {
                          unknown[fieldName] = fieldValue;
                        } else if (fn.TAG === /* SyncOperation */0) {
                          try {
                            var fieldData = fn._0(fieldValue);
                            unknown[fieldName] = fieldData;
                          }
                          catch (raw_internalError){
                            var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                            if (internalError.RE_EXN_ID === Exception) {
                              throw {
                                    RE_EXN_ID: Exception,
                                    _1: prependLocation(internalError._1, fieldName),
                                    Error: new Error()
                                  };
                            }
                            throw internalError;
                          }
                        } else {
                          panic$1(undefined);
                        }
                      }
                      return unknown;
                    });
              }), undefined, undefined);
}

function strip(struct) {
  return set(struct, metadataId$1, /* Strip */1, true, false);
}

function strict(struct) {
  return set(struct, metadataId$1, /* Strict */0, true, false);
}

function factory$3(param) {
  var migrationFactory = function (ctx, struct) {
    ctx.m.push(function (input) {
          return raiseUnexpectedTypeError(input, struct);
        });
  };
  return make("Never", /* Never */0, migrationFactory, migrationFactory, undefined, undefined);
}

function factory$4(param) {
  return make("Unknown", /* Unknown */1, empty, empty, undefined, undefined);
}

var cuidRegex = /^c[^\s-]{8,}$/i;

var uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;

var emailRegex = /^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i;

function factory$5(param) {
  return make("String", /* String */2, (function (ctx, struct) {
                ctx.m.push(function (input) {
                      if (typeof input === "string") {
                        return input;
                      } else {
                        return raiseUnexpectedTypeError(input, struct);
                      }
                    });
              }), empty, undefined, undefined);
}

function min(struct, maybeMessage, length) {
  var refiner = function (value) {
    if (value.length >= length) {
      return ;
    }
    var $$default = "String must be " + length.toString() + " or more characters long";
    raise$2(maybeMessage !== undefined ? Caml_option.valFromOption(maybeMessage) : $$default);
  };
  return refine(struct, refiner, refiner, undefined);
}

function max(struct, maybeMessage, length) {
  var refiner = function (value) {
    if (value.length <= length) {
      return ;
    }
    var $$default = "String must be " + length.toString() + " or fewer characters long";
    raise$2(maybeMessage !== undefined ? Caml_option.valFromOption(maybeMessage) : $$default);
  };
  return refine(struct, refiner, refiner, undefined);
}

function length(struct, maybeMessage, length$1) {
  var refiner = function (value) {
    if (value.length === length$1) {
      return ;
    }
    var $$default = "String must be exactly " + length$1.toString() + " characters long";
    raise$2(maybeMessage !== undefined ? Caml_option.valFromOption(maybeMessage) : $$default);
  };
  return refine(struct, refiner, refiner, undefined);
}

function email(struct, messageOpt, param) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid email address";
  var refiner = function (value) {
    if (!emailRegex.test(value)) {
      return raise$2(message);
    }
    
  };
  return refine(struct, refiner, refiner, undefined);
}

function uuid(struct, messageOpt, param) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid UUID";
  var refiner = function (value) {
    if (!uuidRegex.test(value)) {
      return raise$2(message);
    }
    
  };
  return refine(struct, refiner, refiner, undefined);
}

function cuid(struct, messageOpt, param) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid CUID";
  var refiner = function (value) {
    if (!cuidRegex.test(value)) {
      return raise$2(message);
    }
    
  };
  return refine(struct, refiner, refiner, undefined);
}

function url(struct, messageOpt, param) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid url";
  var refiner = function (value) {
    var tmp;
    try {
      new URL(value);
      tmp = true;
    }
    catch (exn){
      tmp = false;
    }
    if (!tmp) {
      return raise$2(message);
    }
    
  };
  return refine(struct, refiner, refiner, undefined);
}

function pattern(struct, messageOpt, re) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid";
  var refiner = function (value) {
    re.lastIndex = 0;
    if (!re.test(value)) {
      return raise$2(message);
    }
    
  };
  return refine(struct, refiner, refiner, undefined);
}

function trimmed(struct, param) {
  var transformer = function (prim) {
    return prim.trim();
  };
  return transform(struct, transformer, transformer, undefined);
}

function factory$6(param) {
  return make("Bool", /* Bool */5, (function (ctx, struct) {
                ctx.m.push(function (input) {
                      if (typeof input === "boolean") {
                        return input;
                      } else {
                        return raiseUnexpectedTypeError(input, struct);
                      }
                    });
              }), empty, undefined, undefined);
}

function factory$7(param) {
  return make("Int", /* Int */3, (function (ctx, struct) {
                ctx.m.push(function (input) {
                      if (typeof input === "number" && input < 2147483648 && input > -2147483649 && input === Math.trunc(input)) {
                        return input;
                      } else {
                        return raiseUnexpectedTypeError(input, struct);
                      }
                    });
              }), empty, undefined, undefined);
}

function min$1(struct, maybeMessage, thanValue) {
  var refiner = function (value) {
    if (value >= thanValue) {
      return ;
    }
    var $$default = "Number must be greater than or equal to " + thanValue.toString() + "";
    raise$2(maybeMessage !== undefined ? Caml_option.valFromOption(maybeMessage) : $$default);
  };
  return refine(struct, refiner, refiner, undefined);
}

function max$1(struct, maybeMessage, thanValue) {
  var refiner = function (value) {
    if (value <= thanValue) {
      return ;
    }
    var $$default = "Number must be lower than or equal to " + thanValue.toString() + "";
    raise$2(maybeMessage !== undefined ? Caml_option.valFromOption(maybeMessage) : $$default);
  };
  return refine(struct, refiner, refiner, undefined);
}

function factory$8(param) {
  return make("Float", /* Float */4, (function (ctx, struct) {
                ctx.m.push(function (input) {
                      if (typeof input === "number" && !Number.isNaN(input)) {
                        return input;
                      } else {
                        return raiseUnexpectedTypeError(input, struct);
                      }
                    });
              }), empty, undefined, undefined);
}

function factory$9(param) {
  return make("Date", /* Date */7, (function (ctx, struct) {
                ctx.m.push(function (input) {
                      if ((input instanceof Date) && !Number.isNaN(input.getTime())) {
                        return input;
                      } else {
                        return raiseUnexpectedTypeError(input, struct);
                      }
                    });
              }), empty, undefined, undefined);
}

function factory$10(innerStruct) {
  return make("Null", {
              TAG: /* Null */1,
              _0: innerStruct
            }, (function (ctx, param) {
                var planSyncMigration = function (fn) {
                  ctx.m.push(function (input) {
                        if (input !== null) {
                          return Caml_option.some(fn(input));
                        }
                        
                      });
                };
                var fn = innerStruct.p;
                if (typeof fn === "number") {
                  ctx.m.push(function (prim) {
                        if (prim === null) {
                          return ;
                        } else {
                          return Caml_option.some(prim);
                        }
                      });
                  return ;
                }
                if (fn.TAG === /* SyncOperation */0) {
                  return planSyncMigration(fn._0);
                }
                planSyncMigration(fn._0);
                planAsyncMigration(ctx, (function (input) {
                        if (input !== undefined) {
                          return input().then(function (value) {
                                      return Caml_option.some(value);
                                    });
                        } else {
                          return Promise.resolve(undefined);
                        }
                      }));
              }), (function (ctx, param) {
                ctx.m.push(function (input) {
                      if (input === undefined) {
                        return null;
                      }
                      var value = Caml_option.valFromOption(input);
                      var fn = innerStruct.s;
                      if (typeof fn === "number") {
                        return value;
                      } else if (fn.TAG === /* SyncOperation */0) {
                        return fn._0(value);
                      } else {
                        return panic$1(undefined);
                      }
                    });
              }), undefined, undefined);
}

function factory$11(innerStruct) {
  return make("Option", {
              TAG: /* Option */0,
              _0: innerStruct
            }, (function (ctx, param) {
                var planSyncMigration = function (fn) {
                  ctx.m.push(function (input) {
                        if (input !== undefined) {
                          return Caml_option.some(fn(Caml_option.valFromOption(input)));
                        }
                        
                      });
                };
                var fn = innerStruct.p;
                if (typeof fn === "number") {
                  return ;
                }
                if (fn.TAG === /* SyncOperation */0) {
                  return planSyncMigration(fn._0);
                }
                planSyncMigration(fn._0);
                planAsyncMigration(ctx, (function (input) {
                        if (input !== undefined) {
                          return input().then(function (value) {
                                      return Caml_option.some(value);
                                    });
                        } else {
                          return Promise.resolve(undefined);
                        }
                      }));
              }), (function (ctx, param) {
                ctx.m.push(function (input) {
                      if (input === undefined) {
                        return ;
                      }
                      var value = Caml_option.valFromOption(input);
                      var fn = innerStruct.s;
                      if (typeof fn === "number") {
                        return value;
                      } else if (fn.TAG === /* SyncOperation */0) {
                        return fn._0(value);
                      } else {
                        return panic$1(undefined);
                      }
                    });
              }), undefined, undefined);
}

var metadataId$2 = "rescript-struct:Deprecated";

function factory$12(innerStruct, maybeMessage, param) {
  return set(factory$11(innerStruct), metadataId$2, maybeMessage !== undefined ? /* WithMessage */({
                  _0: maybeMessage
                }) : /* WithoutMessage */0, false, false);
}

function classify$3(struct) {
  return get(struct, metadataId$2);
}

function factory$13(innerStruct) {
  return make("Array", {
              TAG: /* Array */2,
              _0: innerStruct
            }, (function (ctx, struct) {
                ctx.m.push(function (input) {
                      if (Array.isArray(input) === false) {
                        return raiseUnexpectedTypeError(input, struct);
                      } else {
                        return input;
                      }
                    });
                var planSyncMigration = function (fn) {
                  ctx.m.push(function (input) {
                        var newArray = [];
                        for(var idx = 0 ,idx_finish = input.length; idx < idx_finish; ++idx){
                          var innerData = input[idx];
                          try {
                            var value = fn(innerData);
                            newArray.push(value);
                          }
                          catch (raw_internalError){
                            var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                            if (internalError.RE_EXN_ID === Exception) {
                              throw {
                                    RE_EXN_ID: Exception,
                                    _1: prependLocation(internalError._1, idx.toString()),
                                    Error: new Error()
                                  };
                            }
                            throw internalError;
                          }
                        }
                        return newArray;
                      });
                };
                var fn = innerStruct.p;
                if (typeof fn === "number") {
                  return ;
                }
                if (fn.TAG === /* SyncOperation */0) {
                  return planSyncMigration(fn._0);
                }
                planSyncMigration(fn._0);
                planAsyncMigration(ctx, (function (input) {
                        return Promise.all(input.map(function (asyncFn, idx) {
                                        return asyncFn().catch(function (exn) {
                                                    throw exn.RE_EXN_ID === Exception ? ({
                                                              RE_EXN_ID: Exception,
                                                              _1: prependLocation(exn._1, idx.toString())
                                                            }) : exn;
                                                  });
                                      }));
                      }));
              }), (function (ctx, param) {
                var fn = innerStruct.s;
                if (typeof fn === "number") {
                  return ;
                }
                if (fn.TAG !== /* SyncOperation */0) {
                  return panic$1(undefined);
                }
                var fn$1 = fn._0;
                ctx.m.push(function (input) {
                      var newArray = [];
                      for(var idx = 0 ,idx_finish = input.length; idx < idx_finish; ++idx){
                        var innerData = input[idx];
                        try {
                          var value = fn$1(innerData);
                          newArray.push(value);
                        }
                        catch (raw_internalError){
                          var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                          if (internalError.RE_EXN_ID === Exception) {
                            throw {
                                  RE_EXN_ID: Exception,
                                  _1: prependLocation(internalError._1, idx.toString()),
                                  Error: new Error()
                                };
                          }
                          throw internalError;
                        }
                      }
                      return newArray;
                    });
              }), undefined, undefined);
}

function min$2(struct, maybeMessage, length) {
  var refiner = function (value) {
    if (value.length >= length) {
      return ;
    }
    var $$default = "Array must be " + length.toString() + " or more items long";
    raise$2(maybeMessage !== undefined ? Caml_option.valFromOption(maybeMessage) : $$default);
  };
  return refine(struct, refiner, refiner, undefined);
}

function max$2(struct, maybeMessage, length) {
  var refiner = function (value) {
    if (value.length <= length) {
      return ;
    }
    var $$default = "Array must be " + length.toString() + " or fewer items long";
    raise$2(maybeMessage !== undefined ? Caml_option.valFromOption(maybeMessage) : $$default);
  };
  return refine(struct, refiner, refiner, undefined);
}

function length$1(struct, maybeMessage, length$2) {
  var refiner = function (value) {
    if (value.length === length$2) {
      return ;
    }
    var $$default = "Array must be exactly " + length$2.toString() + " items long";
    raise$2(maybeMessage !== undefined ? Caml_option.valFromOption(maybeMessage) : $$default);
  };
  return refine(struct, refiner, refiner, undefined);
}

function factory$14(innerStruct) {
  return make("Dict", {
              TAG: /* Dict */6,
              _0: innerStruct
            }, (function (ctx, struct) {
                var planSyncMigration = function (fn) {
                  ctx.m.push(function (input) {
                        var newDict = {};
                        var keys = Object.keys(input);
                        for(var idx = 0 ,idx_finish = keys.length; idx < idx_finish; ++idx){
                          var key = keys[idx];
                          var innerData = input[key];
                          try {
                            var value = fn(innerData);
                            newDict[key] = value;
                          }
                          catch (raw_internalError){
                            var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                            if (internalError.RE_EXN_ID === Exception) {
                              throw {
                                    RE_EXN_ID: Exception,
                                    _1: prependLocation(internalError._1, key),
                                    Error: new Error()
                                  };
                            }
                            throw internalError;
                          }
                        }
                        return newDict;
                      });
                };
                ctx.m.push(function (input) {
                      if ((typeof input === "object" && !Array.isArray(input) && input !== null) === false) {
                        return raiseUnexpectedTypeError(input, struct);
                      } else {
                        return input;
                      }
                    });
                var fn = innerStruct.p;
                if (typeof fn === "number") {
                  return ;
                }
                if (fn.TAG === /* SyncOperation */0) {
                  return planSyncMigration(fn._0);
                }
                planSyncMigration(fn._0);
                planAsyncMigration(ctx, (function (input) {
                        var keys = Object.keys(input);
                        return Promise.all(keys.map(function (key) {
                                          var asyncFn = input[key];
                                          try {
                                            return asyncFn().catch(function (exn) {
                                                        throw exn.RE_EXN_ID === Exception ? ({
                                                                  RE_EXN_ID: Exception,
                                                                  _1: prependLocation(exn._1, key)
                                                                }) : exn;
                                                      });
                                          }
                                          catch (raw_internalError){
                                            var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                                            if (internalError.RE_EXN_ID === Exception) {
                                              throw {
                                                    RE_EXN_ID: Exception,
                                                    _1: prependLocation(internalError._1, key),
                                                    Error: new Error()
                                                  };
                                            }
                                            throw internalError;
                                          }
                                        })).then(function (values) {
                                    var tempDict = {};
                                    values.forEach(function (value, idx) {
                                          var key = keys[idx];
                                          tempDict[key] = value;
                                        });
                                    return tempDict;
                                  });
                      }));
              }), (function (ctx, param) {
                var fn = innerStruct.s;
                if (typeof fn === "number") {
                  return ;
                }
                if (fn.TAG !== /* SyncOperation */0) {
                  return panic$1(undefined);
                }
                var fn$1 = fn._0;
                ctx.m.push(function (input) {
                      var newDict = {};
                      var keys = Object.keys(input);
                      for(var idx = 0 ,idx_finish = keys.length; idx < idx_finish; ++idx){
                        var key = keys[idx];
                        var innerData = input[key];
                        try {
                          var value = fn$1(innerData);
                          newDict[key] = value;
                        }
                        catch (raw_internalError){
                          var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                          if (internalError.RE_EXN_ID === Exception) {
                            throw {
                                  RE_EXN_ID: Exception,
                                  _1: prependLocation(internalError._1, key),
                                  Error: new Error()
                                };
                          }
                          throw internalError;
                        }
                      }
                      return newDict;
                    });
              }), undefined, undefined);
}

var metadataId$3 = "rescript-struct:Defaulted";

function factory$15(innerStruct, defaultValue) {
  return set(make(innerStruct.n, innerStruct.t, (function (ctx, param) {
                    var fn = innerStruct.p;
                    if (typeof fn === "number") {
                      ctx.m.push(function (input) {
                            if (input !== undefined) {
                              return Caml_option.valFromOption(input);
                            } else {
                              return defaultValue;
                            }
                          });
                      return ;
                    }
                    if (fn.TAG === /* SyncOperation */0) {
                      var fn$1 = fn._0;
                      ctx.m.push(function (input) {
                            var option = fn$1(input);
                            if (option !== undefined) {
                              return Caml_option.valFromOption(option);
                            } else {
                              return defaultValue;
                            }
                          });
                      return ;
                    }
                    var fn$2 = fn._0;
                    planAsyncMigration(ctx, (function (input) {
                            return fn$2(input)().then(function (value) {
                                        if (value !== undefined) {
                                          return Caml_option.valFromOption(value);
                                        } else {
                                          return defaultValue;
                                        }
                                      });
                          }));
                  }), (function (ctx, param) {
                    ctx.m.push(function (input) {
                          var value = Caml_option.some(input);
                          var fn = innerStruct.s;
                          if (typeof fn === "number") {
                            return value;
                          } else if (fn.TAG === /* SyncOperation */0) {
                            return fn._0(value);
                          } else {
                            return panic$1(undefined);
                          }
                        });
                  }), undefined, undefined), metadataId$3, /* WithDefaultValue */{
              _0: defaultValue
            }, false, false);
}

function classify$4(struct) {
  return get(struct, metadataId$3);
}

function factory$16(param) {
  var structs = arguments;
  var numberOfStructs = structs.length;
  return make("Tuple", {
              TAG: /* Tuple */4,
              _0: structs
            }, (function (ctx, struct) {
                var noopOps = [];
                var syncOps = [];
                var asyncOps = [];
                for(var idx = 0 ,idx_finish = structs.length; idx < idx_finish; ++idx){
                  var innerStruct = structs[idx];
                  var fn = innerStruct.p;
                  if (typeof fn === "number") {
                    noopOps.push(idx);
                  } else if (fn.TAG === /* SyncOperation */0) {
                    syncOps.push([
                          idx,
                          fn._0
                        ]);
                  } else {
                    syncOps.push([
                          idx,
                          fn._0
                        ]);
                    asyncOps.push(idx);
                  }
                }
                var withAsyncOps = asyncOps.length > 0;
                ctx.m.push(function (input) {
                      if (Array.isArray(input)) {
                        var numberOfInputItems = input.length;
                        if (numberOfStructs !== numberOfInputItems) {
                          raise({
                                TAG: /* TupleSize */3,
                                expected: numberOfStructs,
                                received: numberOfInputItems
                              });
                        }
                        
                      } else {
                        raiseUnexpectedTypeError(input, struct);
                      }
                      var newArray = [];
                      for(var idx = 0 ,idx_finish = syncOps.length; idx < idx_finish; ++idx){
                        var match = syncOps[idx];
                        var originalIdx = match[0];
                        var innerData = input[originalIdx];
                        try {
                          var value = match[1](innerData);
                          newArray[originalIdx] = value;
                        }
                        catch (raw_internalError){
                          var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                          if (internalError.RE_EXN_ID === Exception) {
                            throw {
                                  RE_EXN_ID: Exception,
                                  _1: prependLocation(internalError._1, idx.toString()),
                                  Error: new Error()
                                };
                          }
                          throw internalError;
                        }
                      }
                      for(var idx$1 = 0 ,idx_finish$1 = noopOps.length; idx$1 < idx_finish$1; ++idx$1){
                        var originalIdx$1 = noopOps[idx$1];
                        var innerData$1 = input[originalIdx$1];
                        newArray[originalIdx$1] = innerData$1;
                      }
                      if (withAsyncOps) {
                        return newArray;
                      } else if (numberOfStructs !== 0) {
                        if (numberOfStructs !== 1) {
                          return newArray;
                        } else {
                          return newArray[0];
                        }
                      } else {
                        return ;
                      }
                    });
                if (withAsyncOps) {
                  return planAsyncMigration(ctx, (function (tempArray) {
                                return Promise.all(asyncOps.map(function (originalIdx) {
                                                  return tempArray[originalIdx]().catch(function (exn) {
                                                              throw exn.RE_EXN_ID === Exception ? ({
                                                                        RE_EXN_ID: Exception,
                                                                        _1: prependLocation(exn._1, originalIdx.toString())
                                                                      }) : exn;
                                                            });
                                                })).then(function (values) {
                                            values.forEach(function (value, idx) {
                                                  var originalIdx = asyncOps[idx];
                                                  tempArray[originalIdx] = value;
                                                });
                                            if (tempArray.length <= 1) {
                                              return tempArray[0];
                                            } else {
                                              return tempArray;
                                            }
                                          });
                              }));
                }
                
              }), (function (ctx, param) {
                ctx.m.push(function (input) {
                      var inputArray = numberOfStructs === 1 ? [input] : input;
                      var newArray = [];
                      for(var idx = 0; idx < numberOfStructs; ++idx){
                        var innerData = inputArray[idx];
                        var innerStruct = structs[idx];
                        var fn = innerStruct.s;
                        if (typeof fn === "number") {
                          newArray.push(innerData);
                        } else if (fn.TAG === /* SyncOperation */0) {
                          try {
                            var value = fn._0(innerData);
                            newArray.push(value);
                          }
                          catch (raw_internalError){
                            var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                            if (internalError.RE_EXN_ID === Exception) {
                              throw {
                                    RE_EXN_ID: Exception,
                                    _1: prependLocation(internalError._1, idx.toString()),
                                    Error: new Error()
                                  };
                            }
                            throw internalError;
                          }
                        } else {
                          panic$1(undefined);
                        }
                      }
                      return newArray;
                    });
              }), undefined, undefined);
}

var Tuple = {
  factory: factory$16
};

var HackyValidValue = /* @__PURE__ */Caml_exceptions.create("S.Union.HackyValidValue");

function factory$17(structs) {
  if (structs.length < 2) {
    panic$2(undefined);
  }
  return make("Union", {
              TAG: /* Union */5,
              _0: structs
            }, (function (ctx, compilingStruct) {
                var structs = compilingStruct.t._0;
                var noopOps = [];
                var syncOps = [];
                var asyncOps = [];
                for(var idx = 0 ,idx_finish = structs.length; idx < idx_finish; ++idx){
                  var innerStruct = structs[idx];
                  var fn = innerStruct.p;
                  if (typeof fn === "number") {
                    noopOps.push(undefined);
                  } else if (fn.TAG === /* SyncOperation */0) {
                    syncOps.push([
                          idx,
                          fn._0
                        ]);
                  } else {
                    asyncOps.push([
                          idx,
                          fn._0
                        ]);
                  }
                }
                var withAsyncOps = asyncOps.length > 0;
                if (noopOps.length === 0) {
                  ctx.m.push(function (input) {
                        var idxRef = 0;
                        var errorsRef = [];
                        var maybeNewValueRef;
                        while(idxRef < syncOps.length && maybeNewValueRef === undefined) {
                          var idx = idxRef;
                          var match = syncOps[idx];
                          try {
                            var newValue = match[1](input);
                            maybeNewValueRef = Caml_option.some(newValue);
                          }
                          catch (raw_internalError){
                            var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                            if (internalError.RE_EXN_ID === Exception) {
                              errorsRef[match[0]] = internalError._1;
                              idxRef = idxRef + 1;
                            } else {
                              throw internalError;
                            }
                          }
                        };
                        var match$1 = maybeNewValueRef;
                        if (match$1 !== undefined) {
                          if (withAsyncOps) {
                            return {
                                    maybeSyncValue: match$1,
                                    tempErrors: errorsRef,
                                    originalInput: input
                                  };
                          } else {
                            return Caml_option.valFromOption(match$1);
                          }
                        } else if (withAsyncOps) {
                          return {
                                  maybeSyncValue: match$1,
                                  tempErrors: errorsRef,
                                  originalInput: input
                                };
                        } else {
                          return raise({
                                      TAG: /* InvalidUnion */5,
                                      _0: errorsRef.map(toParseError)
                                    });
                        }
                      });
                  if (withAsyncOps) {
                    return planAsyncMigration(ctx, (function (input) {
                                  var syncValue = input.maybeSyncValue;
                                  if (syncValue !== undefined) {
                                    return Promise.resolve(Caml_option.valFromOption(syncValue));
                                  } else {
                                    return Promise.all(asyncOps.map(function (param) {
                                                      var originalIdx = param[0];
                                                      try {
                                                        return param[1](input.originalInput)().then((function (value) {
                                                                      throw {
                                                                            RE_EXN_ID: HackyValidValue,
                                                                            _1: value,
                                                                            Error: new Error()
                                                                          };
                                                                    }), (function (exn) {
                                                                      if (exn.RE_EXN_ID === Exception) {
                                                                        var array = input.tempErrors;
                                                                        array[originalIdx] = exn._1;
                                                                        return ;
                                                                      }
                                                                      throw exn;
                                                                    }));
                                                      }
                                                      catch (raw_internalError){
                                                        var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                                                        if (internalError.RE_EXN_ID === Exception) {
                                                          var array = input.tempErrors;
                                                          return Promise.resolve((array[originalIdx] = internalError._1, undefined));
                                                        }
                                                        throw internalError;
                                                      }
                                                    })).then((function (param) {
                                                  return raise({
                                                              TAG: /* InvalidUnion */5,
                                                              _0: input.tempErrors.map(toParseError)
                                                            });
                                                }), (function (exn) {
                                                  if (exn.RE_EXN_ID === HackyValidValue) {
                                                    return exn._1;
                                                  }
                                                  throw exn;
                                                }));
                                  }
                                }));
                  } else {
                    return ;
                  }
                }
                
              }), (function (ctx, param) {
                ctx.m.push(function (input) {
                      var idxRef = 0;
                      var maybeLastErrorRef;
                      var maybeNewValueRef;
                      while(idxRef < structs.length && maybeNewValueRef === undefined) {
                        var idx = idxRef;
                        var innerStruct = structs[idx];
                        try {
                          var fn = innerStruct.s;
                          var newValue;
                          newValue = typeof fn === "number" ? input : (
                              fn.TAG === /* SyncOperation */0 ? fn._0(input) : panic$1(undefined)
                            );
                          maybeNewValueRef = Caml_option.some(newValue);
                        }
                        catch (raw_internalError){
                          var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                          if (internalError.RE_EXN_ID === Exception) {
                            maybeLastErrorRef = internalError._1;
                            idxRef = idxRef + 1;
                          } else {
                            throw internalError;
                          }
                        }
                      };
                      var ok = maybeNewValueRef;
                      if (ok !== undefined) {
                        return Caml_option.valFromOption(ok);
                      }
                      var error = maybeLastErrorRef;
                      if (error !== undefined) {
                        throw {
                              RE_EXN_ID: Exception,
                              _1: error,
                              Error: new Error()
                            };
                      }
                      return undefined;
                    });
              }), undefined, undefined);
}

function getExn(result) {
  if (result.TAG === /* Ok */0) {
    return result._0;
  }
  var message = toString(result._0);
  throw new Error("[rescript-struct] " + message + "");
}

function mapErrorToString(result) {
  if (result.TAG === /* Ok */0) {
    return result;
  } else {
    return {
            TAG: /* Error */1,
            _0: toString(result._0)
          };
  }
}

var Result = {
  getExn: getExn,
  mapErrorToString: mapErrorToString
};

function json(innerStruct) {
  return advancedTransform(transform(factory$5(undefined), (function (jsonString) {
                    try {
                      return JSON.parse(jsonString);
                    }
                    catch (raw_obj){
                      var obj = Caml_js_exceptions.internalToOCamlException(raw_obj);
                      if (obj.RE_EXN_ID === Js_exn.$$Error) {
                        var option = obj._1.message;
                        return raise$2(option !== undefined ? Caml_option.valFromOption(option) : "Failed to parse JSON");
                      }
                      throw obj;
                    }
                  }), (function (prim) {
                    return JSON.stringify(prim);
                  }), undefined), (function (param) {
                var match = innerStruct.p;
                var tmp;
                tmp = typeof match === "number" || match.TAG === /* SyncOperation */0 ? false : true;
                if (tmp) {
                  return {
                          TAG: /* Async */1,
                          _0: (function (parsedJson) {
                              return parseAsyncWith(parsedJson, innerStruct).then(function (result) {
                                          if (result.TAG === /* Ok */0) {
                                            return result._0;
                                          }
                                          throw {
                                                RE_EXN_ID: Exception,
                                                _1: result._0,
                                                Error: new Error()
                                              };
                                        });
                            })
                        };
                } else {
                  return {
                          TAG: /* Sync */0,
                          _0: (function (parsedJson) {
                              var value = parseWith(parsedJson, innerStruct);
                              if (value.TAG === /* Ok */0) {
                                return value._0;
                              }
                              throw {
                                    RE_EXN_ID: Exception,
                                    _1: value._0,
                                    Error: new Error()
                                  };
                            })
                        };
                }
              }), (function (param) {
                return {
                        TAG: /* Sync */0,
                        _0: (function (value) {
                            var unknown = serializeWith(value, innerStruct);
                            if (unknown.TAG === /* Ok */0) {
                              return unknown._0;
                            }
                            throw {
                                  RE_EXN_ID: Exception,
                                  _1: unknown._0,
                                  Error: new Error()
                                };
                          })
                      };
              }), undefined);
}

var $$Error$1 = {
  prependLocation: prependLocation$1,
  raiseCustom: raiseCustom,
  raise: raise$2,
  toString: toString
};

var never = factory$3;

var unknown = factory$4;

var string = factory$5;

var bool = factory$6;

var $$int = factory$7;

var $$float = factory$8;

var date = factory$9;

var literal = factory$1;

var literalVariant = factory;

var array = factory$13;

var dict = factory$14;

var option = factory$11;

var $$null = factory$10;

var union = factory$17;

var deprecated = factory$12;

var defaulted = factory$15;

var Object_UnknownKeys = {
  classify: classify$2
};

var $$Object = {
  UnknownKeys: Object_UnknownKeys,
  factory: factory$2,
  strip: strip,
  strict: strict
};

var object0 = factory$2;

var object1 = factory$2;

var object2 = factory$2;

var object3 = factory$2;

var object4 = factory$2;

var object5 = factory$2;

var object6 = factory$2;

var object7 = factory$2;

var object8 = factory$2;

var object9 = factory$2;

var object10 = factory$2;

var tuple0 = factory$16;

var tuple1 = factory$16;

var tuple2 = factory$16;

var tuple3 = factory$16;

var tuple4 = factory$16;

var tuple5 = factory$16;

var tuple6 = factory$16;

var tuple7 = factory$16;

var tuple8 = factory$16;

var tuple9 = factory$16;

var tuple10 = factory$16;

var $$String = {
  min: min,
  max: max,
  length: length,
  email: email,
  uuid: uuid,
  cuid: cuid,
  url: url,
  pattern: pattern,
  trimmed: trimmed
};

var Int = {
  min: min$1,
  max: max$1
};

var Float = {
  min: min$1,
  max: max$1
};

var $$Array = {
  min: min$2,
  max: max$2,
  length: length$1
};

var Defaulted = {
  classify: classify$4
};

var Deprecated = {
  classify: classify$3
};

var Literal = {
  classify: classify$1
};

var Metadata = {
  Id: Id,
  get: get,
  set: set
};

export {
  $$Error$1 as $$Error,
  Raised ,
  never ,
  unknown ,
  string ,
  bool ,
  $$int ,
  $$float ,
  date ,
  literal ,
  literalVariant ,
  array ,
  dict ,
  option ,
  $$null ,
  json ,
  union ,
  deprecated ,
  defaulted ,
  transform ,
  advancedTransform ,
  advancedPreprocess ,
  custom ,
  refine ,
  asyncRefine ,
  parseWith ,
  parseOrRaiseWith ,
  parseAsyncWith ,
  parseAsyncInStepsWith ,
  serializeWith ,
  serializeOrRaiseWith ,
  isAsyncParse ,
  $$Object ,
  object0 ,
  object1 ,
  object2 ,
  object3 ,
  object4 ,
  object5 ,
  object6 ,
  object7 ,
  object8 ,
  object9 ,
  object10 ,
  Tuple ,
  tuple0 ,
  tuple1 ,
  tuple2 ,
  tuple3 ,
  tuple4 ,
  tuple5 ,
  tuple6 ,
  tuple7 ,
  tuple8 ,
  tuple9 ,
  tuple10 ,
  classify ,
  name ,
  $$String ,
  Int ,
  Float ,
  $$Array ,
  Defaulted ,
  Deprecated ,
  Literal ,
  Result ,
  Metadata ,
}
/* No side effect */
