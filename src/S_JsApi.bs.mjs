// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as S$RescriptStruct from "./S.bs.mjs";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

export class RescriptStructError extends Error {
      constructor(message) {
        super(message);
        this.name = "RescriptStructError";
      }
    }
;

function fromOk(value) {
  return {
          success: true,
          value: value
        };
}

function fromError(error) {
  return {
          success: false,
          error: error
        };
}

function transform(struct, maybeParser, maybeSerializer) {
  return S$RescriptStruct.transform(struct, (function (s) {
                return {
                        p: maybeParser !== undefined ? (function (v) {
                              return maybeParser(v, s);
                            }) : undefined,
                        s: maybeSerializer !== undefined ? (function (v) {
                              return maybeSerializer(v, s);
                            }) : undefined
                      };
              }));
}

function refine(struct, refiner) {
  return S$RescriptStruct.refine(struct, (function (s) {
                return function (v) {
                  refiner(v, s);
                };
              }));
}

function noop(a) {
  return a;
}

function asyncParserRefine(struct, refine) {
  return S$RescriptStruct.transform(struct, (function (s) {
                return {
                        a: (function (v) {
                            return function () {
                              return refine(v, s).then(function () {
                                          return v;
                                        });
                            };
                          }),
                        s: noop
                      };
              }));
}

function optional(struct, maybeOr) {
  var struct$1 = S$RescriptStruct.option(struct);
  if (maybeOr === undefined) {
    return struct$1;
  }
  var or = Caml_option.valFromOption(maybeOr);
  if (typeof or === "function") {
    return S$RescriptStruct.$$Option.getOrWith(struct$1, or);
  } else {
    return S$RescriptStruct.$$Option.getOr(struct$1, or);
  }
}

function tuple(structs) {
  return S$RescriptStruct.tuple(function (s) {
              return structs.map(function (struct, idx) {
                          return s.i(idx, struct);
                        });
            });
}

function custom(name, maybeParser, maybeSerializer, param) {
  return S$RescriptStruct.custom(name, (function (s) {
                return {
                        p: maybeParser !== undefined ? (function (v) {
                              return maybeParser(v, s);
                            }) : undefined,
                        s: maybeSerializer !== undefined ? (function (v) {
                              return maybeSerializer(v, s);
                            }) : undefined
                      };
              }));
}

var objectStructOperations = {};

function strict() {
  var struct = this;
  return Object.assign(S$RescriptStruct.$$Object.strict(struct), objectStructOperations);
}

function strip() {
  var struct = this;
  return Object.assign(S$RescriptStruct.$$Object.strip(struct), objectStructOperations);
}

function factory(definer) {
  return Object.assign(S$RescriptStruct.object(function (s) {
                  var definition = {};
                  var fieldNames = Object.keys(definer);
                  for(var idx = 0 ,idx_finish = fieldNames.length; idx < idx_finish; ++idx){
                    var fieldName = fieldNames[idx];
                    var struct = definer[fieldName];
                    definition[fieldName] = s.f(fieldName, struct);
                  }
                  return definition;
                }), objectStructOperations);
}

Object.assign(objectStructOperations, {
      strict: strict,
      strip: strip
    });

function parse(struct, data) {
  try {
    return fromOk(S$RescriptStruct.parseAnyOrRaiseWith(data, struct));
  }
  catch (raw_error){
    var error = Caml_js_exceptions.internalToOCamlException(raw_error);
    if (error.RE_EXN_ID === S$RescriptStruct.Raised) {
      return fromError(new RescriptStructError(S$RescriptStruct.$$Error.toString(error._1)));
    }
    throw error;
  }
}

function parseOrThrow(struct, data) {
  try {
    return S$RescriptStruct.parseAnyOrRaiseWith(data, struct);
  }
  catch (raw_error){
    var error = Caml_js_exceptions.internalToOCamlException(raw_error);
    if (error.RE_EXN_ID === S$RescriptStruct.Raised) {
      throw new RescriptStructError(S$RescriptStruct.$$Error.toString(error._1));
    }
    throw error;
  }
}

function parseAsync(struct, data) {
  return S$RescriptStruct.parseAnyAsyncWith(data, struct).then(function (result) {
              if (result.TAG === "Ok") {
                return fromOk(result._0);
              } else {
                return fromError(new RescriptStructError(S$RescriptStruct.$$Error.toString(result._0)));
              }
            });
}

function serialize(struct, value) {
  try {
    return fromOk(S$RescriptStruct.serializeToUnknownOrRaiseWith(value, struct));
  }
  catch (raw_error){
    var error = Caml_js_exceptions.internalToOCamlException(raw_error);
    if (error.RE_EXN_ID === S$RescriptStruct.Raised) {
      return fromError(new RescriptStructError(S$RescriptStruct.$$Error.toString(error._1)));
    }
    throw error;
  }
}

function serializeOrThrow(struct, value) {
  try {
    return S$RescriptStruct.serializeToUnknownOrRaiseWith(value, struct);
  }
  catch (raw_error){
    var error = Caml_js_exceptions.internalToOCamlException(raw_error);
    if (error.RE_EXN_ID === S$RescriptStruct.Raised) {
      throw new RescriptStructError(S$RescriptStruct.$$Error.toString(error._1));
    }
    throw error;
  }
}

var $$Error = {};

var Result = {};

var $$Object = {
  factory: factory
};

export {
  $$Error ,
  Result ,
  optional ,
  tuple ,
  custom ,
  asyncParserRefine ,
  refine ,
  transform ,
  $$Object ,
  parse ,
  parseOrThrow ,
  parseAsync ,
  serialize ,
  serializeOrThrow ,
}
/*  Not a pure module */
