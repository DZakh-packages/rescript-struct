// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as S$RescriptStruct from "./S.bs.mjs";

function toJsResult(result) {
  if (result.TAG === "Ok") {
    return {
            success: true,
            value: result._0
          };
  } else {
    return {
            success: false,
            error: result._0
          };
  }
}

function transform(struct, maybeParser, maybeSerializer) {
  return S$RescriptStruct.transform(struct, (function (s) {
                return {
                        p: maybeParser !== undefined ? (function (v) {
                              return maybeParser(v, s);
                            }) : undefined,
                        s: maybeSerializer !== undefined ? (function (v) {
                              return maybeSerializer(v, s);
                            }) : undefined
                      };
              }));
}

function refine(struct, refiner) {
  return S$RescriptStruct.refine(struct, (function (s) {
                return function (v) {
                  refiner(v, s);
                };
              }));
}

function noop(a) {
  return a;
}

function asyncParserRefine(struct, refine) {
  return S$RescriptStruct.transform(struct, (function (s) {
                return {
                        a: (function (v) {
                            return function () {
                              return refine(v, s).then(function () {
                                          return v;
                                        });
                            };
                          }),
                        s: noop
                      };
              }));
}

function optional(struct, maybeOr) {
  var struct$1 = S$RescriptStruct.option(struct);
  if (maybeOr === undefined) {
    return struct$1;
  }
  var or = Caml_option.valFromOption(maybeOr);
  if (typeof or === "function") {
    return S$RescriptStruct.$$Option.getOrWith(struct$1, or);
  } else {
    return S$RescriptStruct.$$Option.getOr(struct$1, or);
  }
}

function tuple(structs) {
  return S$RescriptStruct.tuple(function (s) {
              return structs.map(function (struct, idx) {
                          return s.i(idx, struct);
                        });
            });
}

function custom(name, maybeParser, maybeSerializer, param) {
  return S$RescriptStruct.custom(name, (function (s) {
                return {
                        p: maybeParser !== undefined ? (function (v) {
                              return maybeParser(v, s);
                            }) : undefined,
                        s: maybeSerializer !== undefined ? (function (v) {
                              return maybeSerializer(v, s);
                            }) : undefined
                      };
              }));
}

function object(definer) {
  return S$RescriptStruct.object(function (s) {
              var definition = {};
              var fieldNames = Object.keys(definer);
              for(var idx = 0 ,idx_finish = fieldNames.length; idx < idx_finish; ++idx){
                var fieldName = fieldNames[idx];
                var struct = definer[fieldName];
                definition[fieldName] = s.f(fieldName, struct);
              }
              return definition;
            });
}

function parse(struct, data) {
  return toJsResult(S$RescriptStruct.parseAnyWith(data, struct));
}

function parseOrThrow(struct, data) {
  return struct.p(data);
}

function parseAsync(struct, data) {
  return S$RescriptStruct.parseAnyAsyncWith(data, struct).then(toJsResult);
}

function serialize(struct, value) {
  return toJsResult(S$RescriptStruct.serializeToUnknownWith(value, struct));
}

function serializeOrThrow(struct, value) {
  return struct.s(value);
}

export {
  optional ,
  tuple ,
  custom ,
  asyncParserRefine ,
  refine ,
  transform ,
  object ,
  parse ,
  parseOrThrow ,
  parseAsync ,
  serialize ,
  serializeOrThrow ,
}
/* S-RescriptStruct Not a pure module */
