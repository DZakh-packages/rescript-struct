// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as S$RescriptStruct from "./S.bs.mjs";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

export class RescriptStructError extends Error {
      constructor(message) {
        super(message);
        this.name = "RescriptStructError";
      }
    }
;

function fromOk(value) {
  return {
          success: true,
          value: value
        };
}

function fromError(error) {
  return {
          success: false,
          error: error
        };
}

var structOperations = {};

function parse(data) {
  var struct = this;
  try {
    return fromOk(S$RescriptStruct.parseAnyOrRaiseWith(data, struct));
  }
  catch (raw_error){
    var error = Caml_js_exceptions.internalToOCamlException(raw_error);
    if (error.RE_EXN_ID === S$RescriptStruct.Raised) {
      return fromError(new RescriptStructError(S$RescriptStruct.$$Error.toString(error._1)));
    }
    throw error;
  }
}

function parseOrThrow(data) {
  var struct = this;
  try {
    return S$RescriptStruct.parseAnyOrRaiseWith(data, struct);
  }
  catch (raw_error){
    var error = Caml_js_exceptions.internalToOCamlException(raw_error);
    if (error.RE_EXN_ID === S$RescriptStruct.Raised) {
      throw new RescriptStructError(S$RescriptStruct.$$Error.toString(error._1));
    }
    throw error;
  }
}

function parseAsync(data) {
  var struct = this;
  return S$RescriptStruct.parseAnyAsyncWith(data, struct).then(function (result) {
              if (result.TAG === "Ok") {
                return fromOk(result._0);
              } else {
                return fromError(new RescriptStructError(S$RescriptStruct.$$Error.toString(result._0)));
              }
            });
}

function serialize(value) {
  var struct = this;
  try {
    return fromOk(S$RescriptStruct.serializeToUnknownOrRaiseWith(value, struct));
  }
  catch (raw_error){
    var error = Caml_js_exceptions.internalToOCamlException(raw_error);
    if (error.RE_EXN_ID === S$RescriptStruct.Raised) {
      return fromError(new RescriptStructError(S$RescriptStruct.$$Error.toString(error._1)));
    }
    throw error;
  }
}

function serializeOrThrow(value) {
  var struct = this;
  try {
    return S$RescriptStruct.serializeToUnknownOrRaiseWith(value, struct);
  }
  catch (raw_error){
    var error = Caml_js_exceptions.internalToOCamlException(raw_error);
    if (error.RE_EXN_ID === S$RescriptStruct.Raised) {
      throw new RescriptStructError(S$RescriptStruct.$$Error.toString(error._1));
    }
    throw error;
  }
}

function transform(maybeParser, maybeSerializer) {
  var struct = this;
  var struct$1 = S$RescriptStruct.transform(struct, (function (s) {
          var struct = s.s;
          var effectCtx_struct = Object.assign(struct, structOperations);
          var effectCtx_fail = function (message) {
            return s.f(undefined, message);
          };
          var effectCtx = {
            struct: effectCtx_struct,
            fail: effectCtx_fail
          };
          return {
                  p: maybeParser !== undefined ? (function (v) {
                        return maybeParser(v, effectCtx);
                      }) : undefined,
                  s: maybeSerializer !== undefined ? (function (v) {
                        return maybeSerializer(v, effectCtx);
                      }) : undefined
                };
        }));
  return Object.assign(struct$1, structOperations);
}

function refine(refiner) {
  var struct = this;
  var struct$1 = S$RescriptStruct.refine(struct, (function (s) {
          var struct = s.s;
          var effectCtx_struct = Object.assign(struct, structOperations);
          var effectCtx_fail = function (message) {
            return s.f(undefined, message);
          };
          var effectCtx = {
            struct: effectCtx_struct,
            fail: effectCtx_fail
          };
          return function (v) {
            refiner(v, effectCtx);
          };
        }));
  return Object.assign(struct$1, structOperations);
}

function asyncParserRefine(refiner) {
  var struct = this;
  var struct$1 = S$RescriptStruct.asyncParserRefine(struct, (function (s) {
          var struct = s.s;
          var effectCtx_struct = Object.assign(struct, structOperations);
          var effectCtx_fail = function (message) {
            return s.f(undefined, message);
          };
          var effectCtx = {
            struct: effectCtx_struct,
            fail: effectCtx_fail
          };
          return function (v) {
            return refiner(v, effectCtx);
          };
        }));
  return Object.assign(struct$1, structOperations);
}

function describe(description) {
  var struct = this;
  var struct$1 = S$RescriptStruct.describe(struct, description);
  return Object.assign(struct$1, structOperations);
}

function description() {
  var struct = this;
  return S$RescriptStruct.description(struct);
}

function $$default(def) {
  var struct = this;
  var struct$1 = S$RescriptStruct.$$default(struct, def);
  return Object.assign(struct$1, structOperations);
}

function optional(struct) {
  var struct$1 = S$RescriptStruct.option(struct);
  return Object.assign(struct$1, structOperations);
}

function nullable(struct) {
  var struct$1 = S$RescriptStruct.$$null(struct);
  return Object.assign(struct$1, structOperations);
}

function array(struct) {
  var struct$1 = S$RescriptStruct.array(struct);
  return Object.assign(struct$1, structOperations);
}

function record(struct) {
  var struct$1 = S$RescriptStruct.dict(struct);
  return Object.assign(struct$1, structOperations);
}

function jsonString(struct) {
  var struct$1 = S$RescriptStruct.jsonString(struct);
  return Object.assign(struct$1, structOperations);
}

function union(structs) {
  var struct = S$RescriptStruct.union(structs);
  return Object.assign(struct, structOperations);
}

function tuple(structs) {
  var struct = S$RescriptStruct.tuple(function (s) {
        return structs.map(function (struct, idx) {
                    return s.i(idx, struct);
                  });
      });
  return Object.assign(struct, structOperations);
}

function literal(literal$1) {
  if (Number.isNaN(literal$1)) {
    return Js_exn.raiseError("[rescript-struct] Failed to create a NaN literal struct. Use S.nan instead.");
  }
  var struct = S$RescriptStruct.literal(literal$1);
  return Object.assign(struct, structOperations);
}

function custom(name, maybeParser, maybeSerializer, param) {
  var struct = S$RescriptStruct.custom(name, (function (s) {
          var struct = s.s;
          var effectCtx_struct = Object.assign(struct, structOperations);
          var effectCtx_fail = function (message) {
            return s.f(undefined, message);
          };
          var effectCtx = {
            struct: effectCtx_struct,
            fail: effectCtx_fail
          };
          return {
                  p: maybeParser !== undefined ? (function (v) {
                        return maybeParser(v, effectCtx);
                      }) : undefined,
                  s: maybeSerializer !== undefined ? (function (v) {
                        return maybeSerializer(v, effectCtx);
                      }) : undefined
                };
        }));
  return Object.assign(struct, structOperations);
}

Object.assign(structOperations, {
      parse: parse,
      parseOrThrow: parseOrThrow,
      parseAsync: parseAsync,
      serialize: serialize,
      serializeOrThrow: serializeOrThrow,
      transform: transform,
      refine: refine,
      asyncParserRefine: asyncParserRefine,
      optional: (function () {
          return optional(this);
        }),
      nullable: (function () {
          return nullable(this);
        }),
      describe: describe,
      description: description,
      default: $$default
    });

var string = Object.assign(S$RescriptStruct.string, structOperations);

var $$boolean = Object.assign(S$RescriptStruct.bool, structOperations);

var integer = Object.assign(S$RescriptStruct.$$int, structOperations);

var number = Object.assign(S$RescriptStruct.$$float, structOperations);

var never = Object.assign(S$RescriptStruct.never, structOperations);

var unknown = Object.assign(S$RescriptStruct.unknown, structOperations);

var json = Object.assign(S$RescriptStruct.json, structOperations);

var struct = S$RescriptStruct.variant(S$RescriptStruct.literal(NaN), (function (param) {
        
      }));

var nan = Object.assign(struct, structOperations);

var objectStructOperations = {};

function strict() {
  var struct = this;
  return Object.assign(S$RescriptStruct.$$Object.strict(struct), objectStructOperations);
}

function strip() {
  var struct = this;
  return Object.assign(S$RescriptStruct.$$Object.strip(struct), objectStructOperations);
}

function factory(definer) {
  return Object.assign(S$RescriptStruct.object(function (s) {
                  var definition = {};
                  var fieldNames = Object.keys(definer);
                  for(var idx = 0 ,idx_finish = fieldNames.length; idx < idx_finish; ++idx){
                    var fieldName = fieldNames[idx];
                    var struct = definer[fieldName];
                    definition[fieldName] = s.f(fieldName, struct);
                  }
                  return definition;
                }), objectStructOperations);
}

Object.assign(objectStructOperations, structOperations);

Object.assign(objectStructOperations, {
      strict: strict,
      strip: strip
    });

var $$Error = {};

var Result = {};

var $$Object = {
  factory: factory
};

export {
  $$Error ,
  Result ,
  string ,
  $$boolean ,
  integer ,
  number ,
  never ,
  unknown ,
  json ,
  nan ,
  optional ,
  nullable ,
  array ,
  record ,
  jsonString ,
  union ,
  literal ,
  tuple ,
  custom ,
  $$Object ,
}
/*  Not a pure module */
