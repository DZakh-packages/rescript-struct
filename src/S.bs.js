// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Js_exn = require("rescript/lib/js/js_exn.js");
var Js_dict = require("rescript/lib/js/js_dict.js");
var Js_types = require("rescript/lib/js/js_types.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");

function stringify(any) {
  if (any === undefined) {
    return "undefined";
  }
  var string = JSON.stringify(Caml_option.valFromOption(any));
  if (string !== undefined) {
    return string;
  } else {
    return "\"???\"";
  }
}

var Exception = /* @__PURE__ */Caml_exceptions.create("S.Error.Internal.Exception");

function raise(code) {
  throw {
        RE_EXN_ID: Exception,
        _1: {
          c: code,
          p: ""
        },
        Error: new Error()
      };
}

function toParseError(internalError) {
  var path = internalError.p;
  var tmp = path === "" ? [] : path.split(",");
  return {
          operation: /* Parsing */1,
          code: internalError.c,
          path: tmp
        };
}

function toSerializeError(internalError) {
  var path = internalError.p;
  var tmp = path === "" ? [] : path.split(",");
  return {
          operation: /* Serializing */0,
          code: internalError.c,
          path: tmp
        };
}

function prependLocation(error, $$location) {
  var path = error.p;
  var tmp = path === "" ? $$location : "" + $$location + "," + path + "";
  return {
          c: error.c,
          p: tmp
        };
}

function raise$1(expected, received) {
  return raise({
              TAG: /* UnexpectedValue */2,
              expected: stringify(expected),
              received: stringify(received)
            });
}

function panic($$location) {
  throw new Error("[rescript-struct] " + ("For a " + $$location + " either a parser, or a serializer is required") + "");
}

function panic$1(param) {
  throw new Error("[rescript-struct] Unreachable");
}

function panic$2(param) {
  throw new Error("[rescript-struct] A Union struct factory require at least two structs");
}

function prependLocation$1(error, $$location) {
  return {
          operation: error.operation,
          code: error.code,
          path: [$$location].concat(error.path)
        };
}

function raiseCustom(error) {
  throw {
        RE_EXN_ID: Exception,
        _1: {
          c: error.code,
          p: error.path.toString()
        },
        Error: new Error()
      };
}

function raise$2(message) {
  throw {
        RE_EXN_ID: Exception,
        _1: {
          c: {
            TAG: /* OperationFailed */0,
            _0: message
          },
          p: ""
        },
        Error: new Error()
      };
}

function toReason(nestedLevelOpt, error) {
  var nestedLevel = nestedLevelOpt !== undefined ? nestedLevelOpt : 0;
  var reason = error.code;
  if (typeof reason === "number") {
    switch (reason) {
      case /* MissingParser */0 :
          return "Struct parser is missing";
      case /* MissingSerializer */1 :
          return "Struct serializer is missing";
      case /* UnexpectedAsync */2 :
          return "Encountered unexpected asynchronous transform or refine. Use parseAsyncWith instead of parseWith";
      
    }
  } else {
    switch (reason.TAG | 0) {
      case /* OperationFailed */0 :
          return reason._0;
      case /* UnexpectedType */1 :
      case /* UnexpectedValue */2 :
          break;
      case /* TupleSize */3 :
          return "Expected Tuple with " + reason.expected.toString() + " items, received " + reason.received.toString() + "";
      case /* ExcessField */4 :
          return "Encountered disallowed excess key \"" + reason._0 + "\" on an object. Use Deprecated to ignore a specific field, or S.Object.strip to ignore excess keys completely";
      case /* InvalidUnion */5 :
          var lineBreak = "\n" + " ".repeat((nestedLevel << 1)) + "";
          var array = reason._0.map(function (error) {
                var reason = toReason(nestedLevel + 1, error);
                var nonEmptyPath = error.path;
                var $$location = nonEmptyPath.length !== 0 ? "Failed at " + (
                    nonEmptyPath.length !== 0 ? nonEmptyPath.map(function (pathItem) {
                              return "[" + pathItem + "]";
                            }).join("") : "root"
                  ) + ". " : "";
                return "- " + $$location + "" + reason + "";
              });
          var reasons = Array.from(new Set(array));
          return "Invalid union with following errors" + lineBreak + "" + reasons.join(lineBreak) + "";
      
    }
  }
  return "Expected " + reason.expected + ", received " + reason.received + "";
}

function toString(error) {
  var match = error.operation;
  var operation = match ? "parsing" : "serializing";
  var reason = toReason(undefined, error);
  var path = error.path;
  var pathText = path.length !== 0 ? path.map(function (pathItem) {
            return "[" + pathItem + "]";
          }).join("") : "root";
  return "Failed " + operation + " at " + pathText + ". Reason: " + reason + "";
}

var Raised = /* @__PURE__ */Caml_exceptions.create("S.Raised");

function planSyncTransformation(ctx, transformation) {
  var prevSyncTransformation = ctx.s;
  var prevAsyncTransformation = ctx.a;
  var match = ctx.p;
  if (match !== 1) {
    if (match !== 0) {
      ctx.a = (function (input) {
          return prevAsyncTransformation(input).then(transformation);
        });
    } else {
      ctx.p = /* OnlySync */1;
      ctx.s = transformation;
    }
  } else {
    ctx.s = (function (input) {
        return transformation(prevSyncTransformation(input));
      });
  }
}

function planAsyncTransformation(ctx, transformation) {
  var prevAsyncTransformation = ctx.a;
  var match = ctx.p;
  if (match !== 1) {
    if (match !== 0) {
      ctx.a = (function (input) {
          return prevAsyncTransformation(input).then(transformation);
        });
    } else {
      ctx.p = /* OnlyAsync */2;
      ctx.a = transformation;
    }
  } else {
    ctx.p = /* SyncAndAsync */3;
    ctx.a = transformation;
  }
}

function empty(param, param$1) {
  
}

function compile(transformationFactory, struct) {
  var ctx = {
    p: /* NoTransformation */0,
    s: undefined,
    a: undefined
  };
  transformationFactory(ctx, struct);
  var match = ctx.p;
  switch (match) {
    case /* NoTransformation */0 :
        return /* NoOperation */0;
    case /* OnlySync */1 :
        return {
                TAG: /* SyncOperation */0,
                _0: ctx.s
              };
    case /* OnlyAsync */2 :
        return {
                TAG: /* AsyncOperation */1,
                _0: (function (input) {
                    return function () {
                      return ctx.a(input);
                    };
                  })
              };
    case /* SyncAndAsync */3 :
        return {
                TAG: /* AsyncOperation */1,
                _0: (function (input) {
                    var syncOutput = ctx.s(input);
                    return function () {
                      return ctx.a(syncOutput);
                    };
                  })
              };
    
  }
}

function classify(struct) {
  return struct.t;
}

function name(struct) {
  return struct.n;
}

function isAsyncParse(struct) {
  var match = struct.p;
  if (typeof match === "number" || match.TAG === /* SyncOperation */0) {
    return false;
  } else {
    return true;
  }
}

function raiseUnexpectedTypeError(input, struct) {
  var number = Js_types.classify(input);
  var tmp;
  if (typeof number === "number") {
    switch (number) {
      case /* JSFalse */0 :
      case /* JSTrue */1 :
          tmp = "Bool";
          break;
      case /* JSNull */2 :
          tmp = "Null";
          break;
      case /* JSUndefined */3 :
          tmp = "Option";
          break;
      
    }
  } else {
    switch (number.TAG | 0) {
      case /* JSNumber */0 :
          tmp = Number.isNaN(number._0) ? "NaN Literal (NaN)" : "Float";
          break;
      case /* JSString */1 :
          tmp = "String";
          break;
      case /* JSFunction */2 :
          tmp = "Function";
          break;
      case /* JSObject */3 :
          tmp = "Object";
          break;
      case /* JSSymbol */4 :
          tmp = "Symbol";
          break;
      case /* JSBigInt */5 :
          tmp = "BigInt";
          break;
      
    }
  }
  return raise({
              TAG: /* UnexpectedType */1,
              expected: struct.n,
              received: tmp
            });
}

function make(name, tagged, parseTransformationFactory, serializeTransformationFactory, maybeInlinedRefinement, maybeMetadataDict, param) {
  var struct = {
    n: name,
    t: tagged,
    pf: parseTransformationFactory,
    sf: serializeTransformationFactory,
    s: undefined,
    p: undefined,
    i: maybeInlinedRefinement,
    m: maybeMetadataDict
  };
  struct.p = compile(struct.pf, struct);
  struct.s = compile(struct.sf, struct);
  return struct;
}

function parseWith(any, struct) {
  try {
    var fn = struct.p;
    if (typeof fn === "number") {
      return {
              TAG: /* Ok */0,
              _0: any
            };
    } else if (fn.TAG === /* SyncOperation */0) {
      return {
              TAG: /* Ok */0,
              _0: fn._0(any)
            };
    } else {
      return raise(/* UnexpectedAsync */2);
    }
  }
  catch (raw_internalError){
    var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
    if (internalError.RE_EXN_ID === Exception) {
      return {
              TAG: /* Error */1,
              _0: toParseError(internalError._1)
            };
    }
    throw internalError;
  }
}

function parseOrRaiseWith(any, struct) {
  try {
    var fn = struct.p;
    if (typeof fn === "number") {
      return any;
    } else if (fn.TAG === /* SyncOperation */0) {
      return fn._0(any);
    } else {
      return raise(/* UnexpectedAsync */2);
    }
  }
  catch (raw_internalError){
    var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
    if (internalError.RE_EXN_ID === Exception) {
      throw {
            RE_EXN_ID: Raised,
            _1: toParseError(internalError._1),
            Error: new Error()
          };
    }
    throw internalError;
  }
}

function parseAsyncWith(any, struct) {
  try {
    var fn = struct.p;
    if (typeof fn === "number") {
      return Promise.resolve({
                  TAG: /* Ok */0,
                  _0: any
                });
    } else if (fn.TAG === /* SyncOperation */0) {
      return Promise.resolve({
                  TAG: /* Ok */0,
                  _0: fn._0(any)
                });
    } else {
      return fn._0(any)().then(function (value) {
                    return {
                            TAG: /* Ok */0,
                            _0: value
                          };
                  }).catch(function (exn) {
                  if (exn.RE_EXN_ID === Exception) {
                    return {
                            TAG: /* Error */1,
                            _0: toParseError(exn._1)
                          };
                  }
                  throw exn;
                });
    }
  }
  catch (raw_internalError){
    var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
    if (internalError.RE_EXN_ID === Exception) {
      return Promise.resolve({
                  TAG: /* Error */1,
                  _0: toParseError(internalError._1)
                });
    }
    throw internalError;
  }
}

function parseAsyncInStepsWith(any, struct) {
  try {
    var fn = struct.p;
    var tmp;
    if (typeof fn === "number") {
      tmp = (function (param) {
          return Promise.resolve({
                      TAG: /* Ok */0,
                      _0: any
                    });
        });
    } else if (fn.TAG === /* SyncOperation */0) {
      var syncValue = fn._0(any);
      tmp = (function (param) {
          return Promise.resolve({
                      TAG: /* Ok */0,
                      _0: syncValue
                    });
        });
    } else {
      var asyncFn = fn._0(any);
      tmp = (function (param) {
          return asyncFn().then(function (value) {
                        return {
                                TAG: /* Ok */0,
                                _0: value
                              };
                      }).catch(function (exn) {
                      if (exn.RE_EXN_ID === Exception) {
                        return {
                                TAG: /* Error */1,
                                _0: toParseError(exn._1)
                              };
                      }
                      throw exn;
                    });
        });
    }
    return {
            TAG: /* Ok */0,
            _0: tmp
          };
  }
  catch (raw_internalError){
    var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
    if (internalError.RE_EXN_ID === Exception) {
      return {
              TAG: /* Error */1,
              _0: toParseError(internalError._1)
            };
    }
    throw internalError;
  }
}

function serializeWith(value, struct) {
  try {
    var fn = struct.s;
    var tmp;
    tmp = typeof fn === "number" ? value : (
        fn.TAG === /* SyncOperation */0 ? fn._0(value) : panic$1(undefined)
      );
    return {
            TAG: /* Ok */0,
            _0: tmp
          };
  }
  catch (raw_internalError){
    var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
    if (internalError.RE_EXN_ID === Exception) {
      return {
              TAG: /* Error */1,
              _0: toSerializeError(internalError._1)
            };
    }
    throw internalError;
  }
}

function serializeOrRaiseWith(value, struct) {
  try {
    var fn = struct.s;
    if (typeof fn === "number") {
      return value;
    } else if (fn.TAG === /* SyncOperation */0) {
      return fn._0(value);
    } else {
      return panic$1(undefined);
    }
  }
  catch (raw_internalError){
    var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
    if (internalError.RE_EXN_ID === Exception) {
      throw {
            RE_EXN_ID: Raised,
            _1: toSerializeError(internalError._1),
            Error: new Error()
          };
    }
    throw internalError;
  }
}

function make$1(namespace, name) {
  return "" + namespace + ":" + name + "";
}

var Id = {
  make: make$1
};

function get(struct, id) {
  var option = struct.m;
  if (option !== undefined) {
    return Js_dict.get(Caml_option.valFromOption(option), id);
  }
  
}

function set(struct, id, metadata) {
  var metadataChange = {};
  return make(struct.n, struct.t, struct.pf, struct.sf, undefined, Caml_option.some(Object.assign({}, struct.m, (metadataChange[id] = metadata, metadataChange))), undefined);
}

function refine(struct, maybeRefineParser, maybeRefineSerializer, param) {
  if (maybeRefineParser === undefined && maybeRefineSerializer === undefined) {
    panic("struct factory Refine");
  }
  var nextParseTransformationFactory = maybeRefineParser !== undefined ? (function (ctx, compilingStruct) {
        struct.pf(ctx, compilingStruct);
        planSyncTransformation(ctx, (function (input) {
                maybeRefineParser(input);
                return input;
              }));
      }) : struct.pf;
  return make(struct.n, struct.t, nextParseTransformationFactory, maybeRefineSerializer !== undefined ? (function (ctx, compilingStruct) {
                  planSyncTransformation(ctx, (function (input) {
                          maybeRefineSerializer(input);
                          return input;
                        }));
                  struct.sf(ctx, compilingStruct);
                }) : struct.sf, nextParseTransformationFactory === struct.pf ? struct.i : undefined, struct.m, undefined);
}

function asyncRefine(struct, parser, param) {
  return make(struct.n, struct.t, (function (ctx, compilingStruct) {
                struct.pf(ctx, compilingStruct);
                planAsyncTransformation(ctx, (function (input) {
                        return parser(input).then(function (param) {
                                    return input;
                                  });
                      }));
              }), struct.sf, undefined, struct.m, undefined);
}

function transform(struct, maybeTransformParser, maybeTransformSerializer, param) {
  if (maybeTransformParser === undefined && maybeTransformSerializer === undefined) {
    panic("struct factory Transform");
  }
  return make(struct.n, struct.t, (function (ctx, compilingStruct) {
                struct.pf(ctx, compilingStruct);
                if (maybeTransformParser !== undefined) {
                  return planSyncTransformation(ctx, maybeTransformParser);
                } else {
                  return planSyncTransformation(ctx, (function (param) {
                                return raise(/* MissingParser */0);
                              }));
                }
              }), (function (ctx, compilingStruct) {
                if (maybeTransformSerializer !== undefined) {
                  planSyncTransformation(ctx, maybeTransformSerializer);
                } else {
                  planSyncTransformation(ctx, (function (param) {
                          return raise(/* MissingSerializer */1);
                        }));
                }
                struct.sf(ctx, compilingStruct);
              }), undefined, struct.m, undefined);
}

function advancedTransform(struct, maybeTransformParser, maybeTransformSerializer, param) {
  if (maybeTransformParser === undefined && maybeTransformSerializer === undefined) {
    panic("struct factory Transform");
  }
  return make(struct.n, struct.t, (function (ctx, compilingStruct) {
                struct.pf(ctx, compilingStruct);
                if (maybeTransformParser === undefined) {
                  return planSyncTransformation(ctx, (function (param) {
                                return raise(/* MissingParser */0);
                              }));
                }
                var syncTransformation = maybeTransformParser(compilingStruct);
                if (syncTransformation.TAG === /* Sync */0) {
                  return planSyncTransformation(ctx, syncTransformation._0);
                } else {
                  return planAsyncTransformation(ctx, syncTransformation._0);
                }
              }), (function (ctx, compilingStruct) {
                if (maybeTransformSerializer !== undefined) {
                  var syncTransformation = maybeTransformSerializer(compilingStruct);
                  if (syncTransformation.TAG === /* Sync */0) {
                    planSyncTransformation(ctx, syncTransformation._0);
                  } else {
                    planAsyncTransformation(ctx, syncTransformation._0);
                  }
                } else {
                  planSyncTransformation(ctx, (function (param) {
                          return raise(/* MissingSerializer */1);
                        }));
                }
                struct.sf(ctx, compilingStruct);
              }), undefined, struct.m, undefined);
}

function advancedPreprocess(struct, maybePreprocessParser, maybePreprocessSerializer, param) {
  if (maybePreprocessParser === undefined && maybePreprocessSerializer === undefined) {
    panic("struct factory Preprocess");
  }
  var unionStructs = struct.t;
  if (typeof unionStructs !== "number" && unionStructs.TAG === /* Union */6) {
    return make(struct.n, {
                TAG: /* Union */6,
                _0: unionStructs._0.map(function (unionStruct) {
                      return advancedPreprocess(unionStruct, maybePreprocessParser, maybePreprocessSerializer, undefined);
                    })
              }, struct.pf, struct.sf, undefined, struct.m, undefined);
  }
  return make(struct.n, struct.t, (function (ctx, compilingStruct) {
                if (maybePreprocessParser !== undefined) {
                  var syncTransformation = maybePreprocessParser(compilingStruct);
                  if (syncTransformation.TAG === /* Sync */0) {
                    planSyncTransformation(ctx, syncTransformation._0);
                  } else {
                    planAsyncTransformation(ctx, syncTransformation._0);
                  }
                } else {
                  planSyncTransformation(ctx, (function (param) {
                          return raise(/* MissingParser */0);
                        }));
                }
                struct.pf(ctx, compilingStruct);
              }), (function (ctx, compilingStruct) {
                struct.sf(ctx, compilingStruct);
                if (maybePreprocessSerializer === undefined) {
                  return planSyncTransformation(ctx, (function (param) {
                                return raise(/* MissingSerializer */1);
                              }));
                }
                var syncTransformation = maybePreprocessSerializer(compilingStruct);
                if (syncTransformation.TAG === /* Sync */0) {
                  return planSyncTransformation(ctx, syncTransformation._0);
                } else {
                  return planAsyncTransformation(ctx, syncTransformation._0);
                }
              }), undefined, struct.m, undefined);
}

function custom(name, maybeCustomParser, maybeCustomSerializer, param) {
  if (maybeCustomParser === undefined && maybeCustomSerializer === undefined) {
    panic("Custom struct factory");
  }
  return make(name, /* Unknown */1, (function (ctx, param) {
                if (maybeCustomParser !== undefined) {
                  return planSyncTransformation(ctx, Caml_option.valFromOption(maybeCustomParser));
                } else {
                  return planSyncTransformation(ctx, (function (param) {
                                return raise(/* MissingParser */0);
                              }));
                }
              }), (function (ctx, param) {
                if (maybeCustomSerializer !== undefined) {
                  return planSyncTransformation(ctx, Caml_option.valFromOption(maybeCustomSerializer));
                } else {
                  return planSyncTransformation(ctx, (function (param) {
                                return raise(/* MissingSerializer */1);
                              }));
                }
              }), undefined, undefined, undefined);
}

function factory(innerLiteral, variant) {
  var tagged = {
    TAG: /* Literal */0,
    _0: innerLiteral
  };
  var makeParseTransformationFactory = function (literalValue, test) {
    return function (ctx, struct) {
      planSyncTransformation(ctx, (function (input) {
              if (test(input)) {
                if (literalValue === input) {
                  return variant;
                } else {
                  return raise$1(literalValue, input);
                }
              } else {
                return raiseUnexpectedTypeError(input, struct);
              }
            }));
    };
  };
  var makeSerializeTransformationFactory = function (output) {
    return function (ctx, param) {
      planSyncTransformation(ctx, (function (input) {
              if (input === variant) {
                return output;
              } else {
                return raise$1(variant, input);
              }
            }));
    };
  };
  if (typeof innerLiteral === "number") {
    switch (innerLiteral) {
      case /* EmptyNull */0 :
          return make("EmptyNull Literal (null)", tagged, (function (ctx, struct) {
                        planSyncTransformation(ctx, (function (input) {
                                if (input === null) {
                                  return variant;
                                } else {
                                  return raiseUnexpectedTypeError(input, struct);
                                }
                              }));
                      }), makeSerializeTransformationFactory(null), undefined, undefined, undefined);
      case /* EmptyOption */1 :
          return make("EmptyOption Literal (undefined)", tagged, (function (ctx, struct) {
                        planSyncTransformation(ctx, (function (input) {
                                if (input === undefined) {
                                  return variant;
                                } else {
                                  return raiseUnexpectedTypeError(input, struct);
                                }
                              }));
                      }), makeSerializeTransformationFactory(undefined), undefined, undefined, undefined);
      case /* NaN */2 :
          return make("NaN Literal (NaN)", tagged, (function (ctx, struct) {
                        planSyncTransformation(ctx, (function (input) {
                                if (Number.isNaN(input)) {
                                  return variant;
                                } else {
                                  return raiseUnexpectedTypeError(input, struct);
                                }
                              }));
                      }), makeSerializeTransformationFactory(NaN), undefined, undefined, undefined);
      
    }
  } else {
    switch (innerLiteral.TAG | 0) {
      case /* String */0 :
          var string = innerLiteral._0;
          return make("String Literal (\"" + string + "\")", tagged, makeParseTransformationFactory(string, (function (input) {
                            return typeof input === "string";
                          })), makeSerializeTransformationFactory(string), undefined, undefined, undefined);
      case /* Int */1 :
          var $$int = innerLiteral._0;
          return make("Int Literal (" + $$int.toString() + ")", tagged, makeParseTransformationFactory($$int, (function (input) {
                            if (typeof input === "number" && input < 2147483648 && input > -2147483649) {
                              return input % 1 === 0;
                            } else {
                              return false;
                            }
                          })), makeSerializeTransformationFactory($$int), undefined, undefined, undefined);
      case /* Float */2 :
          var $$float = innerLiteral._0;
          return make("Float Literal (" + $$float.toString() + ")", tagged, makeParseTransformationFactory($$float, (function (input) {
                            return typeof input === "number";
                          })), makeSerializeTransformationFactory($$float), undefined, undefined, undefined);
      case /* Bool */3 :
          var bool = innerLiteral._0;
          return make("Bool Literal (" + bool.toString() + ")", tagged, makeParseTransformationFactory(bool, (function (input) {
                            return typeof input === "boolean";
                          })), makeSerializeTransformationFactory(bool), undefined, undefined, undefined);
      
    }
  }
}

function factory$1(innerLiteral) {
  if (typeof innerLiteral === "number") {
    return factory(innerLiteral, undefined);
  } else {
    return factory(innerLiteral, innerLiteral._0);
  }
}

var metadataId = "rescript-struct:Object_UnknownKeys";

function classify$1(struct) {
  var option = get(struct, metadataId);
  if (option !== undefined) {
    return Caml_option.valFromOption(option);
  } else {
    return /* Strip */1;
  }
}

var getMaybeExcessKey = (function(object, innerStructsDict) {
    for (var key in object) {
      if (!Object.prototype.hasOwnProperty.call(innerStructsDict, key)) {
        return key
      }
    }
  });

function factory$2(param) {
  var fieldsArray = arguments;
  var fields = Js_dict.fromArray(fieldsArray);
  var fieldNames = Object.keys(fields);
  return make("Object", {
              TAG: /* Object */4,
              fields: fields,
              fieldNames: fieldNames
            }, (function (ctx, struct) {
                var unknownKeys = classify$1(struct);
                var noopOps = [];
                var syncOps = [];
                var asyncOps = [];
                for(var idx = 0 ,idx_finish = fieldNames.length; idx < idx_finish; ++idx){
                  var fieldName = fieldNames[idx];
                  var fieldStruct = fields[fieldName];
                  var fn = fieldStruct.p;
                  if (typeof fn === "number") {
                    noopOps.push([
                          idx,
                          fieldName
                        ]);
                  } else if (fn.TAG === /* SyncOperation */0) {
                    syncOps.push([
                          idx,
                          fieldName,
                          fn._0
                        ]);
                  } else {
                    syncOps.push([
                          idx,
                          fieldName,
                          fn._0
                        ]);
                    asyncOps.push([
                          idx,
                          fieldName
                        ]);
                  }
                }
                var withAsyncOps = asyncOps.length > 0;
                planSyncTransformation(ctx, (function (input) {
                        if ((typeof input === "object" && input !== null && !Array.isArray(input)) === false) {
                          raiseUnexpectedTypeError(input, struct);
                        }
                        var newArray = [];
                        for(var idx = 0 ,idx_finish = syncOps.length; idx < idx_finish; ++idx){
                          var match = syncOps[idx];
                          var fieldName = match[1];
                          var fieldData = input[fieldName];
                          try {
                            var value = match[2](fieldData);
                            newArray[match[0]] = value;
                          }
                          catch (raw_internalError){
                            var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                            if (internalError.RE_EXN_ID === Exception) {
                              throw {
                                    RE_EXN_ID: Exception,
                                    _1: prependLocation(internalError._1, fieldName),
                                    Error: new Error()
                                  };
                            }
                            throw internalError;
                          }
                        }
                        for(var idx$1 = 0 ,idx_finish$1 = noopOps.length; idx$1 < idx_finish$1; ++idx$1){
                          var match$1 = noopOps[idx$1];
                          var fieldData$1 = input[match$1[1]];
                          newArray[match$1[0]] = fieldData$1;
                        }
                        if (unknownKeys === /* Strict */0) {
                          var excessKey = getMaybeExcessKey(input, fields);
                          if (excessKey !== undefined) {
                            raise({
                                  TAG: /* ExcessField */4,
                                  _0: excessKey
                                });
                          }
                          
                        }
                        if (withAsyncOps || newArray.length > 1) {
                          return newArray;
                        } else {
                          return newArray[0];
                        }
                      }));
                if (withAsyncOps) {
                  return planAsyncTransformation(ctx, (function (tempArray) {
                                return Promise.all(asyncOps.map(function (param) {
                                                  var fieldName = param[1];
                                                  return tempArray[param[0]]().catch(function (exn) {
                                                              throw exn.RE_EXN_ID === Exception ? ({
                                                                        RE_EXN_ID: Exception,
                                                                        _1: prependLocation(exn._1, fieldName)
                                                                      }) : exn;
                                                            });
                                                })).then(function (asyncFieldValues) {
                                            asyncFieldValues.forEach(function (fieldValue, idx) {
                                                  var match = asyncOps[idx];
                                                  tempArray[match[0]] = fieldValue;
                                                });
                                            return tempArray;
                                          });
                              }));
                }
                
              }), (function (ctx, param) {
                planSyncTransformation(ctx, (function (input) {
                        var unknown = {};
                        var fieldValues = fieldNames.length <= 1 ? [input] : input;
                        for(var idx = 0 ,idx_finish = fieldNames.length; idx < idx_finish; ++idx){
                          var fieldName = fieldNames[idx];
                          var fieldStruct = fields[fieldName];
                          var fieldValue = fieldValues[idx];
                          var fn = fieldStruct.s;
                          if (typeof fn === "number") {
                            unknown[fieldName] = fieldValue;
                          } else if (fn.TAG === /* SyncOperation */0) {
                            try {
                              var fieldData = fn._0(fieldValue);
                              unknown[fieldName] = fieldData;
                            }
                            catch (raw_internalError){
                              var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                              if (internalError.RE_EXN_ID === Exception) {
                                throw {
                                      RE_EXN_ID: Exception,
                                      _1: prependLocation(internalError._1, fieldName),
                                      Error: new Error()
                                    };
                              }
                              throw internalError;
                            }
                          } else {
                            panic$1(undefined);
                          }
                        }
                        return unknown;
                      }));
              }), undefined, undefined, undefined);
}

function strip(struct) {
  return set(struct, metadataId, /* Strip */1);
}

function strict(struct) {
  return set(struct, metadataId, /* Strict */0);
}

var value = (Symbol("rescript-struct:Object.FieldDefenition"));

function analyzeDefenitionSlice(defenitionCtx, defenitionSlice, path, inlinedPath) {
  if (defenitionSlice === value) {
    var originalFieldName = defenitionCtx.originalFieldNames[defenitionCtx.registeredFieldsCount];
    defenitionCtx.registeredFieldsCount = defenitionCtx.registeredFieldsCount + 1;
    defenitionCtx.inlinedPathesByOriginalFieldNames[originalFieldName] = inlinedPath;
    defenitionCtx.pathesByOriginalFieldNames[originalFieldName] = path;
    return ;
  }
  if (typeof defenitionSlice === "object" && defenitionSlice !== null) {
    defenitionCtx.inlinedPreparationPathes.push(inlinedPath);
    defenitionCtx.inlinedPreparationValues.push(Array.isArray(defenitionSlice) ? "[]" : "{}");
    var defenitionSliceFieldNames = Object.keys(defenitionSlice);
    for(var idx = 0 ,idx_finish = defenitionSliceFieldNames.length; idx < idx_finish; ++idx){
      var defenitionSliceFieldName = defenitionSliceFieldNames[idx];
      var nextDefenitionSlice = defenitionSlice[defenitionSliceFieldName];
      var tmp = path === "" ? defenitionSliceFieldName : "" + path + "," + defenitionSliceFieldName + "";
      analyzeDefenitionSlice(defenitionCtx, nextDefenitionSlice, tmp, "" + inlinedPath + "[\"" + defenitionSliceFieldName + "\"]");
    }
    return ;
  }
  defenitionCtx.serializeDiscriminantValuesByInlinedPath[inlinedPath] = defenitionSlice;
  defenitionCtx.serializeDiscriminantInlinedPathes.push(inlinedPath);
}

function fromReadyDefenitionCtx(defenitionCtx) {
  var originalFieldNamesCount = defenitionCtx.originalFieldNames.length;
  if (defenitionCtx.registeredFieldsCount > originalFieldNamesCount) {
    throw new Error("[rescript-struct] The object defention has more registered fields than expected.");
  }
  if (defenitionCtx.registeredFieldsCount < originalFieldNamesCount) {
    throw new Error("[rescript-struct] The object defention contains fields that weren't registered.");
  }
  return {
          originalFields: defenitionCtx.originalFields,
          originalFieldNames: defenitionCtx.originalFieldNames,
          inlinedPathesByOriginalFieldNames: defenitionCtx.inlinedPathesByOriginalFieldNames,
          pathesByOriginalFieldNames: defenitionCtx.pathesByOriginalFieldNames,
          inlinedPreparationValues: defenitionCtx.inlinedPreparationValues,
          inlinedPreparationPathes: defenitionCtx.inlinedPreparationPathes,
          serializeDiscriminantValuesByInlinedPath: defenitionCtx.serializeDiscriminantValuesByInlinedPath,
          serializeDiscriminantInlinedPathes: defenitionCtx.serializeDiscriminantInlinedPathes
        };
}

function factory$3(defenition) {
  var defenitionCtx = {
    originalFieldNames: [],
    originalFields: {},
    registeredFieldsCount: 0,
    inlinedPreparationPathes: [],
    inlinedPreparationValues: [],
    inlinedPathesByOriginalFieldNames: {},
    pathesByOriginalFieldNames: {},
    serializeDiscriminantValuesByInlinedPath: {},
    serializeDiscriminantInlinedPathes: []
  };
  var defenitionSlice = defenition(defenitionCtx);
  analyzeDefenitionSlice(defenitionCtx, defenitionSlice, "", "");
  var instructions = fromReadyDefenitionCtx(defenitionCtx);
  return make("Object", {
              TAG: /* Object */4,
              fields: instructions.originalFields,
              fieldNames: instructions.originalFieldNames
            }, (function (ctx, struct) {
                var serializeDiscriminantInlinedPathes = instructions.serializeDiscriminantInlinedPathes;
                var inlinedPreparationPathes = instructions.inlinedPreparationPathes;
                var inlinedPreparationValues = instructions.inlinedPreparationValues;
                var inlinedPathesByOriginalFieldNames = instructions.inlinedPathesByOriginalFieldNames;
                var originalFieldNames = instructions.originalFieldNames;
                var originalFields = instructions.originalFields;
                var withUnknownKeysRefinement = classify$1(struct) === /* Strict */0;
                var parseFnsByOriginalFieldName = {};
                var asyncOps = [];
                var refinement = "if(typeof i!==\"object\"||i===null||Array.isArray(i)){u(i)}";
                var stringRef = "var t;";
                for(var idx = 0 ,idx_finish = inlinedPreparationPathes.length; idx < idx_finish; ++idx){
                  var preparationPath = inlinedPreparationPathes[idx];
                  var preparationInlinedValue = inlinedPreparationValues[idx];
                  stringRef = stringRef + ("t" + preparationPath + "=" + preparationInlinedValue + ";");
                }
                var preparation = stringRef;
                var stringRef$1 = "";
                for(var idx$1 = 0 ,idx_finish$1 = originalFieldNames.length; idx$1 < idx_finish$1; ++idx$1){
                  var originalFieldName = originalFieldNames[idx$1];
                  var inlinedPath = inlinedPathesByOriginalFieldNames[originalFieldName];
                  var fieldStruct = originalFields[originalFieldName];
                  var fn = fieldStruct.p;
                  var maybeParseFn;
                  if (typeof fn === "number") {
                    maybeParseFn = undefined;
                  } else if (fn.TAG === /* SyncOperation */0) {
                    maybeParseFn = fn._0;
                  } else {
                    asyncOps.push([
                          originalFieldName,
                          "TODO: original field name"
                        ]);
                    maybeParseFn = fn._0;
                  }
                  var match = fieldStruct.i;
                  if (maybeParseFn !== undefined) {
                    parseFnsByOriginalFieldName[originalFieldName] = maybeParseFn;
                    stringRef$1 = match !== undefined ? stringRef$1 + ("var v=i[\"" + originalFieldName + "\"];if(" + match + "){t" + inlinedPath + "=v}else{f=\"" + originalFieldName + "\";s(v,o[\"" + originalFieldName + "\"])}") : stringRef$1 + ("f=\"" + originalFieldName + "\",t" + inlinedPath + "=p[\"" + originalFieldName + "\"](i[\"" + originalFieldName + "\"]);");
                  } else {
                    stringRef$1 = stringRef$1 + ("t" + inlinedPath + ":i[\"" + originalFieldName + "\"];");
                  }
                }
                var tryContent = stringRef$1;
                var transformedObjectConstruction = "var f;" + ("try{" + tryContent + "}catch(e){c(e,f)}");
                var stringRef$2 = "for(var key in i){switch(key){";
                for(var idx$2 = 0 ,idx_finish$2 = originalFieldNames.length; idx$2 < idx_finish$2; ++idx$2){
                  var originalFieldName$1 = originalFieldNames[idx$2];
                  stringRef$2 = stringRef$2 + ("case\"" + originalFieldName$1 + "\":continue;");
                }
                var unknownKeysRefinement = stringRef$2 + "default:x(key)}}";
                var stringRef$3 = "";
                for(var idx$3 = 0 ,idx_finish$3 = serializeDiscriminantInlinedPathes.length; idx$3 < idx_finish$3; ++idx$3){
                  var inlinedPath$1 = serializeDiscriminantInlinedPathes[idx$3];
                  stringRef$3 = stringRef$3 + ("t" + inlinedPath$1 + "=d[\`" + inlinedPath$1 + "\`];");
                }
                var serializeDiscriminants = stringRef$3;
                var inlinedParseFunction = "function(i){" + ("" + refinement + "" + preparation + "" + transformedObjectConstruction + "" + (
                    withUnknownKeysRefinement ? unknownKeysRefinement : ""
                  ) + "" + serializeDiscriminants + "return t") + "}";
                planSyncTransformation(ctx, new Function("c", "p", "o", "d", "u", "s", "x", "return " + inlinedParseFunction + "")((function (exn, fieldName) {
                            throw exn.RE_EXN_ID === Exception ? ({
                                      RE_EXN_ID: Exception,
                                      _1: prependLocation(exn._1, fieldName)
                                    }) : exn;
                          }), parseFnsByOriginalFieldName, originalFields, instructions.serializeDiscriminantValuesByInlinedPath, (function (input) {
                            return raiseUnexpectedTypeError(input, struct);
                          }), raiseUnexpectedTypeError, (function (exccessFieldName) {
                            return raise({
                                        TAG: /* ExcessField */4,
                                        _0: exccessFieldName
                                      });
                          })));
              }), (function (ctx, param) {
                var serializeDiscriminantInlinedPathes = instructions.serializeDiscriminantInlinedPathes;
                var serializeDiscriminantValuesByInlinedPath = instructions.serializeDiscriminantValuesByInlinedPath;
                var pathesByOriginalFieldNames = instructions.pathesByOriginalFieldNames;
                var inlinedPathesByOriginalFieldNames = instructions.inlinedPathesByOriginalFieldNames;
                var originalFieldNames = instructions.originalFieldNames;
                var originalFields = instructions.originalFields;
                var serializeFnsByOriginalFieldName = {};
                var stringRef = "";
                for(var idx = 0 ,idx_finish = serializeDiscriminantInlinedPathes.length; idx < idx_finish; ++idx){
                  var inlinedPath = serializeDiscriminantInlinedPathes[idx];
                  stringRef = stringRef + ("if(" + ("t" + inlinedPath + "!==d[\`" + inlinedPath + "\`]") + "){" + ("r(\`" + inlinedPath + "\`,t" + inlinedPath + ")") + "}");
                }
                var serializeDiscriminants = stringRef;
                var contentRef = "return{";
                for(var idx$1 = 0 ,idx_finish$1 = originalFieldNames.length; idx$1 < idx_finish$1; ++idx$1){
                  var originalFieldName = originalFieldNames[idx$1];
                  var fieldStruct = originalFields[originalFieldName];
                  var inlinedPath$1 = Js_dict.get(inlinedPathesByOriginalFieldNames, originalFieldName);
                  if (inlinedPath$1 !== undefined) {
                    var fn = fieldStruct.s;
                    if (typeof fn === "number") {
                      contentRef = contentRef + ("\"" + originalFieldName + "\":t" + inlinedPath$1 + ",");
                    } else if (fn.TAG === /* SyncOperation */0) {
                      serializeFnsByOriginalFieldName[originalFieldName] = fn._0;
                      contentRef = contentRef + ("\"" + originalFieldName + "\":(f=\"" + originalFieldName + "\",s[\"" + originalFieldName + "\"](t" + inlinedPath$1 + ")),");
                    } else {
                      panic$1(undefined);
                    }
                  } else {
                    var taggedLiteral = fieldStruct.t._0;
                    var inlinedValue;
                    if (typeof taggedLiteral === "number") {
                      switch (taggedLiteral) {
                        case /* EmptyNull */0 :
                            inlinedValue = "null";
                            break;
                        case /* EmptyOption */1 :
                            inlinedValue = "undefined";
                            break;
                        case /* NaN */2 :
                            inlinedValue = "NaN";
                            break;
                        
                      }
                    } else {
                      inlinedValue = taggedLiteral.TAG === /* String */0 ? "\"" + taggedLiteral._0 + "\"" : taggedLiteral._0.toString();
                    }
                    contentRef = contentRef + ("\"" + originalFieldName + "\":" + inlinedValue + ",");
                  }
                }
                var tryContent = contentRef + "}";
                var originalObjectConstructionAndReturn = "try{" + tryContent + "}catch(e){c(e,f)}";
                var inlinedSerializeFunction = "function(t){" + ("" + serializeDiscriminants + "" + originalObjectConstructionAndReturn + "") + "}";
                planSyncTransformation(ctx, new Function("s", "d", "r", "c", "return " + inlinedSerializeFunction + "")(serializeFnsByOriginalFieldName, serializeDiscriminantValuesByInlinedPath, (function (inlinedPath, received) {
                            var serializeDiscriminantValue = serializeDiscriminantValuesByInlinedPath[inlinedPath];
                            return raise$1(serializeDiscriminantValue, received);
                          }), (function (exn, originalFieldName) {
                            var path = pathesByOriginalFieldNames[originalFieldName];
                            throw exn.RE_EXN_ID === Exception ? ({
                                      RE_EXN_ID: Exception,
                                      _1: prependLocation(exn._1, path)
                                    }) : exn;
                          })));
              }), undefined, undefined, undefined);
}

function field(defenitionCtx, originalFieldName, struct) {
  defenitionCtx.originalFieldNames.push(originalFieldName);
  defenitionCtx.originalFields[originalFieldName] = struct;
  return value;
}

function discriminant(defenitionCtx, originalFieldName, literal) {
  var struct = factory$1(literal);
  defenitionCtx.originalFieldNames.push(originalFieldName);
  defenitionCtx.originalFields[originalFieldName] = struct;
  defenitionCtx.registeredFieldsCount = defenitionCtx.registeredFieldsCount + 1;
}

function factory$4(param) {
  var transformationFactory = function (ctx, struct) {
    planSyncTransformation(ctx, (function (input) {
            return raiseUnexpectedTypeError(input, struct);
          }));
  };
  return make("Never", /* Never */0, transformationFactory, transformationFactory, undefined, undefined, undefined);
}

function factory$5(param) {
  return make("Unknown", /* Unknown */1, empty, empty, undefined, undefined, undefined);
}

var cuidRegex = /^c[^\s-]{8,}$/i;

var uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;

var emailRegex = /^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i;

function factory$6(param) {
  return make("String", /* String */2, (function (ctx, struct) {
                planSyncTransformation(ctx, (function (input) {
                        if (typeof input === "string") {
                          return input;
                        } else {
                          return raiseUnexpectedTypeError(input, struct);
                        }
                      }));
              }), empty, "typeof v===\"string\"", undefined, undefined);
}

function min(struct, maybeMessage, length) {
  var refiner = function (value) {
    if (value.length >= length) {
      return ;
    }
    var $$default = "String must be " + length.toString() + " or more characters long";
    raise$2(maybeMessage !== undefined ? Caml_option.valFromOption(maybeMessage) : $$default);
  };
  return refine(struct, refiner, refiner, undefined);
}

function max(struct, maybeMessage, length) {
  var refiner = function (value) {
    if (value.length <= length) {
      return ;
    }
    var $$default = "String must be " + length.toString() + " or fewer characters long";
    raise$2(maybeMessage !== undefined ? Caml_option.valFromOption(maybeMessage) : $$default);
  };
  return refine(struct, refiner, refiner, undefined);
}

function length(struct, maybeMessage, length$1) {
  var refiner = function (value) {
    if (value.length === length$1) {
      return ;
    }
    var $$default = "String must be exactly " + length$1.toString() + " characters long";
    raise$2(maybeMessage !== undefined ? Caml_option.valFromOption(maybeMessage) : $$default);
  };
  return refine(struct, refiner, refiner, undefined);
}

function email(struct, messageOpt, param) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid email address";
  var refiner = function (value) {
    if (!emailRegex.test(value)) {
      return raise$2(message);
    }
    
  };
  return refine(struct, refiner, refiner, undefined);
}

function uuid(struct, messageOpt, param) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid UUID";
  var refiner = function (value) {
    if (!uuidRegex.test(value)) {
      return raise$2(message);
    }
    
  };
  return refine(struct, refiner, refiner, undefined);
}

function cuid(struct, messageOpt, param) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid CUID";
  var refiner = function (value) {
    if (!cuidRegex.test(value)) {
      return raise$2(message);
    }
    
  };
  return refine(struct, refiner, refiner, undefined);
}

function url(struct, messageOpt, param) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid url";
  var refiner = function (value) {
    var tmp;
    try {
      new URL(value);
      tmp = true;
    }
    catch (exn){
      tmp = false;
    }
    if (!tmp) {
      return raise$2(message);
    }
    
  };
  return refine(struct, refiner, refiner, undefined);
}

function pattern(struct, messageOpt, re) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid";
  var refiner = function (value) {
    re.lastIndex = 0;
    if (!re.test(value)) {
      return raise$2(message);
    }
    
  };
  return refine(struct, refiner, refiner, undefined);
}

function trimmed(struct, param) {
  var transformer = function (prim) {
    return prim.trim();
  };
  return transform(struct, transformer, transformer, undefined);
}

function factory$7(innerStruct) {
  return make("Json", /* String */2, (function (ctx, struct) {
                var fn = innerStruct.p;
                var $$process = typeof fn === "number" ? (function (prim) {
                      return prim;
                    }) : fn._0;
                planSyncTransformation(ctx, (function (input) {
                        if (typeof input !== "string") {
                          return raiseUnexpectedTypeError(input, struct);
                        }
                        var __x;
                        try {
                          __x = JSON.parse(input);
                        }
                        catch (raw_obj){
                          var obj = Caml_js_exceptions.internalToOCamlException(raw_obj);
                          if (obj.RE_EXN_ID === Js_exn.$$Error) {
                            var option = obj._1.message;
                            __x = raise$2(option !== undefined ? Caml_option.valFromOption(option) : "Failed to parse JSON");
                          } else {
                            throw obj;
                          }
                        }
                        return $$process(__x);
                      }));
                var match = innerStruct.p;
                if (typeof match === "number" || match.TAG === /* SyncOperation */0) {
                  return ;
                } else {
                  return planAsyncTransformation(ctx, (function (asyncFn) {
                                return asyncFn();
                              }));
                }
              }), (function (ctx, param) {
                planSyncTransformation(ctx, (function (input) {
                        var fn = innerStruct.s;
                        var tmp;
                        tmp = typeof fn === "number" ? input : (
                            fn.TAG === /* SyncOperation */0 ? fn._0(input) : panic$1(undefined)
                          );
                        return JSON.stringify(tmp);
                      }));
              }), undefined, undefined, undefined);
}

function factory$8(param) {
  return make("Bool", /* Bool */5, (function (ctx, struct) {
                planSyncTransformation(ctx, (function (input) {
                        if (typeof input === "boolean") {
                          return input;
                        } else {
                          return raiseUnexpectedTypeError(input, struct);
                        }
                      }));
              }), empty, "typeof v===\"boolean\"", undefined, undefined);
}

function factory$9(param) {
  return make("Int", /* Int */3, (function (ctx, struct) {
                planSyncTransformation(ctx, (function (input) {
                        if (typeof input === "number" && input < 2147483648 && input > -2147483649 && input % 1 === 0) {
                          return input;
                        } else {
                          return raiseUnexpectedTypeError(input, struct);
                        }
                      }));
              }), empty, "typeof v===\"number\"&&v<2147483648&&v>-2147483649&&v%1===0", undefined, undefined);
}

function min$1(struct, maybeMessage, thanValue) {
  var refiner = function (value) {
    if (value >= thanValue) {
      return ;
    }
    var $$default = "Number must be greater than or equal to " + thanValue.toString() + "";
    raise$2(maybeMessage !== undefined ? Caml_option.valFromOption(maybeMessage) : $$default);
  };
  return refine(struct, refiner, refiner, undefined);
}

function max$1(struct, maybeMessage, thanValue) {
  var refiner = function (value) {
    if (value <= thanValue) {
      return ;
    }
    var $$default = "Number must be lower than or equal to " + thanValue.toString() + "";
    raise$2(maybeMessage !== undefined ? Caml_option.valFromOption(maybeMessage) : $$default);
  };
  return refine(struct, refiner, refiner, undefined);
}

function port(struct, messageOpt, param) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid port";
  var refiner = function (value) {
    if (value < 1 || value > 65535) {
      return raise$2(message);
    }
    
  };
  return refine(struct, refiner, refiner, undefined);
}

function factory$10(param) {
  return make("Float", /* Float */4, (function (ctx, struct) {
                planSyncTransformation(ctx, (function (input) {
                        if (typeof input === "number" && !Number.isNaN(input)) {
                          return input;
                        } else {
                          return raiseUnexpectedTypeError(input, struct);
                        }
                      }));
              }), empty, "typeof v===\"number\"&&!Number.isNaN(v)", undefined, undefined);
}

function factory$11(param) {
  return make("Date", /* Date */6, (function (ctx, struct) {
                planSyncTransformation(ctx, (function (input) {
                        if ((input instanceof Date) && !Number.isNaN(input.getTime())) {
                          return input;
                        } else {
                          return raiseUnexpectedTypeError(input, struct);
                        }
                      }));
              }), empty, undefined, undefined, undefined);
}

function factory$12(innerStruct) {
  return make("Null", {
              TAG: /* Null */2,
              _0: innerStruct
            }, (function (ctx, param) {
                var planSyncTransformation$1 = function (fn) {
                  planSyncTransformation(ctx, (function (input) {
                          if (input !== null) {
                            return Caml_option.some(fn(input));
                          }
                          
                        }));
                };
                var fn = innerStruct.p;
                if (typeof fn === "number") {
                  return planSyncTransformation(ctx, (function (prim) {
                                if (prim === null) {
                                  return ;
                                } else {
                                  return Caml_option.some(prim);
                                }
                              }));
                }
                if (fn.TAG === /* SyncOperation */0) {
                  return planSyncTransformation$1(fn._0);
                }
                planSyncTransformation$1(fn._0);
                planAsyncTransformation(ctx, (function (input) {
                        if (input !== undefined) {
                          return input().then(function (value) {
                                      return Caml_option.some(value);
                                    });
                        } else {
                          return Promise.resolve(undefined);
                        }
                      }));
              }), (function (ctx, param) {
                planSyncTransformation(ctx, (function (input) {
                        if (input === undefined) {
                          return null;
                        }
                        var value = Caml_option.valFromOption(input);
                        var fn = innerStruct.s;
                        if (typeof fn === "number") {
                          return value;
                        } else if (fn.TAG === /* SyncOperation */0) {
                          return fn._0(value);
                        } else {
                          return panic$1(undefined);
                        }
                      }));
              }), undefined, undefined, undefined);
}

function factory$13(innerStruct) {
  return make("Option", {
              TAG: /* Option */1,
              _0: innerStruct
            }, (function (ctx, param) {
                var planSyncTransformation$1 = function (fn) {
                  planSyncTransformation(ctx, (function (input) {
                          if (input !== undefined) {
                            return Caml_option.some(fn(Caml_option.valFromOption(input)));
                          }
                          
                        }));
                };
                var fn = innerStruct.p;
                if (typeof fn === "number") {
                  return ;
                }
                if (fn.TAG === /* SyncOperation */0) {
                  return planSyncTransformation$1(fn._0);
                }
                planSyncTransformation$1(fn._0);
                planAsyncTransformation(ctx, (function (input) {
                        if (input !== undefined) {
                          return input().then(function (value) {
                                      return Caml_option.some(value);
                                    });
                        } else {
                          return Promise.resolve(undefined);
                        }
                      }));
              }), (function (ctx, param) {
                planSyncTransformation(ctx, (function (input) {
                        if (input === undefined) {
                          return ;
                        }
                        var value = Caml_option.valFromOption(input);
                        var fn = innerStruct.s;
                        if (typeof fn === "number") {
                          return value;
                        } else if (fn.TAG === /* SyncOperation */0) {
                          return fn._0(value);
                        } else {
                          return panic$1(undefined);
                        }
                      }));
              }), undefined, undefined, undefined);
}

var metadataId$1 = "rescript-struct:Deprecated";

function factory$14(innerStruct, maybeMessage, param) {
  return set(factory$13(innerStruct), metadataId$1, maybeMessage !== undefined ? /* WithMessage */({
                  _0: maybeMessage
                }) : /* WithoutMessage */0);
}

function classify$2(struct) {
  return get(struct, metadataId$1);
}

function factory$15(innerStruct) {
  return make("Array", {
              TAG: /* Array */3,
              _0: innerStruct
            }, (function (ctx, struct) {
                planSyncTransformation(ctx, (function (input) {
                        if (Array.isArray(input) === false) {
                          return raiseUnexpectedTypeError(input, struct);
                        } else {
                          return input;
                        }
                      }));
                var planSyncTransformation$1 = function (fn) {
                  planSyncTransformation(ctx, (function (input) {
                          var newArray = [];
                          for(var idx = 0 ,idx_finish = input.length; idx < idx_finish; ++idx){
                            var innerData = input[idx];
                            try {
                              var value = fn(innerData);
                              newArray.push(value);
                            }
                            catch (raw_internalError){
                              var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                              if (internalError.RE_EXN_ID === Exception) {
                                throw {
                                      RE_EXN_ID: Exception,
                                      _1: prependLocation(internalError._1, idx.toString()),
                                      Error: new Error()
                                    };
                              }
                              throw internalError;
                            }
                          }
                          return newArray;
                        }));
                };
                var fn = innerStruct.p;
                if (typeof fn === "number") {
                  return ;
                }
                if (fn.TAG === /* SyncOperation */0) {
                  return planSyncTransformation$1(fn._0);
                }
                planSyncTransformation$1(fn._0);
                planAsyncTransformation(ctx, (function (input) {
                        return Promise.all(input.map(function (asyncFn, idx) {
                                        return asyncFn().catch(function (exn) {
                                                    throw exn.RE_EXN_ID === Exception ? ({
                                                              RE_EXN_ID: Exception,
                                                              _1: prependLocation(exn._1, idx.toString())
                                                            }) : exn;
                                                  });
                                      }));
                      }));
              }), (function (ctx, param) {
                var fn = innerStruct.s;
                if (typeof fn === "number") {
                  return ;
                }
                if (fn.TAG !== /* SyncOperation */0) {
                  return panic$1(undefined);
                }
                var fn$1 = fn._0;
                planSyncTransformation(ctx, (function (input) {
                        var newArray = [];
                        for(var idx = 0 ,idx_finish = input.length; idx < idx_finish; ++idx){
                          var innerData = input[idx];
                          try {
                            var value = fn$1(innerData);
                            newArray.push(value);
                          }
                          catch (raw_internalError){
                            var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                            if (internalError.RE_EXN_ID === Exception) {
                              throw {
                                    RE_EXN_ID: Exception,
                                    _1: prependLocation(internalError._1, idx.toString()),
                                    Error: new Error()
                                  };
                            }
                            throw internalError;
                          }
                        }
                        return newArray;
                      }));
              }), undefined, undefined, undefined);
}

function min$2(struct, maybeMessage, length) {
  var refiner = function (value) {
    if (value.length >= length) {
      return ;
    }
    var $$default = "Array must be " + length.toString() + " or more items long";
    raise$2(maybeMessage !== undefined ? Caml_option.valFromOption(maybeMessage) : $$default);
  };
  return refine(struct, refiner, refiner, undefined);
}

function max$2(struct, maybeMessage, length) {
  var refiner = function (value) {
    if (value.length <= length) {
      return ;
    }
    var $$default = "Array must be " + length.toString() + " or fewer items long";
    raise$2(maybeMessage !== undefined ? Caml_option.valFromOption(maybeMessage) : $$default);
  };
  return refine(struct, refiner, refiner, undefined);
}

function length$1(struct, maybeMessage, length$2) {
  var refiner = function (value) {
    if (value.length === length$2) {
      return ;
    }
    var $$default = "Array must be exactly " + length$2.toString() + " items long";
    raise$2(maybeMessage !== undefined ? Caml_option.valFromOption(maybeMessage) : $$default);
  };
  return refine(struct, refiner, refiner, undefined);
}

function factory$16(innerStruct) {
  return make("Dict", {
              TAG: /* Dict */7,
              _0: innerStruct
            }, (function (ctx, struct) {
                var planSyncTransformation$1 = function (fn) {
                  planSyncTransformation(ctx, (function (input) {
                          var newDict = {};
                          var keys = Object.keys(input);
                          for(var idx = 0 ,idx_finish = keys.length; idx < idx_finish; ++idx){
                            var key = keys[idx];
                            var innerData = input[key];
                            try {
                              var value = fn(innerData);
                              newDict[key] = value;
                            }
                            catch (raw_internalError){
                              var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                              if (internalError.RE_EXN_ID === Exception) {
                                throw {
                                      RE_EXN_ID: Exception,
                                      _1: prependLocation(internalError._1, key),
                                      Error: new Error()
                                    };
                              }
                              throw internalError;
                            }
                          }
                          return newDict;
                        }));
                };
                planSyncTransformation(ctx, (function (input) {
                        if ((typeof input === "object" && input !== null && !Array.isArray(input)) === false) {
                          return raiseUnexpectedTypeError(input, struct);
                        } else {
                          return input;
                        }
                      }));
                var fn = innerStruct.p;
                if (typeof fn === "number") {
                  return ;
                }
                if (fn.TAG === /* SyncOperation */0) {
                  return planSyncTransformation$1(fn._0);
                }
                planSyncTransformation$1(fn._0);
                planAsyncTransformation(ctx, (function (input) {
                        var keys = Object.keys(input);
                        return Promise.all(keys.map(function (key) {
                                          var asyncFn = input[key];
                                          try {
                                            return asyncFn().catch(function (exn) {
                                                        throw exn.RE_EXN_ID === Exception ? ({
                                                                  RE_EXN_ID: Exception,
                                                                  _1: prependLocation(exn._1, key)
                                                                }) : exn;
                                                      });
                                          }
                                          catch (raw_internalError){
                                            var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                                            if (internalError.RE_EXN_ID === Exception) {
                                              throw {
                                                    RE_EXN_ID: Exception,
                                                    _1: prependLocation(internalError._1, key),
                                                    Error: new Error()
                                                  };
                                            }
                                            throw internalError;
                                          }
                                        })).then(function (values) {
                                    var tempDict = {};
                                    values.forEach(function (value, idx) {
                                          var key = keys[idx];
                                          tempDict[key] = value;
                                        });
                                    return tempDict;
                                  });
                      }));
              }), (function (ctx, param) {
                var fn = innerStruct.s;
                if (typeof fn === "number") {
                  return ;
                }
                if (fn.TAG !== /* SyncOperation */0) {
                  return panic$1(undefined);
                }
                var fn$1 = fn._0;
                planSyncTransformation(ctx, (function (input) {
                        var newDict = {};
                        var keys = Object.keys(input);
                        for(var idx = 0 ,idx_finish = keys.length; idx < idx_finish; ++idx){
                          var key = keys[idx];
                          var innerData = input[key];
                          try {
                            var value = fn$1(innerData);
                            newDict[key] = value;
                          }
                          catch (raw_internalError){
                            var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                            if (internalError.RE_EXN_ID === Exception) {
                              throw {
                                    RE_EXN_ID: Exception,
                                    _1: prependLocation(internalError._1, key),
                                    Error: new Error()
                                  };
                            }
                            throw internalError;
                          }
                        }
                        return newDict;
                      }));
              }), undefined, undefined, undefined);
}

var metadataId$2 = "rescript-struct:Defaulted";

function factory$17(innerStruct, defaultValue) {
  return set(make(innerStruct.n, innerStruct.t, (function (ctx, param) {
                    var fn = innerStruct.p;
                    if (typeof fn === "number") {
                      return planSyncTransformation(ctx, (function (input) {
                                    if (input !== undefined) {
                                      return Caml_option.valFromOption(input);
                                    } else {
                                      return defaultValue;
                                    }
                                  }));
                    }
                    if (fn.TAG === /* SyncOperation */0) {
                      var fn$1 = fn._0;
                      return planSyncTransformation(ctx, (function (input) {
                                    var option = fn$1(input);
                                    if (option !== undefined) {
                                      return Caml_option.valFromOption(option);
                                    } else {
                                      return defaultValue;
                                    }
                                  }));
                    }
                    planSyncTransformation(ctx, fn._0);
                    planAsyncTransformation(ctx, (function (asyncFn) {
                            return asyncFn().then(function (value) {
                                        if (value !== undefined) {
                                          return Caml_option.valFromOption(value);
                                        } else {
                                          return defaultValue;
                                        }
                                      });
                          }));
                  }), (function (ctx, param) {
                    planSyncTransformation(ctx, (function (input) {
                            var value = Caml_option.some(input);
                            var fn = innerStruct.s;
                            if (typeof fn === "number") {
                              return value;
                            } else if (fn.TAG === /* SyncOperation */0) {
                              return fn._0(value);
                            } else {
                              return panic$1(undefined);
                            }
                          }));
                  }), undefined, undefined, undefined), metadataId$2, /* WithDefaultValue */{
              _0: defaultValue
            });
}

function classify$3(struct) {
  return get(struct, metadataId$2);
}

function factory$18(param) {
  var structs = arguments;
  var numberOfStructs = structs.length;
  return make("Tuple", {
              TAG: /* Tuple */5,
              _0: structs
            }, (function (ctx, struct) {
                var noopOps = [];
                var syncOps = [];
                var asyncOps = [];
                for(var idx = 0 ,idx_finish = structs.length; idx < idx_finish; ++idx){
                  var innerStruct = structs[idx];
                  var fn = innerStruct.p;
                  if (typeof fn === "number") {
                    noopOps.push(idx);
                  } else if (fn.TAG === /* SyncOperation */0) {
                    syncOps.push([
                          idx,
                          fn._0
                        ]);
                  } else {
                    syncOps.push([
                          idx,
                          fn._0
                        ]);
                    asyncOps.push(idx);
                  }
                }
                var withAsyncOps = asyncOps.length > 0;
                planSyncTransformation(ctx, (function (input) {
                        if (Array.isArray(input)) {
                          var numberOfInputItems = input.length;
                          if (numberOfStructs !== numberOfInputItems) {
                            raise({
                                  TAG: /* TupleSize */3,
                                  expected: numberOfStructs,
                                  received: numberOfInputItems
                                });
                          }
                          
                        } else {
                          raiseUnexpectedTypeError(input, struct);
                        }
                        var newArray = [];
                        for(var idx = 0 ,idx_finish = syncOps.length; idx < idx_finish; ++idx){
                          var match = syncOps[idx];
                          var originalIdx = match[0];
                          var innerData = input[originalIdx];
                          try {
                            var value = match[1](innerData);
                            newArray[originalIdx] = value;
                          }
                          catch (raw_internalError){
                            var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                            if (internalError.RE_EXN_ID === Exception) {
                              throw {
                                    RE_EXN_ID: Exception,
                                    _1: prependLocation(internalError._1, idx.toString()),
                                    Error: new Error()
                                  };
                            }
                            throw internalError;
                          }
                        }
                        for(var idx$1 = 0 ,idx_finish$1 = noopOps.length; idx$1 < idx_finish$1; ++idx$1){
                          var originalIdx$1 = noopOps[idx$1];
                          var innerData$1 = input[originalIdx$1];
                          newArray[originalIdx$1] = innerData$1;
                        }
                        if (withAsyncOps) {
                          return newArray;
                        } else if (numberOfStructs !== 0) {
                          if (numberOfStructs !== 1) {
                            return newArray;
                          } else {
                            return newArray[0];
                          }
                        } else {
                          return ;
                        }
                      }));
                if (withAsyncOps) {
                  return planAsyncTransformation(ctx, (function (tempArray) {
                                return Promise.all(asyncOps.map(function (originalIdx) {
                                                  return tempArray[originalIdx]().catch(function (exn) {
                                                              throw exn.RE_EXN_ID === Exception ? ({
                                                                        RE_EXN_ID: Exception,
                                                                        _1: prependLocation(exn._1, originalIdx.toString())
                                                                      }) : exn;
                                                            });
                                                })).then(function (values) {
                                            values.forEach(function (value, idx) {
                                                  var originalIdx = asyncOps[idx];
                                                  tempArray[originalIdx] = value;
                                                });
                                            if (tempArray.length <= 1) {
                                              return tempArray[0];
                                            } else {
                                              return tempArray;
                                            }
                                          });
                              }));
                }
                
              }), (function (ctx, param) {
                planSyncTransformation(ctx, (function (input) {
                        var inputArray = numberOfStructs === 1 ? [input] : input;
                        var newArray = [];
                        for(var idx = 0; idx < numberOfStructs; ++idx){
                          var innerData = inputArray[idx];
                          var innerStruct = structs[idx];
                          var fn = innerStruct.s;
                          if (typeof fn === "number") {
                            newArray.push(innerData);
                          } else if (fn.TAG === /* SyncOperation */0) {
                            try {
                              var value = fn._0(innerData);
                              newArray.push(value);
                            }
                            catch (raw_internalError){
                              var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                              if (internalError.RE_EXN_ID === Exception) {
                                throw {
                                      RE_EXN_ID: Exception,
                                      _1: prependLocation(internalError._1, idx.toString()),
                                      Error: new Error()
                                    };
                              }
                              throw internalError;
                            }
                          } else {
                            panic$1(undefined);
                          }
                        }
                        return newArray;
                      }));
              }), undefined, undefined, undefined);
}

var Tuple = {
  factory: factory$18
};

var HackyValidValue = /* @__PURE__ */Caml_exceptions.create("S.Union.HackyValidValue");

function factory$19(structs) {
  if (structs.length < 2) {
    panic$2(undefined);
  }
  return make("Union", {
              TAG: /* Union */6,
              _0: structs
            }, (function (ctx, compilingStruct) {
                var structs = compilingStruct.t._0;
                var noopOps = [];
                var syncOps = [];
                var asyncOps = [];
                for(var idx = 0 ,idx_finish = structs.length; idx < idx_finish; ++idx){
                  var innerStruct = structs[idx];
                  var fn = innerStruct.p;
                  if (typeof fn === "number") {
                    noopOps.push(undefined);
                  } else if (fn.TAG === /* SyncOperation */0) {
                    syncOps.push([
                          idx,
                          fn._0
                        ]);
                  } else {
                    asyncOps.push([
                          idx,
                          fn._0
                        ]);
                  }
                }
                var withAsyncOps = asyncOps.length > 0;
                if (noopOps.length === 0) {
                  planSyncTransformation(ctx, (function (input) {
                          var idxRef = 0;
                          var errorsRef = [];
                          var maybeNewValueRef;
                          while(idxRef < syncOps.length && maybeNewValueRef === undefined) {
                            var idx = idxRef;
                            var match = syncOps[idx];
                            try {
                              var newValue = match[1](input);
                              maybeNewValueRef = Caml_option.some(newValue);
                            }
                            catch (raw_internalError){
                              var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                              if (internalError.RE_EXN_ID === Exception) {
                                errorsRef[match[0]] = internalError._1;
                                idxRef = idxRef + 1;
                              } else {
                                throw internalError;
                              }
                            }
                          };
                          var match$1 = maybeNewValueRef;
                          if (match$1 !== undefined) {
                            if (withAsyncOps) {
                              return {
                                      maybeSyncValue: match$1,
                                      tempErrors: errorsRef,
                                      originalInput: input
                                    };
                            } else {
                              return Caml_option.valFromOption(match$1);
                            }
                          } else if (withAsyncOps) {
                            return {
                                    maybeSyncValue: match$1,
                                    tempErrors: errorsRef,
                                    originalInput: input
                                  };
                          } else {
                            return raise({
                                        TAG: /* InvalidUnion */5,
                                        _0: errorsRef.map(toParseError)
                                      });
                          }
                        }));
                  if (withAsyncOps) {
                    return planAsyncTransformation(ctx, (function (input) {
                                  var syncValue = input.maybeSyncValue;
                                  if (syncValue !== undefined) {
                                    return Promise.resolve(Caml_option.valFromOption(syncValue));
                                  } else {
                                    return Promise.all(asyncOps.map(function (param) {
                                                      var originalIdx = param[0];
                                                      try {
                                                        return param[1](input.originalInput)().then((function (value) {
                                                                      throw {
                                                                            RE_EXN_ID: HackyValidValue,
                                                                            _1: value,
                                                                            Error: new Error()
                                                                          };
                                                                    }), (function (exn) {
                                                                      if (exn.RE_EXN_ID === Exception) {
                                                                        var array = input.tempErrors;
                                                                        array[originalIdx] = exn._1;
                                                                        return ;
                                                                      }
                                                                      throw exn;
                                                                    }));
                                                      }
                                                      catch (raw_internalError){
                                                        var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                                                        if (internalError.RE_EXN_ID === Exception) {
                                                          var array = input.tempErrors;
                                                          return Promise.resolve((array[originalIdx] = internalError._1, undefined));
                                                        }
                                                        throw internalError;
                                                      }
                                                    })).then((function (param) {
                                                  return raise({
                                                              TAG: /* InvalidUnion */5,
                                                              _0: input.tempErrors.map(toParseError)
                                                            });
                                                }), (function (exn) {
                                                  if (exn.RE_EXN_ID === HackyValidValue) {
                                                    return exn._1;
                                                  }
                                                  throw exn;
                                                }));
                                  }
                                }));
                  } else {
                    return ;
                  }
                }
                
              }), (function (ctx, param) {
                planSyncTransformation(ctx, (function (input) {
                        var idxRef = 0;
                        var maybeLastErrorRef;
                        var maybeNewValueRef;
                        while(idxRef < structs.length && maybeNewValueRef === undefined) {
                          var idx = idxRef;
                          var innerStruct = structs[idx];
                          try {
                            var fn = innerStruct.s;
                            var newValue;
                            newValue = typeof fn === "number" ? input : (
                                fn.TAG === /* SyncOperation */0 ? fn._0(input) : panic$1(undefined)
                              );
                            maybeNewValueRef = Caml_option.some(newValue);
                          }
                          catch (raw_internalError){
                            var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                            if (internalError.RE_EXN_ID === Exception) {
                              maybeLastErrorRef = internalError._1;
                              idxRef = idxRef + 1;
                            } else {
                              throw internalError;
                            }
                          }
                        };
                        var ok = maybeNewValueRef;
                        if (ok !== undefined) {
                          return Caml_option.valFromOption(ok);
                        }
                        var error = maybeLastErrorRef;
                        if (error !== undefined) {
                          throw {
                                RE_EXN_ID: Exception,
                                _1: error,
                                Error: new Error()
                              };
                        }
                        return undefined;
                      }));
              }), undefined, undefined, undefined);
}

function getExn(result) {
  if (result.TAG === /* Ok */0) {
    return result._0;
  }
  var message = toString(result._0);
  throw new Error("[rescript-struct] " + message + "");
}

function mapErrorToString(result) {
  if (result.TAG === /* Ok */0) {
    return result;
  } else {
    return {
            TAG: /* Error */1,
            _0: toString(result._0)
          };
  }
}

var Result = {
  getExn: getExn,
  mapErrorToString: mapErrorToString
};

var $$Error$1 = {
  prependLocation: prependLocation$1,
  raiseCustom: raiseCustom,
  raise: raise$2,
  toString: toString
};

var never = factory$4;

var unknown = factory$5;

var string = factory$6;

var bool = factory$8;

var $$int = factory$9;

var $$float = factory$10;

var date = factory$11;

var literal = factory$1;

var literalVariant = factory;

var array = factory$15;

var dict = factory$16;

var option = factory$13;

var $$null = factory$12;

var json = factory$7;

var union = factory$19;

var deprecated = factory$14;

var defaulted = factory$17;

var Object_UnknownKeys = {
  classify: classify$1
};

var $$Object = {
  UnknownKeys: Object_UnknownKeys,
  factory: factory$2,
  strip: strip,
  strict: strict
};

var Object2 = {};

var object = factory$3;

var object0 = factory$2;

var object1 = factory$2;

var object2 = factory$2;

var object3 = factory$2;

var object4 = factory$2;

var object5 = factory$2;

var object6 = factory$2;

var object7 = factory$2;

var object8 = factory$2;

var object9 = factory$2;

var object10 = factory$2;

var tuple0 = factory$18;

var tuple1 = factory$18;

var tuple2 = factory$18;

var tuple3 = factory$18;

var tuple4 = factory$18;

var tuple5 = factory$18;

var tuple6 = factory$18;

var tuple7 = factory$18;

var tuple8 = factory$18;

var tuple9 = factory$18;

var tuple10 = factory$18;

var $$String = {
  min: min,
  max: max,
  length: length,
  email: email,
  uuid: uuid,
  cuid: cuid,
  url: url,
  pattern: pattern,
  trimmed: trimmed
};

var Int = {
  min: min$1,
  max: max$1,
  port: port
};

var Float = {
  min: min$1,
  max: max$1
};

var $$Array = {
  min: min$2,
  max: max$2,
  length: length$1
};

var Defaulted = {
  classify: classify$3
};

var Deprecated = {
  classify: classify$2
};

var Metadata = {
  Id: Id,
  get: get,
  set: set
};

exports.$$Error = $$Error$1;
exports.Raised = Raised;
exports.never = never;
exports.unknown = unknown;
exports.string = string;
exports.bool = bool;
exports.$$int = $$int;
exports.$$float = $$float;
exports.date = date;
exports.literal = literal;
exports.literalVariant = literalVariant;
exports.array = array;
exports.dict = dict;
exports.option = option;
exports.$$null = $$null;
exports.json = json;
exports.union = union;
exports.deprecated = deprecated;
exports.defaulted = defaulted;
exports.transform = transform;
exports.advancedTransform = advancedTransform;
exports.advancedPreprocess = advancedPreprocess;
exports.custom = custom;
exports.refine = refine;
exports.asyncRefine = asyncRefine;
exports.parseWith = parseWith;
exports.parseOrRaiseWith = parseOrRaiseWith;
exports.parseAsyncWith = parseAsyncWith;
exports.parseAsyncInStepsWith = parseAsyncInStepsWith;
exports.serializeWith = serializeWith;
exports.serializeOrRaiseWith = serializeOrRaiseWith;
exports.isAsyncParse = isAsyncParse;
exports.$$Object = $$Object;
exports.Object2 = Object2;
exports.object = object;
exports.field = field;
exports.discriminant = discriminant;
exports.object0 = object0;
exports.object1 = object1;
exports.object2 = object2;
exports.object3 = object3;
exports.object4 = object4;
exports.object5 = object5;
exports.object6 = object6;
exports.object7 = object7;
exports.object8 = object8;
exports.object9 = object9;
exports.object10 = object10;
exports.Tuple = Tuple;
exports.tuple0 = tuple0;
exports.tuple1 = tuple1;
exports.tuple2 = tuple2;
exports.tuple3 = tuple3;
exports.tuple4 = tuple4;
exports.tuple5 = tuple5;
exports.tuple6 = tuple6;
exports.tuple7 = tuple7;
exports.tuple8 = tuple8;
exports.tuple9 = tuple9;
exports.tuple10 = tuple10;
exports.classify = classify;
exports.name = name;
exports.$$String = $$String;
exports.Int = Int;
exports.Float = Float;
exports.$$Array = $$Array;
exports.Defaulted = Defaulted;
exports.Deprecated = Deprecated;
exports.Result = Result;
exports.Metadata = Metadata;
/* value Not a pure module */
