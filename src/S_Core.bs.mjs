// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";

var immutableEmpty = {};

function fromString(string) {
  return JSON.stringify(string);
}

function toArray(path) {
  if (path === "") {
    return [];
  } else {
    return JSON.parse(path.split("\"][\"").join("\",\""));
  }
}

function fromLocation($$location) {
  return "[" + JSON.stringify($$location) + "]";
}

function fromArray(array) {
  var len = array.length;
  if (len !== 1) {
    if (len !== 0) {
      return "[" + array.map(fromString).join("][") + "]";
    } else {
      return "";
    }
  }
  var $$location = array[0];
  return "[" + JSON.stringify($$location) + "]";
}

function concat(path, concatedPath) {
  return path + concatedPath;
}

var symbol = Symbol("rescript-schema");

var itemSymbol = Symbol("item");

var Raised = /* @__PURE__ */Caml_exceptions.create("S_Core-RescriptSchema.Raised");

var globalConfig = {
  r: 0,
  u: "Strip",
  n: false
};

class RescriptSchemaError extends Error {
      constructor(code, flag, path) {
        super();
        this.flag = flag;
        this.code = code;
        this.path = path;
        this.s = symbol;
        this.RE_EXN_ID = Raised;
        this._1 = this;
        this.Error = this;
        this.name = "RescriptSchemaError";
      }
      get message() {
        return message(this);
      }
      get reason() {
        return reason(this);
      }
    }
;

function getOrRethrow(exn) {
  if ((exn&&exn.s===symbol)) {
    return exn;
  }
  throw exn;
}

function has(acc, flag) {
  return (acc & flag) !== 0;
}

function embed(b, value) {
  var e = b.g.e;
  var l = e.length;
  e[l] = value;
  return "e[" + l + "]";
}

function allocateScope(b) {
  var varsAllocation = b.l;
  if (varsAllocation === "") {
    return b.c;
  } else {
    return "let " + varsAllocation + ";" + b.c;
  }
}

function varWithoutAllocation(b) {
  var newCounter = b.g.v + 1;
  b.g.v = newCounter;
  return "v" + newCounter;
}

function allocateVal(b) {
  var $$var = varWithoutAllocation(b);
  var varsAllocation = b.l;
  b.l = varsAllocation === "" ? $$var : varsAllocation + "," + $$var;
  return {
          v: true,
          i: $$var,
          a: false
        };
}

function objectJoin(inlinedLocation, value) {
  return inlinedLocation + ":" + value + ",";
}

function arrayJoin(_inlinedLocation, value) {
  return value + ",";
}

function make(_b, isArray) {
  return {
          v: false,
          i: "",
          a: false,
          j: isArray ? arrayJoin : objectJoin,
          c: 0,
          p: ""
        };
}

function add(objectVal, inlinedLocation, val) {
  objectVal[inlinedLocation] = val;
  if (val.a) {
    objectVal.p = objectVal.p + val.i + ",";
    objectVal.i = objectVal.i + objectVal.j(inlinedLocation, "a[" + (objectVal.c++) + "]");
  } else {
    objectVal.i = objectVal.i + objectVal.j(inlinedLocation, val.i);
  }
}

function merge(target, subObjectVal) {
  var inlinedLocations = Object.keys(subObjectVal);
  for(var idx = 6 ,idx_finish = inlinedLocations.length; idx < idx_finish; ++idx){
    var inlinedLocation = inlinedLocations[idx];
    add(target, inlinedLocation, subObjectVal[inlinedLocation]);
  }
}

function complete(objectVal, isArray) {
  objectVal.i = isArray ? "[" + objectVal.i + "]" : "{" + objectVal.i + "}";
  if (objectVal.c) {
    objectVal.a = true;
    objectVal.i = "Promise.all([" + objectVal.p + "]).then(a=>(" + objectVal.i + "))";
  }
  return objectVal;
}

function $$var(b, val) {
  if (val.v) {
    return val.i;
  }
  var $$var$1 = varWithoutAllocation(b);
  var i = val.i;
  var allocation = i === "" ? $$var$1 : $$var$1 + "=" + i;
  b.l = b.l === "" ? allocation : b.l + "," + allocation;
  val.v = true;
  val.i = $$var$1;
  return $$var$1;
}

function push(b, input, val) {
  return $$var(b, input) + ".push(" + val.i + ")";
}

function addKey(b, input, key, val) {
  return $$var(b, input) + "[" + key + "]=" + val.i;
}

function set(b, input, val) {
  if (input === val) {
    return "";
  }
  var inputVar = $$var(b, input);
  var match = input.a;
  if (match) {
    var match$1 = val.a;
    if (!match$1) {
      return inputVar + "=Promise.resolve(" + val.i + ")";
    }
    
  } else {
    var match$2 = val.a;
    if (match$2) {
      input.a = true;
      return inputVar + "=" + val.i;
    }
    
  }
  return inputVar + "=" + val.i;
}

function get(b, targetVal, inlinedLocation) {
  var val = targetVal[inlinedLocation];
  if (val !== undefined) {
    return val;
  } else {
    return {
            v: false,
            i: $$var(b, targetVal) + ("[" + inlinedLocation + "]"),
            a: false
          };
  }
}

function setInlined(b, input, inlined) {
  return $$var(b, input) + "=" + inlined;
}

function map(b, inlinedFn, input) {
  return {
          v: false,
          i: inlinedFn + "(" + input.i + ")",
          a: false
        };
}

function transform(b, input, operation) {
  if (!input.a) {
    return operation(b, input);
  }
  var bb = {
    c: "",
    l: "",
    g: b.g
  };
  var operationInput = {
    v: true,
    i: varWithoutAllocation(bb),
    a: false
  };
  var operationOutputVal = operation(bb, operationInput);
  var operationCode = allocateScope(bb);
  return {
          v: false,
          i: input.i + ".then(" + $$var(b, operationInput) + "=>{" + operationCode + "return " + operationOutputVal.i + "})",
          a: true
        };
}

function raise(b, code, path) {
  throw new RescriptSchemaError(code, b.g.o, path);
}

function embedSyncOperation(b, input, fn) {
  if (input.a) {
    return {
            v: false,
            i: input.i + ".then(" + embed(b, fn) + ")",
            a: true
          };
  } else {
    return map(b, embed(b, fn), input);
  }
}

function embedAsyncOperation(b, input, fn) {
  if (!(b.g.o & 2)) {
    raise(b, "UnexpectedAsync", "");
  }
  var val = embedSyncOperation(b, input, fn);
  val.a = true;
  return val;
}

function failWithArg(b, path, fn, arg) {
  return embed(b, (function (arg) {
                return raise(b, fn(arg), path);
              })) + "(" + arg + ")";
}

function fail(b, message, path) {
  return embed(b, (function () {
                return raise(b, {
                            TAG: "OperationFailed",
                            _0: message
                          }, path);
              })) + "()";
}

function effectCtx(b, selfSchema, path) {
  return {
          schema: selfSchema,
          fail: (function (message, customPathOpt) {
              var customPath = customPathOpt !== undefined ? customPathOpt : "";
              return raise(b, {
                          TAG: "OperationFailed",
                          _0: message
                        }, path + customPath);
            })
        };
}

function registerInvalidJson(b, selfSchema, path) {
  if (b.g.o & 8) {
    return raise(b, {
                TAG: "InvalidJsonSchema",
                _0: selfSchema
              }, path);
  }
  
}

function invalidOperation(b, path, description) {
  return raise(b, {
              TAG: "InvalidOperation",
              description: description
            }, path);
}

function withCatch(b, input, $$catch, fn) {
  var prevCode = b.c;
  b.c = "";
  var errorVar = varWithoutAllocation(b);
  var maybeResolveVal = $$catch(b, errorVar);
  var catchCode = "if(" + (errorVar + "&&" + errorVar + ".s===s") + "){" + b.c;
  b.c = "";
  var bb = {
    c: "",
    l: "",
    g: b.g
  };
  var fnOutput = fn(bb);
  b.c = b.c + allocateScope(bb);
  if (fnOutput === input && b.c === "") {
    return fnOutput;
  }
  var isAsync = fnOutput.a;
  var output = input === fnOutput ? input : ({
        v: false,
        i: "",
        a: isAsync
      });
  var catchCode$1 = maybeResolveVal !== undefined ? (function (catchLocation) {
        return catchCode + (
                catchLocation === 1 ? "return " + maybeResolveVal.i : set(b, output, maybeResolveVal)
              ) + ("}else{throw " + errorVar + "}");
      }) : (function (param) {
        return catchCode + "}throw " + errorVar;
      });
  b.c = prevCode + ("try{" + b.c + (
      isAsync ? setInlined(b, output, fnOutput.i + ".catch(" + errorVar + "=>{" + catchCode$1(1) + "})") : set(b, output, fnOutput)
    ) + "}catch(" + errorVar + "){" + catchCode$1(0) + "}");
  return output;
}

function withPathPrepend(b, input, path, maybeDynamicLocationVar, fn) {
  if (path === "" && maybeDynamicLocationVar === undefined) {
    return fn(b, input, path);
  }
  try {
    return withCatch(b, input, (function (b, errorVar) {
                  b.c = errorVar + ".path=" + JSON.stringify(path) + "+" + (
                    maybeDynamicLocationVar !== undefined ? "'[\"'+" + maybeDynamicLocationVar + "+'\"]'+" : ""
                  ) + errorVar + ".path";
                }), (function (b) {
                  return fn(b, input, "");
                }));
  }
  catch (exn){
    var error = getOrRethrow(exn);
    throw new RescriptSchemaError(error.code, error.flag, path + "[]" + error.path);
  }
}

function typeFilterCode(b, schema, input, path) {
  var inputVar = $$var(b, input);
  return "if(" + schema.f(b, inputVar) + "){" + failWithArg(b, path, (function (input) {
                return {
                        TAG: "InvalidType",
                        expected: schema,
                        received: input
                      };
              }), inputVar) + "}";
}

function parseWithTypeValidation(b, schema, input, path) {
  if (!(schema.f !== undefined && (schema.t.TAG === "literal" || b.g.o & 1))) {
    return schema.b(b, input, schema, path);
  }
  b.c = b.c + typeFilterCode(b, schema, input, path);
  var bb = {
    c: "",
    l: "",
    g: b.g
  };
  var val = schema.b(bb, input, schema, path);
  b.c = b.c + allocateScope(bb);
  return val;
}

function noop(_b, input, param, param$1) {
  return input;
}

function invalidJson(b, input, selfSchema, path) {
  registerInvalidJson(b, selfSchema, path);
  return input;
}

function noopOperation(i) {
  return i;
}

function compile(builder, schema, flag) {
  if (flag & 8 && schema["~r"]().t.TAG === "option") {
    throw new RescriptSchemaError({
              TAG: "InvalidJsonSchema",
              _0: schema
            }, flag, "");
  }
  var embeded = [];
  var b = {
    c: "",
    l: "",
    g: {
      v: -1,
      o: flag,
      e: embeded
    }
  };
  var input = {
    v: true,
    i: "i",
    a: false
  };
  var output = builder(b, input, schema, "");
  schema.i = output.a;
  if (b.l !== "") {
    b.c = "let " + b.l + ";" + b.c;
  }
  if ((flag & 1 || schema.t.TAG === "literal") && schema.f !== undefined) {
    b.c = typeFilterCode(b, schema, input, "") + b.c;
  }
  if (b.c === "" && output === input && !(flag & 22)) {
    return noopOperation;
  }
  var inlinedOutput = flag & 4 ? "void 0" : output.i;
  if (flag & 16) {
    inlinedOutput = "JSON.stringify(" + inlinedOutput + ")";
  }
  if (flag & 2 && !output.a) {
    inlinedOutput = "Promise.resolve(" + inlinedOutput + ")";
  }
  var inlinedFunction = "i=>{" + b.c + "return " + inlinedOutput + "}";
  return new Function("e", "s", "return " + inlinedFunction)(embeded, symbol);
}

function operationFn(s, o) {
  if ((o in s)) {
    return (s[o]);
  }
  var ss = o & 32 ? s["~r"]() : s;
  var f = compile(ss.b, ss, o);
  ((s[o] = f));
  return f;
}

function compile$1(schema, input, output, mode, typeValidationOpt) {
  var typeValidation = typeValidationOpt !== undefined ? typeValidationOpt : true;
  var flag = 0;
  var exit = 0;
  switch (output) {
    case "Output" :
    case "Input" :
        exit = 1;
        break;
    case "Assert" :
        flag = flag | 4;
        break;
    case "Json" :
        flag = flag | 8;
        break;
    case "JsonString" :
        flag = flag | 24;
        break;
    
  }
  if (exit === 1 && output === input) {
    throw new Error("[rescript-schema] Can't compile operation to converting value to self");
  }
  if (mode !== "Sync") {
    flag = flag | 2;
  }
  if (typeValidation) {
    flag = flag | 1;
  }
  if (input === "Output") {
    flag = flag | 32;
  }
  var fn = operationFn(schema, flag);
  if (input !== "JsonString") {
    return fn;
  }
  var flag$1 = flag;
  return function (jsonString) {
    try {
      return fn(JSON.parse(jsonString));
    }
    catch (exn){
      throw new RescriptSchemaError({
                TAG: "OperationFailed",
                _0: exn.message
              }, flag$1, "");
    }
  };
}

function toSelf() {
  return this;
}

function onlyChild(factory, schema) {
  return function () {
    var reversed = schema["~r"]();
    if (reversed === schema) {
      return this;
    } else {
      return factory(reversed);
    }
  };
}

function value(literal) {
  return literal.value;
}

function isJsonable(literal) {
  return literal.j;
}

function toString(literal) {
  return literal.s;
}

function arrayFilterBuilder(b, inputVar, literal) {
  var items = literal.i;
  return inputVar + "!==" + embed(b, literal.value) + "&&(!Array.isArray(" + inputVar + ")||" + inputVar + ".length!==" + items.length + (
          items.length > 0 ? "||" + items.map(function (literal, idx) {
                    return literal.f(b, inputVar + "[" + idx + "]", literal);
                  }).join("||") : ""
        ) + ")";
}

function dictFilterBuilder(b, inputVar, literal) {
  var items = literal.i;
  var fields = Object.keys(items);
  var numberOfFields = fields.length;
  return inputVar + "!==" + embed(b, value) + "&&(!" + inputVar + "||" + inputVar + ".constructor!==Object||Object.keys(" + inputVar + ").length!==" + numberOfFields + (
          numberOfFields > 0 ? "||" + fields.map(function (field) {
                    var literal = items[field];
                    return literal.f(b, inputVar + "[" + JSON.stringify(field) + "]", literal);
                  }).join("||") : ""
        ) + ")";
}

function inlinedStrictEqualFilterBuilder(param, inputVar, literal) {
  return inputVar + "!==" + literal.s;
}

function strictEqualFilterBuilder(b, inputVar, literal) {
  return inputVar + "!==" + embed(b, literal.value);
}

var undefined_value = undefined;

var $$undefined = {
  kind: "Undefined",
  value: undefined_value,
  s: "undefined",
  f: inlinedStrictEqualFilterBuilder,
  j: false
};

var null_value = null;

var $$null = {
  kind: "Null",
  value: null_value,
  s: "null",
  f: inlinedStrictEqualFilterBuilder,
  j: true
};

var nan_value = NaN;

function nan_f(param, inputVar, param$1) {
  return "!Number.isNaN(" + inputVar + ")";
}

var nan = {
  kind: "NaN",
  value: nan_value,
  s: "NaN",
  f: nan_f,
  j: false
};

function parseInternal(value) {
  var typeOfValue = typeof value;
  if (typeOfValue === "symbol") {
    return {
            kind: "Symbol",
            value: value,
            s: value.toString(),
            f: strictEqualFilterBuilder,
            j: false
          };
  } else if (typeOfValue === "boolean") {
    return {
            kind: "Boolean",
            value: value,
            s: value ? "true" : "false",
            f: inlinedStrictEqualFilterBuilder,
            j: true
          };
  } else if (typeOfValue === "string") {
    return {
            kind: "String",
            value: value,
            s: JSON.stringify(value),
            f: inlinedStrictEqualFilterBuilder,
            j: true
          };
  } else if (typeOfValue === "function") {
    return {
            kind: "Function",
            value: value,
            s: value.toString(),
            f: strictEqualFilterBuilder,
            j: false
          };
  } else if (typeOfValue === "object") {
    if (value === null) {
      return $$null;
    } else if (Array.isArray(value)) {
      var items = [];
      var isJsonable = true;
      var string = "[";
      for(var idx = 0 ,idx_finish = value.length; idx < idx_finish; ++idx){
        var itemValue = value[idx];
        var itemLiteral = parseInternal(itemValue);
        if (isJsonable && !itemLiteral.j) {
          isJsonable = false;
        }
        if (idx !== 0) {
          string = string + ", ";
        }
        string = string + itemLiteral.s;
        items.push(itemLiteral);
      }
      return {
              kind: "Array",
              value: value,
              s: string + "]",
              f: arrayFilterBuilder,
              j: isJsonable,
              i: Caml_option.some(items)
            };
    } else if (value.constructor === Object) {
      var items$1 = {};
      var string$1 = "{";
      var isJsonable$1 = true;
      var fields = Object.keys(value);
      var numberOfFields = fields.length;
      for(var idx$1 = 0; idx$1 < numberOfFields; ++idx$1){
        var field = fields[idx$1];
        var itemValue$1 = value[field];
        var itemLiteral$1 = parseInternal(itemValue$1);
        if (isJsonable$1 && !itemLiteral$1.j) {
          isJsonable$1 = false;
        }
        if (idx$1 !== 0) {
          string$1 = string$1 + ",";
        }
        string$1 = string$1 + (JSON.stringify(field) + ":" + itemLiteral$1.s);
        items$1[field] = itemLiteral$1;
      }
      return {
              kind: "Dict",
              value: value,
              s: string$1 + "}",
              f: dictFilterBuilder,
              j: isJsonable$1,
              i: Caml_option.some(items$1)
            };
    } else {
      return {
              kind: "Object",
              value: value,
              s: Object.prototype.toString.call(value),
              f: strictEqualFilterBuilder,
              j: false
            };
    }
  } else if (typeOfValue === "undefined") {
    return $$undefined;
  } else if (typeOfValue === "number") {
    if (Number.isNaN(value)) {
      return nan;
    } else {
      return {
              kind: "Number",
              value: value,
              s: value.toString(),
              f: inlinedStrictEqualFilterBuilder,
              j: true
            };
    }
  } else {
    return {
            kind: "BigInt",
            value: value,
            s: value.toString() + "n",
            f: inlinedStrictEqualFilterBuilder,
            j: false
          };
  }
}

function parse(any) {
  return parseInternal(any);
}

function isAsync(schema) {
  var v = schema.i;
  if (typeof v === "boolean") {
    return v;
  }
  try {
    var b = {
      c: "",
      l: "",
      g: {
        v: -1,
        o: 2,
        e: []
      }
    };
    var input = {
      v: true,
      i: "i",
      a: false
    };
    var output = schema.b(b, input, schema, "");
    schema.i = output.a;
    return schema.i;
  }
  catch (exn){
    getOrRethrow(exn);
    return false;
  }
}

function reverse(schema) {
  return schema["~r"]();
}

function parseOrThrow(any, schema) {
  return operationFn(schema, 1)(any);
}

function parseJsonStringOrThrow(jsonString, schema) {
  var tmp;
  try {
    tmp = JSON.parse(jsonString);
  }
  catch (exn){
    throw new RescriptSchemaError({
              TAG: "OperationFailed",
              _0: exn.message
            }, 1, "");
  }
  return parseOrThrow(tmp, schema);
}

function parseAsyncOrThrow(any, schema) {
  return operationFn(schema, 3)(any);
}

function convertOrThrow(input, schema) {
  return operationFn(schema, 0)(input);
}

function convertToJsonOrThrow(any, schema) {
  return operationFn(schema, 8)(any);
}

function convertToJsonStringOrThrow(input, schema) {
  return operationFn(schema, 24)(input);
}

function convertAsyncOrThrow(any, schema) {
  return operationFn(schema, 2)(any);
}

function reverseConvertOrThrow(value, schema) {
  return operationFn(schema, 32)(value);
}

function reverseConvertToJsonOrThrow(value, schema) {
  return operationFn(schema, 40)(value);
}

function reverseConvertToJsonStringOrThrow(value, schema, spaceOpt) {
  var space = spaceOpt !== undefined ? spaceOpt : 0;
  return JSON.stringify(reverseConvertToJsonOrThrow(value, schema), null, space);
}

function assertOrThrow(any, schema) {
  return operationFn(schema, 5)(any);
}

function wrapExnToFailure(exn) {
  if ((exn&&exn.s===symbol)) {
    return {
            success: false,
            error: exn
          };
  }
  throw exn;
}

function js_safe(fn) {
  try {
    return {
            success: true,
            value: fn()
          };
  }
  catch (exn){
    return wrapExnToFailure(exn);
  }
}

function js_safeAsync(fn) {
  try {
    return fn().then((function (value) {
                  return {
                          success: true,
                          value: value
                        };
                }), wrapExnToFailure);
  }
  catch (exn){
    return Promise.resolve(wrapExnToFailure(exn));
  }
}

function makeReverseSchema(name, tagged, metadataMap, builder, maybeTypeFilter) {
  return {
          t: tagged,
          n: name,
          "~r": toSelf,
          b: builder,
          f: maybeTypeFilter,
          i: 0,
          m: metadataMap
        };
}

function makeSchema(name, tagged, metadataMap, builder, maybeTypeFilter, reverse) {
  return {
          t: tagged,
          n: name,
          "~r": (function () {
              var original = this;
              var reversed = reverse.call(original);
              var reversed$1 = original !== reversed && typeof reversed.t === "string" ? makeReverseSchema(reversed.n, reversed.t, reversed.m, reversed.b, reversed.f) : reversed;
              original["~r"] = (function () {
                  return reversed$1;
                });
              reversed$1["~r"] = (function () {
                  return original;
                });
              return reversed$1;
            }),
          b: builder,
          f: maybeTypeFilter,
          i: 0,
          m: metadataMap
        };
}

function make$1(namespace, name) {
  return namespace + ":" + name;
}

var Id = {
  make: make$1
};

var empty = {};

function set$1(map, id, metadata) {
  if (map === empty) {
    return ({[id]:metadata});
  }
  var copy = Object.assign({}, map);
  copy[id] = metadata;
  return copy;
}

function get$1(schema, id) {
  return schema.m[id];
}

function set$2(schema, id, metadata) {
  var metadataMap = set$1(schema.m, id, metadata);
  return makeSchema(schema.n, schema.t, metadataMap, schema.b, schema.f, (function () {
                var schema$1 = schema["~r"]();
                return makeReverseSchema(schema$1.n, schema$1.t, metadataMap, schema$1.b, schema$1.f);
              }));
}

function primitiveName() {
  return this.t;
}

function makePrimitiveSchema(tagged, builder, maybeTypeFilter) {
  return makeSchema(primitiveName, tagged, empty, builder, maybeTypeFilter, toSelf);
}

function recursive(fn) {
  var r = "r" + globalConfig.r;
  globalConfig.r = globalConfig.r + 1 | 0;
  var placeholder = {
    m: empty,
    t: "Input",
    n: (function () {
        return "<recursive>";
      }),
    b: (function (b, input, param, param$1) {
        return transform(b, input, (function (b, input) {
                      return map(b, r, input);
                    }));
      }),
    "~r": (function () {
        return makeReverseSchema(primitiveName, "unknown", empty, (function (b, input, param, param$1) {
                      return map(b, r, input);
                    }), undefined);
      })
  };
  var schema = fn(placeholder);
  placeholder.f = schema.f;
  var initialParseOperationBuilder = schema.b;
  schema.b = (function (b, input, selfSchema, path) {
      var inputVar = $$var(b, input);
      var bb = {
        c: "",
        l: "",
        g: b.g
      };
      var opOutput = initialParseOperationBuilder(bb, input, selfSchema, "");
      var opBodyCode = allocateScope(bb) + ("return " + opOutput.i);
      b.c = b.c + ("let " + r + "=" + inputVar + "=>{" + opBodyCode + "};");
      return withPathPrepend(b, input, path, undefined, (function (b, input, param) {
                    return transform(b, input, (function (b, input) {
                                  var output = map(b, r, input);
                                  if (opOutput.a) {
                                    output.a = true;
                                    placeholder.b = (function (b, input, param, param$1) {
                                        return transform(b, input, (function (b, input) {
                                                      var output = map(b, r, input);
                                                      output.a = true;
                                                      return output;
                                                    }));
                                      });
                                  }
                                  return output;
                                }));
                  }));
    });
  var initialReverse = schema["~r"].bind(schema);
  schema["~r"] = (function () {
      var initialReversed = initialReverse();
      var reversed = makeReverseSchema(initialReversed.n, initialReversed.t, initialReversed.m, (function (b, input, selfSchema, path) {
              var inputVar = $$var(b, input);
              var bb = {
                c: "",
                l: "",
                g: b.g
              };
              var opOutput = initialReversed.b(bb, input, selfSchema, "");
              var opBodyCode = allocateScope(bb) + ("return " + opOutput.i);
              b.c = b.c + ("let " + r + "=" + inputVar + "=>{" + opBodyCode + "};");
              return withPathPrepend(b, input, path, undefined, (function (b, input, param) {
                            return map(b, r, input);
                          }));
            }), initialReversed.f);
      reversed["~r"] = (function () {
          return schema;
        });
      schema["~r"] = (function () {
          return reversed;
        });
      return reversed;
    });
  return schema;
}

function setName(schema, name) {
  return makeSchema((function () {
                return name;
              }), schema.t, schema.m, schema.b, schema.f, (function () {
                return schema["~r"]();
              }));
}

function removeTypeValidation(schema) {
  return makeSchema(schema.n, schema.t, schema.m, schema.b, undefined, (function () {
                return schema["~r"]();
              }));
}

function internalRefine(schema, refiner) {
  return makeSchema(schema.n, schema.t, schema.m, (function (b, input, selfSchema, path) {
                return transform(b, schema.b(b, input, schema, path), (function (b, input) {
                              var bb = {
                                c: "",
                                l: "",
                                g: b.g
                              };
                              var rCode = refiner(bb, $$var(bb, input), selfSchema, path);
                              b.c = b.c + allocateScope(bb) + rCode;
                              return input;
                            }));
              }), schema.f, (function () {
                var schema$1 = schema["~r"]();
                return makeReverseSchema(schema$1.n, schema$1.t, schema$1.m, (function (b, input, selfSchema, path) {
                              var input$1 = transform(b, input, (function (b, input) {
                                      b.c = b.c + refiner(b, $$var(b, input), selfSchema, path);
                                      return input;
                                    }));
                              return schema$1.b(b, input$1, schema$1, path);
                            }), schema$1.f);
              }));
}

function refine(schema, refiner) {
  return internalRefine(schema, (function (b, inputVar, selfSchema, path) {
                return embed(b, refiner(effectCtx(b, selfSchema, path))) + "(" + inputVar + ");";
              }));
}

function addRefinement(schema, metadataId, refinement, refiner) {
  var refinements = schema.m[metadataId];
  return internalRefine(set$2(schema, metadataId, refinements !== undefined ? refinements.concat(refinement) : [refinement]), refiner);
}

function transform$1(schema, transformer) {
  return makeSchema(schema.n, schema.t, schema.m, (function (b, input, selfSchema, path) {
                var input$1 = schema.b(b, input, schema, path);
                var match = transformer(effectCtx(b, selfSchema, path));
                var parser = match.p;
                if (parser !== undefined) {
                  if (match.a !== undefined) {
                    return invalidOperation(b, path, "The S.transform doesn't allow parser and asyncParser at the same time. Remove parser in favor of asyncParser");
                  } else {
                    return embedSyncOperation(b, input$1, parser);
                  }
                }
                var asyncParser = match.a;
                if (asyncParser !== undefined) {
                  return embedAsyncOperation(b, input$1, asyncParser);
                } else if (match.s !== undefined) {
                  return invalidOperation(b, path, "The S.transform parser is missing");
                } else {
                  return input$1;
                }
              }), schema.f, (function () {
                var schema$1 = schema["~r"]();
                return makeReverseSchema(primitiveName, "unknown", empty, (function (b, input, selfSchema, path) {
                              var match = transformer(effectCtx(b, selfSchema, path));
                              var serializer = match.s;
                              if (serializer === undefined) {
                                if (match.a !== undefined || match.p !== undefined) {
                                  return invalidOperation(b, path, "The S.transform serializer is missing");
                                } else {
                                  return schema$1.b(b, input, schema$1, path);
                                }
                              }
                              var input$1 = embedSyncOperation(b, input, serializer);
                              return schema$1.b(b, input$1, schema$1, path);
                            }), undefined);
              }));
}

function custom(name, definer) {
  return makeSchema((function () {
                return name;
              }), "unknown", empty, (function (b, input, selfSchema, path) {
                registerInvalidJson(b, selfSchema, path);
                var match = definer(effectCtx(b, selfSchema, path));
                var parser = match.p;
                if (parser !== undefined) {
                  if (match.a !== undefined) {
                    return invalidOperation(b, path, "The S.custom doesn't allow parser and asyncParser at the same time. Remove parser in favor of asyncParser");
                  } else {
                    return embedSyncOperation(b, input, parser);
                  }
                }
                var asyncParser = match.a;
                if (asyncParser !== undefined) {
                  return embedAsyncOperation(b, input, asyncParser);
                } else if (match.s !== undefined) {
                  return invalidOperation(b, path, "The S.custom parser is missing");
                } else {
                  return input;
                }
              }), undefined, (function () {
                return makeReverseSchema((function () {
                              return name;
                            }), "unknown", empty, (function (b, input, selfSchema, path) {
                              registerInvalidJson(b, selfSchema, path);
                              var match = definer(effectCtx(b, selfSchema, path));
                              var serializer = match.s;
                              if (serializer !== undefined) {
                                return embedSyncOperation(b, input, serializer);
                              } else if (match.a !== undefined || match.p !== undefined) {
                                return invalidOperation(b, path, "The S.custom serializer is missing");
                              } else {
                                return input;
                              }
                            }), undefined);
              }));
}

function literal(value) {
  var literal$1 = parseInternal(value);
  return makeSchema((function () {
                return literal$1.s;
              }), {
              TAG: "literal",
              _0: literal$1
            }, empty, literal$1.j ? noop : invalidJson, (function (b, inputVar) {
                return literal$1.f(b, inputVar, literal$1);
              }), toSelf);
}

var unit = literal((void 0));

var defaultMetadataId = "rescript-schema:Option.default";

function name() {
  return this.t._0.n() + " | undefined";
}

function $$default(schema) {
  return schema.m[defaultMetadataId];
}

function makeBuilder(isNullInput, isNullOutput) {
  return function (b, input, selfSchema, path) {
    var childSchema = selfSchema.t._0;
    var childSchemaTag = childSchema.t.TAG;
    var bb = {
      c: "",
      l: "",
      g: b.g
    };
    var itemInput = !(b.g.o & 1) && (childSchema.t === "unknown" || childSchemaTag === "option" || childSchemaTag === "literal" && childSchema.t._0.value === (void 0)) ? ({
          v: false,
          i: embed(bb, Caml_option.valFromOption) + "(" + $$var(b, input) + ")",
          a: false
        }) : input;
    var itemOutput = childSchema.b(bb, itemInput, childSchema, path);
    var itemCode = allocateScope(bb);
    var inputLiteral = isNullInput ? "null" : "void 0";
    var ouputLiteral = isNullOutput ? "null" : "void 0";
    var isTransformed = inputLiteral !== ouputLiteral || itemOutput !== input;
    var output = isTransformed ? ({
          v: false,
          i: "",
          a: itemOutput.a
        }) : input;
    if (itemCode !== "" || isTransformed) {
      b.c = b.c + ("if(" + $$var(b, input) + "!==" + inputLiteral + "){" + itemCode + set(b, output, itemOutput) + "}" + (
          inputLiteral !== ouputLiteral || output.a ? "else{" + set(b, output, {
                  v: false,
                  i: ouputLiteral,
                  a: false
                }) + "}" : ""
        ));
    }
    return output;
  };
}

function maybeTypeFilter(schema, inlinedNoneValue) {
  if (schema.f !== undefined) {
    return (function (b, inputVar) {
              return inputVar + "!==" + inlinedNoneValue + "&&(" + schema.f(b, inputVar) + ")";
            });
  }
  
}

function factory(schema) {
  return makeSchema(name, {
              TAG: "option",
              _0: schema
            }, empty, makeBuilder(false, false), maybeTypeFilter(schema, "void 0"), onlyChild(factory, schema));
}

function getWithDefault(schema, $$default) {
  return makeSchema(schema.n, schema.t, set$1(schema.m, defaultMetadataId, $$default), (function (b, input, param, path) {
                return transform(b, schema.b(b, input, schema, path), (function (b, input) {
                              var inputVar = $$var(b, input);
                              var tmp;
                              tmp = $$default.TAG === "Value" ? embed(b, $$default._0) : embed(b, $$default._0) + "()";
                              return {
                                      v: false,
                                      i: inputVar + "===void 0?" + tmp + ":" + inputVar,
                                      a: false
                                    };
                            }));
              }), schema.f, (function () {
                var reversed = schema["~r"]();
                if (reversed.t.TAG === "option") {
                  return reversed.t._0;
                } else {
                  return reversed;
                }
              }));
}

function getOr(schema, defalutValue) {
  return getWithDefault(schema, {
              TAG: "Value",
              _0: defalutValue
            });
}

function getOrWith(schema, defalutCb) {
  return getWithDefault(schema, {
              TAG: "Callback",
              _0: defalutCb
            });
}

function factory$1(schema) {
  return makeSchema((function () {
                return schema.n() + " | null";
              }), {
              TAG: "null",
              _0: schema
            }, empty, makeBuilder(true, false), maybeTypeFilter(schema, "null"), (function () {
                var child = schema["~r"]();
                return makeReverseSchema(name, {
                            TAG: "option",
                            _0: child
                          }, empty, makeBuilder(false, true), maybeTypeFilter(schema, "void 0"));
              }));
}

function nullable(schema) {
  return factory(factory$1(schema));
}

function builder(b, input, selfSchema, path) {
  b.c = b.c + failWithArg(b, path, (function (input) {
          return {
                  TAG: "InvalidType",
                  expected: selfSchema,
                  received: input
                };
        }), input.i) + ";";
  return input;
}

var schema = makeSchema(primitiveName, "never", empty, builder, undefined, toSelf);

var metadataId = "rescript-schema:Array.refinements";

function refinements(schema) {
  var m = schema.m[metadataId];
  if (m !== undefined) {
    return m;
  } else {
    return [];
  }
}

function typeFilter(_b, inputVar) {
  return "!Array.isArray(" + inputVar + ")";
}

function factory$2(schema) {
  return makeSchema((function () {
                return schema.n() + "[]";
              }), {
              TAG: "array",
              _0: schema
            }, empty, (function (b, input, param, path) {
                var inputVar = $$var(b, input);
                var iteratorVar = varWithoutAllocation(b);
                var bb = {
                  c: "",
                  l: "",
                  g: b.g
                };
                var itemInput = {
                  v: false,
                  i: inputVar + "[" + iteratorVar + "]",
                  a: false
                };
                var itemOutput = withPathPrepend(bb, itemInput, path, iteratorVar, (function (b, input, path) {
                        return parseWithTypeValidation(b, schema, input, path);
                      }));
                var itemCode = allocateScope(bb);
                var isTransformed = itemInput !== itemOutput;
                var output = isTransformed ? ({
                      v: false,
                      i: "[]",
                      a: false
                    }) : input;
                if (isTransformed || itemCode !== "") {
                  b.c = b.c + ("for(let " + iteratorVar + "=0;" + iteratorVar + "<" + inputVar + ".length;++" + iteratorVar + "){" + itemCode + (
                      isTransformed ? push(b, output, itemOutput) : ""
                    ) + "}");
                }
                if (itemOutput.a) {
                  return {
                          v: false,
                          i: "Promise.all(" + output.i + ")",
                          a: true
                        };
                } else {
                  return output;
                }
              }), typeFilter, onlyChild(factory$2, schema));
}

function typeFilter$1(_b, inputVar) {
  return "!" + inputVar + "||" + inputVar + ".constructor!==Object";
}

function name$1() {
  var tagged = this.t;
  if (tagged.fieldNames.length === 0) {
    return "{}";
  } else {
    return "{ " + tagged.fieldNames.map(function (fieldName) {
                  return fieldName + ": " + tagged.fields[fieldName].n() + ";";
                }).join(" ") + " }";
  }
}

function setUnknownKeys(schema, unknownKeys) {
  var match = schema.t;
  if (typeof match !== "object" || !(match.TAG === "object" && match.unknownKeys !== unknownKeys)) {
    return schema;
  } else {
    return {
            t: {
              TAG: "object",
              fieldNames: match.fieldNames,
              fields: match.fields,
              unknownKeys: unknownKeys,
              advanced: match.advanced
            },
            n: schema.n,
            "~r": schema["~r"],
            b: schema.b,
            f: schema.f,
            i: schema.i,
            m: schema.m
          };
  }
}

function strip(schema) {
  return setUnknownKeys(schema, "Strip");
}

function strict(schema) {
  return setUnknownKeys(schema, "Strict");
}

function name$2() {
  return "[" + this.t.items.map(function (schema) {
                return schema.n();
              }).join(", ") + "]";
}

function typeFilter$2(length) {
  return function (b, inputVar) {
    return typeFilter(b, inputVar) + ("||" + inputVar + ".length!==" + length);
  };
}

function factory$3(schema) {
  return makeSchema((function () {
                return "dict<" + schema.n() + ">";
              }), {
              TAG: "dict",
              _0: schema
            }, empty, (function (b, input, param, path) {
                var inputVar = $$var(b, input);
                var keyVar = varWithoutAllocation(b);
                var bb = {
                  c: "",
                  l: "",
                  g: b.g
                };
                var itemInput = {
                  v: false,
                  i: inputVar + "[" + keyVar + "]",
                  a: false
                };
                var itemOutput = withPathPrepend(bb, itemInput, path, keyVar, (function (b, input, path) {
                        return parseWithTypeValidation(b, schema, input, path);
                      }));
                var itemCode = allocateScope(bb);
                var isTransformed = itemInput !== itemOutput;
                var output = isTransformed ? ({
                      v: false,
                      i: "{}",
                      a: false
                    }) : input;
                if (isTransformed || itemCode !== "") {
                  b.c = b.c + ("for(let " + keyVar + " in " + inputVar + "){" + itemCode + (
                      isTransformed ? addKey(b, output, keyVar, itemOutput) : ""
                    ) + "}");
                }
                if (!itemOutput.a) {
                  return output;
                }
                var resolveVar = varWithoutAllocation(b);
                var rejectVar = varWithoutAllocation(b);
                var asyncParseResultVar = varWithoutAllocation(b);
                var counterVar = varWithoutAllocation(b);
                var outputVar = $$var(b, output);
                return {
                        v: false,
                        i: "new Promise((" + resolveVar + "," + rejectVar + ")=>{let " + counterVar + "=Object.keys(" + outputVar + ").length;for(let " + keyVar + " in " + outputVar + "){" + outputVar + "[" + keyVar + "].then(" + asyncParseResultVar + "=>{" + outputVar + "[" + keyVar + "]=" + asyncParseResultVar + ";if(" + counterVar + "--===1){" + resolveVar + "(" + outputVar + ")}}," + rejectVar + ")}})",
                        a: true
                      };
              }), typeFilter$1, onlyChild(factory$3, schema));
}

var schema$1 = makeSchema(primitiveName, "unknown", empty, invalidJson, undefined, toSelf);

var metadataId$1 = "rescript-schema:String.refinements";

function refinements$1(schema) {
  var m = schema.m[metadataId$1];
  if (m !== undefined) {
    return m;
  } else {
    return [];
  }
}

var cuidRegex = /^c[^\s-]{8,}$/i;

var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;

var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;

var datetimeRe = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?Z$/;

function typeFilter$3(_b, inputVar) {
  return "typeof " + inputVar + "!==\"string\"";
}

var schema$2 = makePrimitiveSchema("string", noop, typeFilter$3);

function factory$4(schema, spaceOpt) {
  var space = spaceOpt !== undefined ? spaceOpt : 0;
  return makeSchema(primitiveName, "string", empty, (function (b, input, param, path) {
                var jsonVal = allocateVal(b);
                b.c = b.c + ("try{" + jsonVal.i + "=JSON.parse(" + input.i + ")}catch(t){" + failWithArg(b, path, (function (message) {
                          return {
                                  TAG: "OperationFailed",
                                  _0: message
                                };
                        }), "t.message") + "}");
                return parseWithTypeValidation(b, schema, jsonVal, path);
              }), typeFilter$3, (function () {
                var reversed = schema["~r"]();
                return makeReverseSchema(reversed.n, reversed.t, reversed.m, (function (b, input, param, path) {
                              var prevFlag = b.g.o;
                              b.g.o = prevFlag | 8;
                              if (reversed.t.TAG === "option") {
                                raise(b, {
                                      TAG: "InvalidJsonSchema",
                                      _0: reversed
                                    }, "");
                              }
                              var output = {
                                v: false,
                                i: "JSON.stringify(" + reversed.b(b, input, reversed, path).i + (
                                  space > 0 ? ",null," + space : ""
                                ) + ")",
                                a: false
                              };
                              b.g.o = prevFlag;
                              return output;
                            }), reversed.f);
              }));
}

function typeFilter$4(_b, inputVar) {
  return "typeof " + inputVar + "!==\"boolean\"";
}

var schema$3 = makePrimitiveSchema("boolean", noop, typeFilter$4);

var metadataId$2 = "rescript-schema:Int.refinements";

function refinements$2(schema) {
  var m = schema.m[metadataId$2];
  if (m !== undefined) {
    return m;
  } else {
    return [];
  }
}

function typeFilter$5(_b, inputVar) {
  return "typeof " + inputVar + "!==\"number\"||" + inputVar + ">2147483647||" + inputVar + "<-2147483648||" + inputVar + "%1!==0";
}

var schema$4 = makePrimitiveSchema("int32", noop, typeFilter$5);

var metadataId$3 = "rescript-schema:Float.refinements";

function refinements$3(schema) {
  var m = schema.m[metadataId$3];
  if (m !== undefined) {
    return m;
  } else {
    return [];
  }
}

function typeFilter$6(_b, inputVar) {
  return "typeof " + inputVar + "!==\"number\"" + (
          globalConfig.n ? "" : "||Number.isNaN(" + inputVar + ")"
        );
}

var schema$5 = makePrimitiveSchema("number", noop, typeFilter$6);

function typeFilter$7(_b, inputVar) {
  return "typeof " + inputVar + "!==\"bigint\"";
}

var schema$6 = makePrimitiveSchema("bigint", invalidJson, typeFilter$7);

function parse$1(b, schemas, path, input, output) {
  var isMultiple = schemas.length > 1;
  var loop = function (idx, errorCodes) {
    if (idx === schemas.length) {
      return failWithArg(b, path, (function (internalErrors) {
                    return {
                            TAG: "InvalidUnion",
                            _0: internalErrors
                          };
                  }), "[" + errorCodes + "]");
    }
    var schema = schemas[idx];
    var parserCode;
    try {
      var bb = {
        c: "",
        l: "",
        g: b.g
      };
      var itemOutput = schema.b(bb, input, schema, "");
      if (itemOutput !== input) {
        bb.c = bb.c + set(bb, output, itemOutput);
      }
      parserCode = allocateScope(bb);
    }
    catch (exn){
      parserCode = "throw " + embed(b, getOrRethrow(exn));
    }
    if (!isMultiple) {
      return parserCode;
    }
    var errorVar = "e" + idx;
    return "try{" + parserCode + "}catch(" + errorVar + "){" + loop(idx + 1 | 0, errorCodes + errorVar + ",") + "}";
  };
  return loop(0, "");
}

function factory$5(schemas) {
  var len = schemas.length;
  if (len === 1) {
    return schemas[0];
  }
  if (len !== 0) {
    return makeSchema((function () {
                  return schemas.map(function (s) {
                                return s.n();
                              }).join(" | ");
                }), {
                TAG: "union",
                _0: schemas
              }, empty, (function (b, input, selfSchema, path) {
                  var schemas = selfSchema.t._0;
                  var inputVar = $$var(b, input);
                  var output = {
                    v: false,
                    i: inputVar,
                    a: false
                  };
                  $$var(b, output);
                  var byTypeFilter = {};
                  var typeFilters = [];
                  for(var idx = 0 ,idx_finish = schemas.length; idx < idx_finish; ++idx){
                    var schema = schemas[idx];
                    var typeFilterCode = schema.f !== undefined ? schema.f(b, inputVar) : "";
                    var schemas$1 = Js_dict.get(byTypeFilter, typeFilterCode);
                    if (schemas$1 !== undefined) {
                      schemas$1.push(schema);
                    } else {
                      typeFilters.push(typeFilterCode);
                      byTypeFilter[typeFilterCode] = [schema];
                    }
                  }
                  var loopTypeFilters = function (_idx, _maybeUnknownParser) {
                    while(true) {
                      var maybeUnknownParser = _maybeUnknownParser;
                      var idx = _idx;
                      if (idx === typeFilters.length) {
                        if (maybeUnknownParser !== undefined) {
                          return maybeUnknownParser;
                        } else {
                          return failWithArg(b, path, (function (received) {
                                        return {
                                                TAG: "InvalidType",
                                                expected: selfSchema,
                                                received: received
                                              };
                                      }), inputVar);
                        }
                      }
                      var typeFilterCode = typeFilters[idx];
                      var schemas = byTypeFilter[typeFilterCode];
                      var parserCode = parse$1(b, schemas, path, input, output);
                      if (typeFilterCode === "") {
                        _maybeUnknownParser = parserCode;
                        _idx = idx + 1 | 0;
                        continue ;
                      }
                      var tmp = parserCode === "" ? "" : "}else{" + parserCode;
                      return "if(" + typeFilterCode + "){" + loopTypeFilters(idx + 1 | 0, maybeUnknownParser) + tmp + "}";
                    };
                  };
                  b.c = b.c + loopTypeFilters(0, undefined);
                  if (output.a) {
                    return {
                            v: false,
                            i: "Promise.resolve(" + output.i + ")",
                            a: true
                          };
                  } else {
                    return output;
                  }
                }), undefined, (function () {
                  var original = this;
                  var schemas = original.t._0;
                  return factory$5(schemas.map(function (s) {
                                  return s["~r"]();
                                }));
                }));
  }
  throw new Error("[rescript-schema] S.union requires at least one item");
}

function $$enum(values) {
  return factory$5(values.map(literal));
}

function preprocess(schema, transformer) {
  var unionSchemas = schema.t;
  if (typeof unionSchemas === "object" && unionSchemas.TAG === "union") {
    return makeSchema(schema.n, {
                TAG: "union",
                _0: unionSchemas._0.map(function (unionSchema) {
                      return preprocess(unionSchema, transformer);
                    })
              }, schema.m, schema.b, schema.f, schema["~r"]);
  }
  return makeSchema(schema.n, schema.t, schema.m, (function (b, input, selfSchema, path) {
                var match = transformer(effectCtx(b, selfSchema, path));
                var parser = match.p;
                if (parser !== undefined) {
                  if (match.a !== undefined) {
                    return invalidOperation(b, path, "The S.preprocess doesn't allow parser and asyncParser at the same time. Remove parser in favor of asyncParser");
                  } else {
                    return parseWithTypeValidation(b, schema, embedSyncOperation(b, input, parser), path);
                  }
                }
                var asyncParser = match.a;
                if (asyncParser !== undefined) {
                  return transform(b, embedAsyncOperation(b, input, asyncParser), (function (b, input) {
                                return parseWithTypeValidation(b, schema, input, path);
                              }));
                } else {
                  return parseWithTypeValidation(b, schema, input, path);
                }
              }), undefined, (function () {
                var reversed = schema["~r"]();
                return makeReverseSchema(primitiveName, "unknown", empty, (function (b, input, param, path) {
                              var input$1 = reversed.b(b, input, reversed, path);
                              var match = transformer(effectCtx(b, schema, path));
                              var serializer = match.s;
                              if (serializer !== undefined) {
                                return embedSyncOperation(b, input$1, serializer);
                              } else {
                                return input$1;
                              }
                            }), undefined);
              }));
}

function list(schema) {
  return transform$1(factory$2(schema), (function (param) {
                return {
                        p: Belt_List.fromArray,
                        s: Belt_List.toArray
                      };
              }));
}

function json(validate) {
  return makeSchema((function () {
                return "JSON";
              }), {
              TAG: "JSON",
              validated: validate
            }, empty, validate ? (function (b, input, selfSchema, path) {
                  var parse = function (input, pathOpt) {
                    var path$1 = pathOpt !== undefined ? pathOpt : path;
                    var match = typeof input;
                    if (match === "string" || match === "boolean") {
                      return input;
                    }
                    if (match === "object") {
                      if (input === null) {
                        return input;
                      }
                      if (Array.isArray(input)) {
                        var output = [];
                        for(var idx = 0 ,idx_finish = input.length; idx < idx_finish; ++idx){
                          var inputItem = input[idx];
                          var $$location = idx.toString();
                          output.push(parse(inputItem, path$1 + ("[" + JSON.stringify($$location) + "]")));
                        }
                        return output;
                      }
                      var keys = Object.keys(input);
                      var output$1 = {};
                      for(var idx$1 = 0 ,idx_finish$1 = keys.length; idx$1 < idx_finish$1; ++idx$1){
                        var key = keys[idx$1];
                        var field = input[key];
                        output$1[key] = parse(field, path$1 + ("[" + JSON.stringify(key) + "]"));
                      }
                      return output$1;
                    }
                    if (match === "number" && !Number.isNaN(input)) {
                      return input;
                    }
                    return raise(b, {
                                TAG: "InvalidType",
                                expected: selfSchema,
                                received: input
                              }, path$1);
                  };
                  return map(b, embed(b, parse), input);
                }) : noop, undefined, (function () {
                if (validate) {
                  return json(false);
                } else {
                  return this;
                }
              }));
}

var Catch = {};

function $$catch(schema, getFallbackValue) {
  return makeSchema(schema.n, schema.t, schema.m, (function (b, input, selfSchema, path) {
                var inputVar = $$var(b, input);
                return withCatch(b, input, (function (b, errorVar) {
                              return {
                                      v: false,
                                      i: embed(b, (function (input, internalError) {
                                              return getFallbackValue({
                                                          e: internalError,
                                                          i: input,
                                                          s: selfSchema,
                                                          f: (function (message, customPathOpt) {
                                                              var customPath = customPathOpt !== undefined ? customPathOpt : "";
                                                              return raise(b, {
                                                                          TAG: "OperationFailed",
                                                                          _0: message
                                                                        }, path + customPath);
                                                            })
                                                        });
                                            })) + "(" + inputVar + "," + errorVar + ")",
                                      a: false
                                    };
                            }), (function (b) {
                              return parseWithTypeValidation(b, schema, input, path);
                            }));
              }), undefined, (function () {
                return schema["~r"]();
              }));
}

var deprecationMetadataId = "rescript-schema:deprecation";

function deprecate(schema, message) {
  return set$2(schema, deprecationMetadataId, message);
}

function deprecation(schema) {
  return schema.m[deprecationMetadataId];
}

var descriptionMetadataId = "rescript-schema:description";

function describe(schema, description) {
  return set$2(schema, descriptionMetadataId, description);
}

function description(schema) {
  return schema.m[descriptionMetadataId];
}

function getFullItemPath(item) {
  switch (item.k) {
    case 1 :
        return getFullItemPath(item.t) + item.p;
    case 0 :
    case 2 :
        return item.p;
    
  }
}

function getItemReversed(item) {
  switch (item.k) {
    case 1 :
        var $$location = item.l;
        var targetReversed = getItemReversed(item.t);
        var match = targetReversed.t;
        var maybeReversed;
        if (typeof match !== "object") {
          maybeReversed = undefined;
        } else {
          switch (match.TAG) {
            case "object" :
                maybeReversed = match.fields[$$location];
                break;
            case "tuple" :
                maybeReversed = match.items[$$location];
                break;
            default:
              maybeReversed = undefined;
          }
        }
        if (maybeReversed === undefined) {
          var message = "Impossible to reverse the " + item.i + " access of '" + targetReversed.n() + "' schema";
          throw new Error("[rescript-schema] " + message);
        }
        return maybeReversed;
    case 0 :
    case 2 :
        return item.s["~r"]();
    
  }
}

function definitionToOutput(b, definition, getItemOutput) {
  if (!(typeof definition === "object" && definition !== null)) {
    return {
            v: false,
            i: embed(b, definition),
            a: false
          };
  }
  var item = definition[itemSymbol];
  if (item !== undefined) {
    return getItemOutput(item);
  }
  var isArray = Array.isArray(definition);
  var keys = Object.keys(definition);
  var objectVal = make(b, isArray);
  for(var idx = 0 ,idx_finish = keys.length; idx < idx_finish; ++idx){
    var key = keys[idx];
    add(objectVal, isArray ? "\"" + key + "\"" : JSON.stringify(key), definitionToOutput(b, definition[key], getItemOutput));
  }
  return complete(objectVal, isArray);
}

function objectStrictModeCheck(b, input, inlinedLocations, unknownKeys, path) {
  if (!(unknownKeys === "Strict" && b.g.o & 1)) {
    return ;
  }
  var key = allocateVal(b);
  var keyVar = key.i;
  b.c = b.c + ("for(" + keyVar + " in " + input.i + "){if(");
  if (inlinedLocations.length !== 0) {
    for(var idx = 0 ,idx_finish = inlinedLocations.length; idx < idx_finish; ++idx){
      var inlinedLocation = inlinedLocations[idx];
      if (idx !== 0) {
        b.c = b.c + "&&";
      }
      b.c = b.c + (keyVar + "!==" + inlinedLocation);
    }
  } else {
    b.c = b.c + "true";
  }
  b.c = b.c + ("){" + failWithArg(b, path, (function (exccessFieldName) {
            return {
                    TAG: "ExcessField",
                    _0: exccessFieldName
                  };
          }), keyVar) + "}}");
}

function proxify(item) {
  return new Proxy(immutableEmpty, {
              get: (function (param, prop) {
                  if (prop === itemSymbol) {
                    return item;
                  }
                  var inlinedLocation = JSON.stringify(prop);
                  return proxify({
                              k: 1,
                              i: inlinedLocation,
                              l: prop,
                              t: item,
                              p: "[" + inlinedLocation + "]"
                            });
                })
            });
}

function definitionToRitem(definition, path, ritems, ritemsByItemPath) {
  if (!(typeof definition === "object" && definition !== null)) {
    return {
            k: 1,
            p: path,
            s: literal(definition)
          };
  }
  var item = definition[itemSymbol];
  if (item !== undefined) {
    var ritem_2 = getItemReversed(item);
    var ritem = {
      k: 0,
      p: path,
      i: item,
      s: ritem_2
    };
    item.r = ritem;
    ritemsByItemPath[getFullItemPath(item)] = ritem;
    return ritem;
  }
  var keys = Object.keys(definition);
  var isArray = Array.isArray(definition);
  var fields = isArray ? [] : ({});
  for(var idx = 0 ,idx_finish = keys.length; idx < idx_finish; ++idx){
    var $$location = keys[idx];
    var inlinedLocation = isArray ? "\"" + $$location + "\"" : JSON.stringify($$location);
    var ritem$1 = definitionToRitem(definition[$$location], path + ("[" + inlinedLocation + "]"), ritems, ritemsByItemPath);
    ritems.push(ritem$1);
    fields[$$location] = ritem$1.s;
  }
  return {
          k: 2,
          p: path,
          s: makeReverseSchema(isArray ? name$2 : name$1, isArray ? ({
                    TAG: "tuple",
                    items: fields
                  }) : ({
                    TAG: "object",
                    fieldNames: keys,
                    fields: fields,
                    unknownKeys: globalConfig.u,
                    advanced: true
                  }), empty, builder, isArray ? typeFilter$2(fields.length) : typeFilter$1),
          a: isArray
        };
}

function builder$1(schemas, inlinedLocations, isArray) {
  return function (parentB, input, selfSchema, path) {
    var unknownKeys = selfSchema.t.unknownKeys;
    var b = {
      c: "",
      l: "",
      g: parentB.g
    };
    var typeFilters = "";
    var objectVal = make(b, isArray);
    for(var idx = 0 ,idx_finish = schemas.length; idx < idx_finish; ++idx){
      var schema = schemas[idx];
      var inlinedLocation = inlinedLocations[idx];
      var itemPath = "[" + inlinedLocation + "]";
      var itemInput = get(b, input, inlinedLocation);
      var path$1 = path + itemPath;
      if (schema.f !== undefined) {
        if (schema.t.TAG === "literal" && !(b.g.o & 64)) {
          typeFilters = typeFilterCode(b, schema, itemInput, path$1) + typeFilters;
        } else if (b.g.o & 1) {
          typeFilters = typeFilters + typeFilterCode(b, schema, itemInput, path$1);
        }
        
      }
      add(objectVal, inlinedLocation, schema.b(b, itemInput, schema, path$1));
    }
    objectStrictModeCheck(b, input, inlinedLocations, unknownKeys, path);
    b.c = typeFilters + b.c;
    parentB.c = parentB.c + allocateScope(b);
    if ((unknownKeys !== "Strip" || b.g.o & 32) && selfSchema === selfSchema["~r"]()) {
      return input;
    } else {
      return complete(objectVal, isArray);
    }
  };
}

function reverse$1(fieldNames, schemas, inlinedLocations) {
  return function () {
    var reversedFields = {};
    var reversedSchemas = [];
    var isTransformed = false;
    for(var idx = 0 ,idx_finish = fieldNames.length; idx < idx_finish; ++idx){
      var fieldName = fieldNames[idx];
      var schema = schemas[idx];
      var reversed = schema["~r"]();
      reversedFields[fieldName] = reversed;
      reversedSchemas.push(reversed);
      if (schema !== reversed) {
        isTransformed = true;
      }
      
    }
    if (isTransformed) {
      return makeReverseSchema(name$1, {
                  TAG: "object",
                  fieldNames: fieldNames,
                  fields: reversedFields,
                  unknownKeys: globalConfig.u,
                  advanced: false
                }, empty, builder$1(reversedSchemas, inlinedLocations, false), typeFilter$1);
    } else {
      return this;
    }
  };
}

function nested(fieldName) {
  var parentCtx = this;
  var cacheId = "~" + fieldName;
  var ctx = parentCtx[cacheId];
  if (ctx !== undefined) {
    return Caml_option.valFromOption(ctx);
  }
  var schemas = [];
  var inlinedLocations = [];
  var fieldNames = [];
  var fields = {};
  var schema = makeSchema(name$1, {
        TAG: "object",
        fieldNames: fieldNames,
        fields: fields,
        unknownKeys: globalConfig.u,
        advanced: false
      }, empty, builder$1(schemas, inlinedLocations, false), typeFilter$1, reverse$1(fieldNames, schemas, inlinedLocations));
  var target = parentCtx.f(fieldName, schema)[itemSymbol];
  var field = function (fieldName, schema) {
    var inlinedLocation = JSON.stringify(fieldName);
    if (fields[fieldName]) {
      throw new Error("[rescript-schema] " + ("The field " + inlinedLocation + " defined twice"));
    }
    var item_3 = "[" + inlinedLocation + "]";
    var item = {
      k: 1,
      i: inlinedLocation,
      l: fieldName,
      t: target,
      p: item_3
    };
    fields[fieldName] = schema;
    fieldNames.push(fieldName);
    inlinedLocations.push(inlinedLocation);
    schemas.push(schema);
    return proxify(item);
  };
  var tag = function (tag$1, asValue) {
    field(tag$1, literal(asValue));
  };
  var fieldOr = function (fieldName, schema, or) {
    return field(fieldName, getOr(factory(schema), or));
  };
  var flatten = function (schema) {
    var match = schema.t;
    if (typeof match === "object" && match.TAG === "object") {
      var flattenedFields = match.fields;
      var flattenedFieldNames = match.fieldNames;
      if (match.advanced) {
        var message = "Unsupported nested flatten for advanced object schema '" + schema.n() + "'";
        throw new Error("[rescript-schema] " + message);
      }
      var match$1 = schema["~r"]().t;
      var exit = 0;
      if (typeof match$1 !== "object") {
        exit = 2;
      } else {
        if (match$1.TAG === "object" && !match$1.advanced) {
          var result = {};
          for(var idx = 0 ,idx_finish = flattenedFieldNames.length; idx < idx_finish; ++idx){
            var fieldName = flattenedFieldNames[idx];
            result[fieldName] = field(fieldName, flattenedFields[fieldName]);
          }
          return result;
        }
        exit = 2;
      }
      if (exit === 2) {
        var message$1 = "Unsupported nested flatten for transformed schema '" + schema.n() + "'";
        throw new Error("[rescript-schema] " + message$1);
      }
      
    }
    var message$2 = "The '" + schema.n() + "' schema can't be flattened";
    throw new Error("[rescript-schema] " + message$2);
  };
  var ctx$1 = {
    field: field,
    f: field,
    fieldOr: fieldOr,
    tag: tag,
    nested: nested,
    flatten: flatten,
    fields: fields,
    fieldNames: fieldNames
  };
  parentCtx[cacheId] = ctx$1;
  return ctx$1;
}

function advancedReverse(definition, kind, items) {
  return function () {
    var ritemsByItemPath = {};
    var ritems = [];
    var ritem = definitionToRitem(definition, "", ritems, ritemsByItemPath);
    var reversed;
    switch (ritem.k) {
      case 0 :
          var reversed$1 = ritem.s;
          reversed = makeReverseSchema(reversed$1.n, reversed$1.t, reversed$1.m, reversed$1.b, reversed$1.f);
          break;
      case 1 :
      case 2 :
          reversed = ritem.s;
          break;
      
    }
    reversed.b = (function (b, input, param, path) {
        var prevCode = b.c;
        b.c = "";
        var typeFilters = {
          contents: ""
        };
        for(var idx = 0 ,idx_finish = ritems.length; idx < idx_finish; ++idx){
          var match = ritems[idx];
          switch (match.k) {
            case 0 :
                break;
            case 1 :
                var rpath = match.p;
                var itemInput = {
                  v: false,
                  i: $$var(b, input) + rpath,
                  a: false
                };
                var path$1 = path + rpath;
                typeFilters.contents = typeFilters.contents + typeFilterCode(b, match.s, itemInput, path$1);
                break;
            case 2 :
                if (b.g.o & 1) {
                  invalidOperation(b, path, "Type validation mode is not supported");
                }
                break;
            
          }
        }
        var getRitemInput = function (ritem) {
          if (ritem.p === "") {
            return input;
          } else {
            return {
                    v: false,
                    i: $$var(b, input) + ritem.p,
                    a: false
                  };
          }
        };
        var reversedToInput = function (reversed, originalPath) {
          var literal = reversed.t;
          if (typeof literal === "object") {
            switch (literal.TAG) {
              case "literal" :
                  return {
                          v: false,
                          i: embed(b, literal._0.value),
                          a: false
                        };
              case "object" :
                  var fields = literal.fields;
                  var fieldNames = literal.fieldNames;
                  var objectVal = make(b, false);
                  for(var idx = 0 ,idx_finish = fieldNames.length; idx < idx_finish; ++idx){
                    var fieldName = fieldNames[idx];
                    var schema = fields[fieldName];
                    var inlinedLocation = JSON.stringify(fieldName);
                    var itemPath = originalPath + ("[" + inlinedLocation + "]");
                    var ritem = ritemsByItemPath[itemPath];
                    var itemInput = ritem !== undefined ? getRitemInput(ritem) : reversedToInput(schema, itemPath);
                    add(objectVal, inlinedLocation, itemInput);
                  }
                  return complete(objectVal, false);
              case "tuple" :
                  var schemas = literal.items;
                  var objectVal$1 = make(b, true);
                  for(var idx$1 = 0 ,idx_finish$1 = schemas.length; idx$1 < idx_finish$1; ++idx$1){
                    var schema$1 = schemas[idx$1];
                    var inlinedLocation$1 = "\"" + idx$1 + "\"";
                    var itemPath$1 = originalPath + ("[" + inlinedLocation$1 + "]");
                    var ritem$1 = ritemsByItemPath[itemPath$1];
                    var itemInput$1 = ritem$1 !== undefined ? getRitemInput(ritem$1) : reversedToInput(schema$1, itemPath$1);
                    add(objectVal$1, inlinedLocation$1, itemInput$1);
                  }
                  return complete(objectVal$1, true);
              default:
                
            }
          }
          var tmp = originalPath === "" ? "Schema isn't registered" : "Schema for " + originalPath + " isn't registered";
          return invalidOperation(b, path, tmp);
        };
        var getItemOutput = function (item) {
          var ritem = item.r;
          if (ritem !== undefined) {
            var reversed = ritem.s;
            var itemInput = getRitemInput(ritem);
            var path$2 = path + ritem.p;
            if (ritem.p !== "" && reversed.f !== undefined) {
              if (reversed.t.TAG === "literal" && !(b.g.o & 64)) {
                typeFilters.contents = typeFilterCode(b, reversed, itemInput, path$2) + typeFilters.contents;
              } else if (b.g.o & 1) {
                typeFilters.contents = typeFilters.contents + typeFilterCode(b, reversed, itemInput, path$2);
              }
              
            }
            return reversed.b(b, itemInput, reversed, path$2);
          }
          var reversed$1 = item.s["~r"]();
          var input = reversedToInput(reversed$1, item.p);
          var prevFlag = b.g.o;
          b.g.o = (prevFlag | 1) ^ 1 | 64;
          var output = reversed$1.b(b, input, reversed$1, path);
          b.g.o = prevFlag;
          return output;
        };
        var schemaOutput = function (items, isArray) {
          var objectVal = make(b, isArray);
          for(var idx = 0 ,idx_finish = items.length; idx < idx_finish; ++idx){
            var item = items[idx];
            switch (item.k) {
              case 0 :
                  add(objectVal, item.i, getItemOutput(item));
                  break;
              case 1 :
                  break;
              case 2 :
                  merge(objectVal, getItemOutput(item));
                  break;
              
            }
          }
          return complete(objectVal, isArray);
        };
        var output = kind === "To" ? getItemOutput(items[0]) : (
            kind === "Array" ? schemaOutput(items, true) : schemaOutput(items, false)
          );
        b.c = prevCode + typeFilters.contents + b.c;
        return output;
      });
    return reversed;
  };
}

function advancedBuilder(definition, items, inlinedLocations) {
  return function (parentB, input, selfSchema, path) {
    var outputs = new WeakMap();
    var unknownKeys = selfSchema.t.unknownKeys;
    var b = {
      c: "",
      l: "",
      g: parentB.g
    };
    var inputVar = $$var(b, input);
    var typeFilters = "";
    for(var idx = 0 ,idx_finish = items.length; idx < idx_finish; ++idx){
      var item = items[idx];
      switch (item.k) {
        case 0 :
            var schema = item.s;
            var itemPath = "[" + item.i + "]";
            var itemInput = {
              v: false,
              i: inputVar + itemPath,
              a: false
            };
            var path$1 = path + itemPath;
            if (schema.f !== undefined) {
              if (schema.t.TAG === "literal" && !(b.g.o & 64)) {
                typeFilters = typeFilterCode(b, schema, itemInput, path$1) + typeFilters;
              } else if (b.g.o & 1) {
                typeFilters = typeFilters + typeFilterCode(b, schema, itemInput, path$1);
              }
              
            }
            outputs.set(item, schema.b(b, itemInput, schema, path$1));
            break;
        case 1 :
            break;
        case 2 :
            var schema$1 = item.s;
            outputs.set(item, schema$1.b(b, input, schema$1, path));
            break;
        
      }
    }
    objectStrictModeCheck(b, input, inlinedLocations, unknownKeys, path);
    var getItemOutput = function (item) {
      switch (item.k) {
        case 1 :
            return get(b, getItemOutput(item.t), item.i);
        case 0 :
        case 2 :
            return outputs.get(item);
        
      }
    };
    var output = definitionToOutput(b, definition, getItemOutput);
    b.c = typeFilters + b.c;
    parentB.c = parentB.c + allocateScope(b);
    return output;
  };
}

function to(schema, definer) {
  var item = {
    k: 2,
    s: schema,
    p: ""
  };
  var definition = definer(proxify(item));
  return makeSchema(schema.n, schema.t, schema.m, (function (b, input, param, path) {
                var itemOutput = schema.b(b, input, schema, path);
                var bb = {
                  c: "",
                  l: "",
                  g: b.g
                };
                var getItemOutput = function (item) {
                  switch (item.k) {
                    case 1 :
                        return get(bb, getItemOutput(item.t), item.i);
                    case 0 :
                    case 2 :
                        return itemOutput;
                    
                  }
                };
                var output = definitionToOutput(bb, definition, getItemOutput);
                b.c = b.c + allocateScope(bb);
                return output;
              }), schema.f, advancedReverse(definition, "To", [item]));
}

function object(definer) {
  var inlinedLocations = [];
  var items = [];
  var fields = {};
  var fieldNames = [];
  var flatten = function (schema) {
    var match = schema.t;
    if (typeof match === "object" && match.TAG === "object") {
      var flattenedFields = match.fields;
      var flattenedFieldNames = match.fieldNames;
      for(var idx = 0 ,idx_finish = flattenedFieldNames.length; idx < idx_finish; ++idx){
        var fieldName = flattenedFieldNames[idx];
        var schema$1 = flattenedFields[fieldName];
        var definedSchema = fields[fieldName];
        if (definedSchema !== undefined) {
          if (definedSchema !== schema$1) {
            throw new Error("[rescript-schema] " + ("The field " + fieldName + " defined twice with incompatible schemas"));
          }
          
        } else {
          fields[fieldName] = schema$1;
          fieldNames.push(fieldName);
        }
      }
      var item_0 = setUnknownKeys(schema, "Strip");
      var item = {
        k: 2,
        s: item_0,
        p: ""
      };
      items.push(item);
      return proxify(item);
    }
    var message = "The '" + schema.n() + "' schema can't be flattened";
    throw new Error("[rescript-schema] " + message);
  };
  var field = function (fieldName, schema) {
    var inlinedLocation = JSON.stringify(fieldName);
    if (fields[fieldName]) {
      throw new Error("[rescript-schema] " + ("The field " + inlinedLocation + " defined twice with incompatible schemas"));
    }
    var item_2 = "[" + inlinedLocation + "]";
    var item = {
      k: 0,
      s: schema,
      i: inlinedLocation,
      p: item_2
    };
    fields[fieldName] = schema;
    fieldNames.push(fieldName);
    inlinedLocations.push(inlinedLocation);
    items.push(item);
    return proxify(item);
  };
  var tag = function (tag$1, asValue) {
    field(tag$1, literal(asValue));
  };
  var fieldOr = function (fieldName, schema, or) {
    return field(fieldName, getOr(factory(schema), or));
  };
  var ctx = {
    field: field,
    f: field,
    fieldOr: fieldOr,
    tag: tag,
    nested: nested,
    flatten: flatten,
    fields: fields,
    fieldNames: fieldNames
  };
  var definition = definer(ctx);
  return {
          t: {
            TAG: "object",
            fieldNames: fieldNames,
            fields: fields,
            unknownKeys: globalConfig.u,
            advanced: true
          },
          n: name$1,
          "~r": advancedReverse(definition, "Object", items),
          b: advancedBuilder(definition, items, inlinedLocations),
          f: typeFilter$1,
          i: 0,
          m: empty
        };
}

function tuple(definer) {
  var items = [];
  var inlinedLocations = [];
  var schemas = [];
  var item = function (idx, schema) {
    var inlinedLocation = "\"" + idx + "\"";
    if (items[idx]) {
      throw new Error("[rescript-schema] " + ("The item [" + inlinedLocation + "] is defined multiple times"));
    }
    var item_2 = "[" + inlinedLocation + "]";
    var item$1 = {
      k: 0,
      s: schema,
      i: inlinedLocation,
      p: item_2
    };
    schemas[idx] = schema;
    inlinedLocations[idx] = inlinedLocation;
    items[idx] = item$1;
    return proxify(item$1);
  };
  var tag = function (idx, asValue) {
    item(idx, literal(asValue));
  };
  var ctx = {
    item: item,
    tag: tag
  };
  var definition = definer(ctx);
  var length = items.length;
  for(var idx = 0; idx < length; ++idx){
    if (!schemas[idx]) {
      var inlinedLocation = "\"" + idx + "\"";
      var item_2 = "[" + inlinedLocation + "]";
      var item$1 = {
        k: 0,
        s: unit,
        i: inlinedLocation,
        p: item_2
      };
      schemas[idx] = unit;
      inlinedLocations[idx] = inlinedLocation;
      items[idx] = item$1;
    }
    
  }
  return makeSchema(name$2, {
              TAG: "tuple",
              items: schemas
            }, empty, advancedBuilder(definition, items, inlinedLocations), typeFilter$2(length), advancedReverse(definition, "Array", items));
}

function definitionToSchema(definition) {
  if (!(typeof definition === "object" && definition !== null)) {
    return literal(definition);
  }
  if (definition["~r"]) {
    return definition;
  }
  if (Array.isArray(definition)) {
    var length = definition.length;
    var inlinedLocations = new Array(length);
    var reversedSchemas = new Array(length);
    var isTransformed = false;
    for(var idx = 0 ,idx_finish = definition.length; idx < idx_finish; ++idx){
      var schema = definitionToSchema(definition[idx]);
      var reversed = schema["~r"]();
      definition[idx] = schema;
      reversedSchemas[idx] = reversed;
      inlinedLocations[idx] = "\"" + idx + "\"";
      if (schema !== reversed) {
        isTransformed = true;
      }
      
    }
    var maybeTypeFilter = typeFilter$2(length);
    return makeSchema(name$2, {
                TAG: "tuple",
                items: definition
              }, empty, builder$1(definition, inlinedLocations, true), maybeTypeFilter, isTransformed ? (function () {
                    return makeReverseSchema(name$2, {
                                TAG: "tuple",
                                items: reversedSchemas
                              }, empty, builder$1(reversedSchemas, inlinedLocations, true), maybeTypeFilter);
                  }) : toSelf);
  }
  var fieldNames = Object.keys(definition);
  var length$1 = fieldNames.length;
  var schemas = new Array(length$1);
  var inlinedLocations$1 = new Array(length$1);
  for(var idx$1 = 0; idx$1 < length$1; ++idx$1){
    var $$location = fieldNames[idx$1];
    var inlinedLocation = JSON.stringify($$location);
    var schema$1 = definitionToSchema(definition[$$location]);
    schemas[idx$1] = schema$1;
    inlinedLocations$1[idx$1] = inlinedLocation;
    definition[$$location] = schema$1;
  }
  return makeSchema(name$1, {
              TAG: "object",
              fieldNames: fieldNames,
              fields: definition,
              unknownKeys: globalConfig.u,
              advanced: false
            }, empty, builder$1(schemas, inlinedLocations$1, false), typeFilter$1, reverse$1(fieldNames, schemas, inlinedLocations$1));
}

function matches(schema) {
  return schema;
}

var ctx = {
  matches: matches
};

function factory$6(definer) {
  return definitionToSchema(definer(ctx));
}

var $$class = RescriptSchemaError;

function make$2(prim0, prim1, prim2) {
  return new RescriptSchemaError(prim0, prim1, prim2);
}

function raise$1(error) {
  throw error;
}

function reason(error, nestedLevelOpt) {
  var nestedLevel = nestedLevelOpt !== undefined ? nestedLevelOpt : 0;
  var reason$1 = error.code;
  if (typeof reason$1 !== "object") {
    return "Encountered unexpected async transform or refine. Use ParseAsync operation instead";
  }
  switch (reason$1.TAG) {
    case "OperationFailed" :
        return reason$1._0;
    case "InvalidOperation" :
        return reason$1.description;
    case "InvalidType" :
        return "Expected " + reason$1.expected.n() + ", received " + parseInternal(reason$1.received).s;
    case "ExcessField" :
        return "Encountered disallowed excess key " + JSON.stringify(reason$1._0) + " on an object";
    case "InvalidUnion" :
        var lineBreak = "\n" + " ".repeat((nestedLevel << 1));
        var reasonsDict = {};
        reason$1._0.forEach(function (error) {
              var reason$2 = reason(error, nestedLevel + 1);
              var nonEmptyPath = error.path;
              var $$location = nonEmptyPath === "" ? "" : "Failed at " + nonEmptyPath + ". ";
              reasonsDict["- " + $$location + reason$2] = undefined;
            });
        var uniqueReasons = Object.keys(reasonsDict);
        return "Invalid union with following errors" + lineBreak + uniqueReasons.join(lineBreak);
    case "InvalidJsonSchema" :
        return "The '" + reason$1._0.n() + "' schema cannot be converted to JSON";
    
  }
}

function reason$1(error) {
  return reason(error, undefined);
}

function message(error) {
  var op = error.flag;
  var text = "Failed " + (
    op & 1 ? (
        op & 4 ? "asserting" : "parsing"
      ) : "converting"
  );
  if (op & 32) {
    text = text + " reverse";
  }
  if (op & 2) {
    text = text + " async";
  }
  if (op & 8) {
    text = text + " to JSON" + (
      op & 16 ? " string" : ""
    );
  }
  var nonEmptyPath = error.path;
  var pathText = nonEmptyPath === "" ? "root" : nonEmptyPath;
  return text + " at " + pathText + ". Reason: " + reason(error, undefined);
}

function internalInline(schema, maybeVariant, param) {
  var metadataMap = Object.assign({}, schema.m);
  var literal = schema.t;
  var inlinedSchema;
  if (typeof literal !== "object") {
    switch (literal) {
      case "never" :
          inlinedSchema = "S.never";
          break;
      case "unknown" :
          inlinedSchema = "S.unknown";
          break;
      case "string" :
          inlinedSchema = "S.string";
          break;
      case "int32" :
          inlinedSchema = "S.int";
          break;
      case "number" :
          inlinedSchema = "S.float";
          break;
      case "bigint" :
          inlinedSchema = "S.bigint";
          break;
      case "boolean" :
          inlinedSchema = "S.bool";
          break;
      
    }
  } else {
    switch (literal.TAG) {
      case "literal" :
          inlinedSchema = "S.literal(%raw(\`" + literal._0.s + "\`))";
          break;
      case "option" :
          inlinedSchema = "S.option(" + internalInline(literal._0, undefined, undefined) + ")";
          break;
      case "null" :
          inlinedSchema = "S.null(" + internalInline(literal._0, undefined, undefined) + ")";
          break;
      case "array" :
          inlinedSchema = "S.array(" + internalInline(literal._0, undefined, undefined) + ")";
          break;
      case "object" :
          var fieldNames = literal.fieldNames;
          if (fieldNames.length !== 0) {
            var fields = literal.fields;
            inlinedSchema = "S.object(s =>\n  {\n    " + fieldNames.map(function (fieldName) {
                    var schema = fields[fieldName];
                    var inlinedLocation = JSON.stringify(fieldName);
                    return inlinedLocation + ": s.field(" + inlinedLocation + ", " + internalInline(schema, undefined, undefined) + ")";
                  }).join(",\n    ") + ",\n  }\n)";
          } else {
            inlinedSchema = "S.object(_ => ())";
          }
          break;
      case "tuple" :
          var items = literal.items;
          var exit = 0;
          var len = items.length;
          if (len >= 4) {
            exit = 1;
          } else {
            switch (len) {
              case 0 :
                  exit = 1;
                  break;
              case 1 :
                  var s0 = items[0];
                  inlinedSchema = "S.tuple1(" + internalInline(s0, undefined, undefined) + ")";
                  break;
              case 2 :
                  var s0$1 = items[0];
                  var s1 = items[1];
                  inlinedSchema = "S.tuple2(" + internalInline(s0$1, undefined, undefined) + ", " + internalInline(s1, undefined, undefined) + ")";
                  break;
              case 3 :
                  var s0$2 = items[0];
                  var s1$1 = items[1];
                  var s2 = items[2];
                  inlinedSchema = "S.tuple3(" + internalInline(s0$2, undefined, undefined) + ", " + internalInline(s1$1, undefined, undefined) + ", " + internalInline(s2, undefined, undefined) + ")";
                  break;
              
            }
          }
          if (exit === 1) {
            inlinedSchema = "S.tuple(s => (" + items.map(function (schema, idx) {
                    return "s.item(" + idx + ", " + internalInline(schema, undefined, undefined) + ")";
                  }).join(", ") + "))";
          }
          break;
      case "union" :
          var variantNamesCounter = {};
          inlinedSchema = "S.union([" + literal._0.map(function (s) {
                  var variantName = s.n();
                  var n = Js_dict.get(variantNamesCounter, variantName);
                  var numberOfVariantNames = n !== undefined ? n : 0;
                  variantNamesCounter[variantName] = numberOfVariantNames + 1;
                  var variantName$1 = numberOfVariantNames !== 0 ? variantName + (numberOfVariantNames + 1) : variantName;
                  var inlinedVariant = "#" + JSON.stringify(variantName$1);
                  return internalInline(s, inlinedVariant, undefined);
                }).join(", ") + "])";
          break;
      case "dict" :
          inlinedSchema = "S.dict(" + internalInline(literal._0, undefined, undefined) + ")";
          break;
      case "JSON" :
          inlinedSchema = "S.json(~validate=" + literal.validated + ")";
          break;
      
    }
  }
  var $$default = schema.m[defaultMetadataId];
  var inlinedSchema$1;
  if ($$default !== undefined) {
    Js_dict.unsafeDeleteKey(metadataMap, defaultMetadataId);
    if ($$default.TAG === "Value") {
      var defaultValue = $$default._0;
      inlinedSchema$1 = inlinedSchema + ("->S.Option.getOr(%raw(\`" + (
          defaultValue === (void 0) ? "undefined" : JSON.stringify(defaultValue)
        ) + "\`))");
    } else {
      var any = $$default._0();
      inlinedSchema$1 = inlinedSchema + ("->S.Option.getOrWith(() => %raw(\`" + (
          any === (void 0) ? "undefined" : JSON.stringify(any)
        ) + "\`))");
    }
  } else {
    inlinedSchema$1 = inlinedSchema;
  }
  var message = deprecation(schema);
  var inlinedSchema$2 = message !== undefined ? (Js_dict.unsafeDeleteKey(metadataMap, deprecationMetadataId), inlinedSchema$1 + ("->S.deprecate(" + JSON.stringify(message) + ")")) : inlinedSchema$1;
  var message$1 = description(schema);
  var inlinedSchema$3 = message$1 !== undefined ? (Js_dict.unsafeDeleteKey(metadataMap, descriptionMetadataId), inlinedSchema$2 + ("->S.describe(" + (
          message$1 === (void 0) ? "undefined" : JSON.stringify(message$1)
        ) + ")")) : inlinedSchema$2;
  var match = schema.t;
  var inlinedSchema$4;
  inlinedSchema$4 = typeof match !== "object" || !(match.TAG === "object" && match.unknownKeys !== "Strip") ? inlinedSchema$3 : inlinedSchema$3 + "->S.Object.strict";
  var match$1 = schema.t;
  var inlinedSchema$5;
  var exit$1 = 0;
  if (typeof match$1 !== "object") {
    switch (match$1) {
      case "string" :
          exit$1 = 1;
          break;
      case "int32" :
          var refinements$4 = refinements$2(schema);
          if (refinements$4.length !== 0) {
            Js_dict.unsafeDeleteKey(metadataMap, metadataId$2);
            inlinedSchema$5 = inlinedSchema$4 + refinements$4.map(function (refinement) {
                    var match = refinement.kind;
                    if (typeof match !== "object") {
                      return "->S.port(~message=" + JSON.stringify(refinement.message) + ")";
                    } else if (match.TAG === "Min") {
                      return "->S.intMin(" + match.value + ", ~message=" + JSON.stringify(refinement.message) + ")";
                    } else {
                      return "->S.intMax(" + match.value + ", ~message=" + JSON.stringify(refinement.message) + ")";
                    }
                  }).join("");
          } else {
            inlinedSchema$5 = inlinedSchema$4;
          }
          break;
      case "number" :
          var refinements$5 = refinements$3(schema);
          if (refinements$5.length !== 0) {
            Js_dict.unsafeDeleteKey(metadataMap, metadataId$3);
            inlinedSchema$5 = inlinedSchema$4 + refinements$5.map(function (refinement) {
                    var match = refinement.kind;
                    if (match.TAG === "Min") {
                      var value = match.value;
                      return "->S.floatMin(" + (value.toString() + (
                                value % 1 === 0 ? "." : ""
                              )) + ", ~message=" + JSON.stringify(refinement.message) + ")";
                    }
                    var value$1 = match.value;
                    return "->S.floatMax(" + (value$1.toString() + (
                              value$1 % 1 === 0 ? "." : ""
                            )) + ", ~message=" + JSON.stringify(refinement.message) + ")";
                  }).join("");
          } else {
            inlinedSchema$5 = inlinedSchema$4;
          }
          break;
      default:
        inlinedSchema$5 = inlinedSchema$4;
    }
  } else {
    switch (match$1.TAG) {
      case "literal" :
          if (match$1._0.kind === "String") {
            exit$1 = 1;
          } else {
            inlinedSchema$5 = inlinedSchema$4;
          }
          break;
      case "array" :
          var refinements$6 = refinements(schema);
          if (refinements$6.length !== 0) {
            Js_dict.unsafeDeleteKey(metadataMap, metadataId);
            inlinedSchema$5 = inlinedSchema$4 + refinements$6.map(function (refinement) {
                    var match = refinement.kind;
                    switch (match.TAG) {
                      case "Min" :
                          return "->S.arrayMinLength(" + match.length + ", ~message=" + JSON.stringify(refinement.message) + ")";
                      case "Max" :
                          return "->S.arrayMaxLength(" + match.length + ", ~message=" + JSON.stringify(refinement.message) + ")";
                      case "Length" :
                          return "->S.arrayLength(" + match.length + ", ~message=" + JSON.stringify(refinement.message) + ")";
                      
                    }
                  }).join("");
          } else {
            inlinedSchema$5 = inlinedSchema$4;
          }
          break;
      default:
        inlinedSchema$5 = inlinedSchema$4;
    }
  }
  if (exit$1 === 1) {
    var refinements$7 = refinements$1(schema);
    if (refinements$7.length !== 0) {
      Js_dict.unsafeDeleteKey(metadataMap, metadataId$1);
      inlinedSchema$5 = inlinedSchema$4 + refinements$7.map(function (refinement) {
              var match = refinement.kind;
              if (typeof match !== "object") {
                switch (match) {
                  case "Email" :
                      return "->S.email(~message=" + JSON.stringify(refinement.message) + ")";
                  case "Uuid" :
                      return "->S.uuid(~message=" + JSON.stringify(refinement.message) + ")";
                  case "Cuid" :
                      return "->S.cuid(~message=" + JSON.stringify(refinement.message) + ")";
                  case "Url" :
                      return "->S.url(~message=" + JSON.stringify(refinement.message) + ")";
                  case "Datetime" :
                      return "->S.datetime(~message=" + JSON.stringify(refinement.message) + ")";
                  
                }
              } else {
                switch (match.TAG) {
                  case "Min" :
                      return "->S.stringMinLength(" + match.length + ", ~message=" + JSON.stringify(refinement.message) + ")";
                  case "Max" :
                      return "->S.stringMaxLength(" + match.length + ", ~message=" + JSON.stringify(refinement.message) + ")";
                  case "Length" :
                      return "->S.stringLength(" + match.length + ", ~message=" + JSON.stringify(refinement.message) + ")";
                  case "Pattern" :
                      return "->S.pattern(%re(" + JSON.stringify(match.re.toString()) + "), ~message=" + JSON.stringify(refinement.message) + ")";
                  
                }
              }
            }).join("");
    } else {
      inlinedSchema$5 = inlinedSchema$4;
    }
  }
  var inlinedSchema$6 = Object.keys(metadataMap).length !== 0 ? "{\n  let s = " + inlinedSchema$5 + "\n  let _ = %raw(\`s.m = " + JSON.stringify(metadataMap) + "\`)\n  s\n}" : inlinedSchema$5;
  if (maybeVariant !== undefined) {
    return inlinedSchema$6 + ("->S.to(v => " + maybeVariant + "(v))");
  } else {
    return inlinedSchema$6;
  }
}

function inline(schema) {
  return internalInline(schema, undefined, undefined);
}

function tuple1(v0) {
  return tuple(function (s) {
              return s.item(0, v0);
            });
}

function tuple2(v0, v1) {
  return definitionToSchema([
              v0,
              v1
            ]);
}

function tuple3(v0, v1, v2) {
  return definitionToSchema([
              v0,
              v1,
              v2
            ]);
}

function intMin(schema, minValue, maybeMessage) {
  var message = maybeMessage !== undefined ? maybeMessage : "Number must be greater than or equal to " + minValue;
  return addRefinement(schema, metadataId$2, {
              kind: {
                TAG: "Min",
                value: minValue
              },
              message: message
            }, (function (b, inputVar, param, path) {
                return "if(" + inputVar + "<" + embed(b, minValue) + "){" + fail(b, message, path) + "}";
              }));
}

function intMax(schema, maxValue, maybeMessage) {
  var message = maybeMessage !== undefined ? maybeMessage : "Number must be lower than or equal to " + maxValue;
  return addRefinement(schema, metadataId$2, {
              kind: {
                TAG: "Max",
                value: maxValue
              },
              message: message
            }, (function (b, inputVar, param, path) {
                return "if(" + inputVar + ">" + embed(b, maxValue) + "){" + fail(b, message, path) + "}";
              }));
}

function port(schema, messageOpt) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid port";
  return addRefinement(schema, metadataId$2, {
              kind: "Port",
              message: message
            }, (function (b, inputVar, param, path) {
                return "if(" + inputVar + "<1||" + inputVar + ">65535){" + fail(b, message, path) + "}";
              }));
}

function floatMin(schema, minValue, maybeMessage) {
  var message = maybeMessage !== undefined ? maybeMessage : "Number must be greater than or equal to " + minValue;
  return addRefinement(schema, metadataId$3, {
              kind: {
                TAG: "Min",
                value: minValue
              },
              message: message
            }, (function (b, inputVar, param, path) {
                return "if(" + inputVar + "<" + embed(b, minValue) + "){" + fail(b, message, path) + "}";
              }));
}

function floatMax(schema, maxValue, maybeMessage) {
  var message = maybeMessage !== undefined ? maybeMessage : "Number must be lower than or equal to " + maxValue;
  return addRefinement(schema, metadataId$3, {
              kind: {
                TAG: "Max",
                value: maxValue
              },
              message: message
            }, (function (b, inputVar, param, path) {
                return "if(" + inputVar + ">" + embed(b, maxValue) + "){" + fail(b, message, path) + "}";
              }));
}

function arrayMinLength(schema, length, maybeMessage) {
  var message = maybeMessage !== undefined ? maybeMessage : "Array must be " + length + " or more items long";
  return addRefinement(schema, metadataId, {
              kind: {
                TAG: "Min",
                length: length
              },
              message: message
            }, (function (b, inputVar, param, path) {
                return "if(" + inputVar + ".length<" + embed(b, length) + "){" + fail(b, message, path) + "}";
              }));
}

function arrayMaxLength(schema, length, maybeMessage) {
  var message = maybeMessage !== undefined ? maybeMessage : "Array must be " + length + " or fewer items long";
  return addRefinement(schema, metadataId, {
              kind: {
                TAG: "Max",
                length: length
              },
              message: message
            }, (function (b, inputVar, param, path) {
                return "if(" + inputVar + ".length>" + embed(b, length) + "){" + fail(b, message, path) + "}";
              }));
}

function arrayLength(schema, length, maybeMessage) {
  var message = maybeMessage !== undefined ? maybeMessage : "Array must be exactly " + length + " items long";
  return addRefinement(schema, metadataId, {
              kind: {
                TAG: "Length",
                length: length
              },
              message: message
            }, (function (b, inputVar, param, path) {
                return "if(" + inputVar + ".length!==" + embed(b, length) + "){" + fail(b, message, path) + "}";
              }));
}

function stringMinLength(schema, length, maybeMessage) {
  var message = maybeMessage !== undefined ? maybeMessage : "String must be " + length + " or more characters long";
  return addRefinement(schema, metadataId$1, {
              kind: {
                TAG: "Min",
                length: length
              },
              message: message
            }, (function (b, inputVar, param, path) {
                return "if(" + inputVar + ".length<" + embed(b, length) + "){" + fail(b, message, path) + "}";
              }));
}

function stringMaxLength(schema, length, maybeMessage) {
  var message = maybeMessage !== undefined ? maybeMessage : "String must be " + length + " or fewer characters long";
  return addRefinement(schema, metadataId$1, {
              kind: {
                TAG: "Max",
                length: length
              },
              message: message
            }, (function (b, inputVar, param, path) {
                return "if(" + inputVar + ".length>" + embed(b, length) + "){" + fail(b, message, path) + "}";
              }));
}

function stringLength(schema, length, maybeMessage) {
  var message = maybeMessage !== undefined ? maybeMessage : "String must be exactly " + length + " characters long";
  return addRefinement(schema, metadataId$1, {
              kind: {
                TAG: "Length",
                length: length
              },
              message: message
            }, (function (b, inputVar, param, path) {
                return "if(" + inputVar + ".length!==" + embed(b, length) + "){" + fail(b, message, path) + "}";
              }));
}

function email(schema, messageOpt) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid email address";
  return addRefinement(schema, metadataId$1, {
              kind: "Email",
              message: message
            }, (function (b, inputVar, param, path) {
                return "if(!" + embed(b, emailRegex) + ".test(" + inputVar + ")){" + fail(b, message, path) + "}";
              }));
}

function uuid(schema, messageOpt) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid UUID";
  return addRefinement(schema, metadataId$1, {
              kind: "Uuid",
              message: message
            }, (function (b, inputVar, param, path) {
                return "if(!" + embed(b, uuidRegex) + ".test(" + inputVar + ")){" + fail(b, message, path) + "}";
              }));
}

function cuid(schema, messageOpt) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid CUID";
  return addRefinement(schema, metadataId$1, {
              kind: "Cuid",
              message: message
            }, (function (b, inputVar, param, path) {
                return "if(!" + embed(b, cuidRegex) + ".test(" + inputVar + ")){" + fail(b, message, path) + "}";
              }));
}

function url(schema, messageOpt) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid url";
  return addRefinement(schema, metadataId$1, {
              kind: "Url",
              message: message
            }, (function (b, inputVar, param, path) {
                return "try{new URL(" + inputVar + ")}catch(_){" + fail(b, message, path) + "}";
              }));
}

function pattern(schema, re, messageOpt) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid";
  return addRefinement(schema, metadataId$1, {
              kind: {
                TAG: "Pattern",
                re: re
              },
              message: message
            }, (function (b, inputVar, param, path) {
                var reVal = {
                  v: false,
                  i: embed(b, re),
                  a: false
                };
                var reVar = $$var(b, reVal);
                return reVar + ".lastIndex=0;if(!" + reVar + ".test(" + inputVar + ")){" + fail(b, message, path) + "}";
              }));
}

function datetime(schema, messageOpt) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid datetime string! Must be UTC";
  var refinement = {
    kind: "Datetime",
    message: message
  };
  var refinements = schema.m[metadataId$1];
  return transform$1(set$2(schema, metadataId$1, refinements !== undefined ? refinements.concat(refinement) : [refinement]), (function (s) {
                return {
                        p: (function (string) {
                            if (!datetimeRe.test(string)) {
                              s.fail(message, undefined);
                            }
                            return new Date(string);
                          }),
                        s: (function (date) {
                            return date.toISOString();
                          })
                      };
              }));
}

function trim(schema) {
  var transformer = function (string) {
    return string.trim();
  };
  return transform$1(schema, (function (param) {
                return {
                        p: transformer,
                        s: transformer
                      };
              }));
}

function js_union(values) {
  return factory$5(values.map(definitionToSchema));
}

function js_transform(schema, maybeParser, maybeSerializer) {
  return transform$1(schema, (function (s) {
                return {
                        p: maybeParser !== undefined ? (function (v) {
                              return maybeParser(v, s);
                            }) : undefined,
                        s: maybeSerializer !== undefined ? (function (v) {
                              return maybeSerializer(v, s);
                            }) : undefined
                      };
              }));
}

function js_refine(schema, refiner) {
  return refine(schema, (function (s) {
                return function (v) {
                  refiner(v, s);
                };
              }));
}

function noop$1(a) {
  return a;
}

function js_asyncParserRefine(schema, refine) {
  return transform$1(schema, (function (s) {
                return {
                        a: (function (v) {
                            return refine(v, s).then(function () {
                                        return v;
                                      });
                          }),
                        s: noop$1
                      };
              }));
}

function js_optional(schema, maybeOr) {
  var schema$1 = factory(schema);
  if (maybeOr === undefined) {
    return schema$1;
  }
  var or = Caml_option.valFromOption(maybeOr);
  if (typeof or === "function") {
    return getOrWith(schema$1, or);
  } else {
    return getOr(schema$1, or);
  }
}

function js_custom(name, maybeParser, maybeSerializer, param) {
  return custom(name, (function (s) {
                return {
                        p: maybeParser !== undefined ? (function (v) {
                              return maybeParser(v, s);
                            }) : undefined,
                        s: maybeSerializer !== undefined ? (function (v) {
                              return maybeSerializer(v, s);
                            }) : undefined
                      };
              }));
}

function js_merge(s1, s2) {
  var match = s1.t;
  if (typeof match === "object" && match.TAG === "object") {
    var s1Fields = match.fields;
    var s1FieldNames = match.fieldNames;
    var match$1 = s2.t;
    if (typeof match$1 === "object" && match$1.TAG === "object") {
      var s2Fields = match$1.fields;
      var s2FieldNames = match$1.fieldNames;
      var fieldNames = [];
      var fields = {};
      for(var idx = 0 ,idx_finish = s1FieldNames.length; idx < idx_finish; ++idx){
        var fieldName = s1FieldNames[idx];
        fieldNames.push(fieldName);
        fields[fieldName] = s1Fields[fieldName];
      }
      for(var idx$1 = 0 ,idx_finish$1 = s2FieldNames.length; idx$1 < idx_finish$1; ++idx$1){
        var fieldName$1 = s2FieldNames[idx$1];
        if (fields[fieldName$1]) {
          throw new Error("[rescript-schema] " + ("The field \"" + fieldName$1 + "\" is defined multiple times"));
        }
        fieldNames.push(fieldName$1);
        fields[fieldName$1] = s2Fields[fieldName$1];
      }
      return makeSchema((function () {
                    return s1.n() + " & " + s2.n();
                  }), {
                  TAG: "object",
                  fieldNames: fieldNames,
                  fields: fields,
                  unknownKeys: match$1.unknownKeys,
                  advanced: true
                }, empty, (function (b, input, param, path) {
                    var s1Result = s1.b(b, input, s1, path);
                    var s2Result = s2.b(b, input, s2, path);
                    return {
                            v: false,
                            i: "{..." + s1Result.i + ", ..." + s2Result.i + "}",
                            a: false
                          };
                  }), typeFilter$1, (function () {
                    return makeReverseSchema(primitiveName, "unknown", empty, (function (b, param, param$1, path) {
                                  return invalidOperation(b, path, "The S.merge serializing is not supported yet");
                                }), undefined);
                  }));
    }
    
  }
  throw new Error("[rescript-schema] The merge supports only Object schemas");
}

function js_name(prim) {
  return prim.n();
}

var resetOperationsCache = ((schema) => {
  for (let key in schema) {
    if (+key) {
      delete schema[key];
    }
  }
});

function setGlobalConfig(override) {
  globalConfig.r = 0;
  var unknownKeys = override.defaultUnknownKeys;
  globalConfig.u = unknownKeys !== undefined ? unknownKeys : "Strip";
  var prevDisableNanNumberCheck = globalConfig.n;
  var disableNanNumberValidation = override.disableNanNumberValidation;
  globalConfig.n = disableNanNumberValidation !== undefined ? disableNanNumberValidation : false;
  if (prevDisableNanNumberCheck !== globalConfig.n) {
    return resetOperationsCache(schema$5);
  }
  
}

var Path = {
  empty: "",
  dynamic: "[]",
  toArray: toArray,
  fromArray: fromArray,
  fromLocation: fromLocation,
  concat: concat
};

var Flag = {
  none: 0,
  typeValidation: 1,
  async: 2,
  assertOutput: 4,
  jsonableOutput: 8,
  jsonStringOutput: 16,
  reverse: 32,
  has: has
};

var $$Error$1 = {
  $$class: $$class,
  make: make$2,
  raise: raise$1,
  message: message,
  reason: reason$1
};

var Literal = {
  parse: parse,
  value: value,
  isJsonable: isJsonable,
  toString: toString
};

var never = schema;

var unknown = schema$1;

var string = schema$2;

var bool = schema$3;

var $$int = schema$4;

var $$float = schema$5;

var bigint = schema$6;

var array = factory$2;

var dict = factory$3;

var option = factory;

var $$null$1 = factory$1;

var jsonString = factory$4;

var union = factory$5;

var Schema = {};

var schema$7 = factory$6;

var $$Object = {
  strip: strip,
  strict: strict
};

var Tuple = {};

var $$Option = {
  $$default: $$default,
  getOr: getOr,
  getOrWith: getOrWith
};

var String_Refinement = {};

var $$String = {
  Refinement: String_Refinement,
  refinements: refinements$1
};

var Int_Refinement = {};

var Int = {
  Refinement: Int_Refinement,
  refinements: refinements$2
};

var Float_Refinement = {};

var Float = {
  Refinement: Float_Refinement,
  refinements: refinements$3
};

var Array_Refinement = {};

var $$Array$1 = {
  Refinement: Array_Refinement,
  refinements: refinements
};

var Metadata = {
  Id: Id,
  get: get$1,
  set: set$2
};

var js_schema = definitionToSchema;

export {
  Path ,
  Raised ,
  Flag ,
  $$Error$1 as $$Error,
  Literal ,
  never ,
  unknown ,
  unit ,
  string ,
  bool ,
  $$int ,
  $$float ,
  bigint ,
  json ,
  literal ,
  array ,
  list ,
  dict ,
  option ,
  $$null$1 as $$null,
  nullable ,
  jsonString ,
  union ,
  $$enum ,
  Catch ,
  $$catch ,
  describe ,
  description ,
  deprecate ,
  deprecation ,
  transform$1 as transform,
  preprocess ,
  custom ,
  refine ,
  to ,
  compile$1 as compile,
  parseOrThrow ,
  parseJsonStringOrThrow ,
  parseAsyncOrThrow ,
  convertOrThrow ,
  convertToJsonOrThrow ,
  convertToJsonStringOrThrow ,
  convertAsyncOrThrow ,
  reverseConvertOrThrow ,
  reverseConvertToJsonOrThrow ,
  reverseConvertToJsonStringOrThrow ,
  assertOrThrow ,
  isAsync ,
  recursive ,
  setName ,
  removeTypeValidation ,
  Schema ,
  schema$7 as schema,
  $$Object ,
  object ,
  Tuple ,
  tuple ,
  tuple1 ,
  tuple2 ,
  tuple3 ,
  $$Option ,
  $$String ,
  Int ,
  Float ,
  $$Array$1 as $$Array,
  Metadata ,
  inline ,
  reverse ,
  intMin ,
  intMax ,
  port ,
  floatMin ,
  floatMax ,
  arrayMinLength ,
  arrayMaxLength ,
  arrayLength ,
  stringMinLength ,
  stringMaxLength ,
  stringLength ,
  email ,
  uuid ,
  cuid ,
  url ,
  pattern ,
  datetime ,
  trim ,
  js_safe ,
  js_safeAsync ,
  js_union ,
  js_optional ,
  js_custom ,
  js_asyncParserRefine ,
  js_refine ,
  js_transform ,
  js_schema ,
  js_merge ,
  js_name ,
  setGlobalConfig ,
}
/* symbol Not a pure module */
