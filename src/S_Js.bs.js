// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var S = require("./S.bs.js");
var Js_exn = require("rescript/lib/js/js_exn.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");

class ReScriptStructError extends Error {
      constructor(message) {
        super(message);
        this.name = "ReScriptStructError";
      }
    }
    exports.ReScriptStructError = ReScriptStructError
;

function fromOk(value) {
  return {
          success: true,
          value: value
        };
}

function fromError(error) {
  return {
          success: false,
          error: error
        };
}

var structOperations = {};

function parse(data) {
  var struct = this;
  try {
    return fromOk(S.parseOrRaiseWith(data, struct));
  }
  catch (raw_error){
    var error = Caml_js_exceptions.internalToOCamlException(raw_error);
    if (error.RE_EXN_ID === S.Raised) {
      return fromError(new ReScriptStructError(S.$$Error.toString(error._1)));
    }
    throw error;
  }
}

function parseOrThrow(data) {
  var struct = this;
  try {
    return S.parseOrRaiseWith(data, struct);
  }
  catch (raw_error){
    var error = Caml_js_exceptions.internalToOCamlException(raw_error);
    if (error.RE_EXN_ID === S.Raised) {
      throw new ReScriptStructError(S.$$Error.toString(error._1));
    }
    throw error;
  }
}

function parseAsync(data) {
  var struct = this;
  return S.parseAsyncWith(data, struct).then(function (result) {
              if (result.TAG === /* Ok */0) {
                return fromOk(result._0);
              } else {
                return fromError(new ReScriptStructError(S.$$Error.toString(result._0)));
              }
            });
}

function serialize(value) {
  var struct = this;
  try {
    return fromOk(S.serializeOrRaiseWith(value, struct));
  }
  catch (raw_error){
    var error = Caml_js_exceptions.internalToOCamlException(raw_error);
    if (error.RE_EXN_ID === S.Raised) {
      return fromError(new ReScriptStructError(S.$$Error.toString(error._1)));
    }
    throw error;
  }
}

function serializeOrThrow(value) {
  var struct = this;
  try {
    return S.serializeOrRaiseWith(value, struct);
  }
  catch (raw_error){
    var error = Caml_js_exceptions.internalToOCamlException(raw_error);
    if (error.RE_EXN_ID === S.Raised) {
      throw new ReScriptStructError(S.$$Error.toString(error._1));
    }
    throw error;
  }
}

function transform(parser, serializer) {
  var struct = this;
  var struct$1 = S.transform(struct, parser, serializer, undefined);
  return Object.assign(struct$1, structOperations);
}

function refine(parser, serializer) {
  var struct = this;
  var struct$1 = S.refine(struct, parser, serializer, undefined);
  return Object.assign(struct$1, structOperations);
}

function asyncRefine(parser) {
  var struct = this;
  var struct$1 = S.asyncRefine(struct, parser, undefined);
  return Object.assign(struct$1, structOperations);
}

function string(param) {
  var struct = S.string(undefined);
  return Object.assign(struct, structOperations);
}

function $$boolean(param) {
  var struct = S.bool(undefined);
  return Object.assign(struct, structOperations);
}

function integer(param) {
  var struct = S.$$int(undefined);
  return Object.assign(struct, structOperations);
}

function number(param) {
  var struct = S.$$float(undefined);
  return Object.assign(struct, structOperations);
}

function never(param) {
  var struct = S.never(undefined);
  return Object.assign(struct, structOperations);
}

function unknown(param) {
  var struct = S.unknown(undefined);
  return Object.assign(struct, structOperations);
}

function optional(struct) {
  var struct$1 = S.option(struct);
  return Object.assign(struct$1, structOperations);
}

function nullable(struct) {
  var struct$1 = S.$$null(struct);
  return Object.assign(struct$1, structOperations);
}

function array(struct) {
  var struct$1 = S.array(struct);
  return Object.assign(struct$1, structOperations);
}

function record(struct) {
  var struct$1 = S.dict(struct);
  return Object.assign(struct$1, structOperations);
}

function json(struct) {
  var struct$1 = S.json(struct);
  return Object.assign(struct$1, structOperations);
}

function union(structs) {
  var struct = S.union(structs);
  return Object.assign(struct, structOperations);
}

function defaulted(struct, value) {
  var struct$1 = S.defaulted(struct, value);
  return Object.assign(struct$1, structOperations);
}

function literal(value) {
  var taggedLiteral = typeof value === "string" ? ({
        TAG: /* String */0,
        _0: value
      }) : (
      typeof value === "boolean" ? ({
            TAG: /* Bool */3,
            _0: value
          }) : (
          typeof value === "number" ? (
              Number.isNaN(value) ? Js_exn.raiseError("[rescript-struct] Failed to create a NaN literal struct. Use S.nan instead.") : ({
                    TAG: /* Float */2,
                    _0: value
                  })
            ) : (
              value === null ? /* EmptyNull */0 : (
                  value === undefined ? /* EmptyOption */1 : Js_exn.raiseError("[rescript-struct] The value provided to literal struct factory is not supported.")
                )
            )
        )
    );
  var struct = S.literal(taggedLiteral);
  return Object.assign(struct, structOperations);
}

function nan(param) {
  var struct = S.literal(/* NaN */2);
  return Object.assign(struct, structOperations);
}

function custom(name, parser, serializer) {
  var struct = S.custom(name, parser, serializer, undefined);
  return Object.assign(struct, structOperations);
}

Object.assign(structOperations, {
      parse: parse,
      parseOrThrow: parseOrThrow,
      parseAsync: parseAsync,
      serialize: serialize,
      serializeOrThrow: serializeOrThrow,
      transform: transform,
      refine: refine,
      asyncRefine: asyncRefine,
      optional: (function (param) {
          return optional(this);
        }),
      nullable: (function (param) {
          return nullable(this);
        })
    });

var objectStructOperations = {};

function strict(param) {
  var struct = this;
  var struct$1 = S.$$Object.strict(struct);
  return Object.assign(struct$1, objectStructOperations);
}

function strip(param) {
  var struct = this;
  var struct$1 = S.$$Object.strip(struct);
  return Object.assign(struct$1, objectStructOperations);
}

function factory(definer) {
  var struct = S.object(function (o) {
        var definition = {};
        var fieldNames = Object.keys(definer);
        for(var idx = 0 ,idx_finish = fieldNames.length; idx < idx_finish; ++idx){
          var fieldName = fieldNames[idx];
          var struct = definer[fieldName];
          definition[fieldName] = S.field(o, fieldName, struct);
        }
        return definition;
      });
  return Object.assign(struct, objectStructOperations);
}

Object.assign(objectStructOperations, structOperations);

Object.assign(objectStructOperations, {
      strict: strict,
      strip: strip
    });

var $$Error = {};

var Result = {};

var $$Object = {
  factory: factory
};

exports.$$Error = $$Error;
exports.Result = Result;
exports.string = string;
exports.$$boolean = $$boolean;
exports.integer = integer;
exports.number = number;
exports.never = never;
exports.unknown = unknown;
exports.optional = optional;
exports.nullable = nullable;
exports.array = array;
exports.record = record;
exports.json = json;
exports.union = union;
exports.literal = literal;
exports.nan = nan;
exports.defaulted = defaulted;
exports.custom = custom;
exports.$$Object = $$Object;
/*  Not a pure module */
